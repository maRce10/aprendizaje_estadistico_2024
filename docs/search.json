[
  {
    "objectID": "preparacion_curso.html",
    "href": "preparacion_curso.html",
    "title": "1 Instalacion de software",
    "section": "",
    "text": "1 Instalacion de software\n\nInstalá o actualizá R en el ordenador que utilizarás durante el curso (https://cran.r-project.org). Asumo que ya lo tenés instalado, pero intentá actualizarlo si tenés una versión de R &lt; 4.0.0. Puedes averiguar qué versión de R tenés ejecutando esto en la consola de R:\n\n\n\nCódigo\nversion$version.string\n\n\n\nActualizá todos los paquetes de R si ya tenías instalado R (⚠️ este paso puede tardar mucho en ejecutarse ⚠️):\n\n\n\nCódigo\nupdate.packages(ask = FALSE)\n\n\n\nInstalá R en la computadora que utilizarás durante el curso (https://cran.r-project.org/). Probablemente ya lo tenés instalado, pero intentá actualizarlo si tenés una versión de R &lt; 4.0.0. Podés encontrar qué versión de R tenés ejecutando esto en la consola de R:\n\n\n\nCódigo\nversion$version.string\n\n\n\nInstalá la interfaz de RStudio (https://posit.co/download/rstudio-desktop/, elejí la versión gratuita).\nAbrí RStudio y seleccioná la pestaña “Tools” y luego “Global options” (última opción). Seleccioná la opción “Code”, luego seleccioná la casilla de “Soft wrap”.\nTambién en Rstudio: Seleccioná la opción “Pane Layout” y mové “Source” al panel superior izquierdo y “Console” al panel superior derecho. Esta disposición asigna más espacio en la pantalla a los paneles más útiles. Dalé “Apply” y “Ok”. Para aquellos que no estén familiarizados con RStudio, “Source” es un editor de texto donde se escribe el código y donde guardas el código en un archivo físico (normalmente en formato .R) y la consola evalúa el código que se envia desde el “Source” e imprime los resultados (si los hay). Podés escribir código en la consola, pero no se guardará en un archivo físico.\nAhora en la consola de R en Rstudio ejecutá el siguiente código para instalar los paquetes que estaremos usando durante el curso:\n\n\n\nCódigo\n# # cargar funciones del paquete \"sketchy\"\n# source(\n#   paste0(\n#     \"https://raw.githubusercontent.com/maRce10/\",\n#     \"sketchy/main/R/load_packages.R\"\n#   )\n# )\n# source(\n#   paste0(\n#     \"https://raw.githubusercontent.com/maRce10/\",\n#     \"sketchy/main/R/internal_functions.R\"\n#   )\n# )\n# \n# instalar paquete sketchy para instalar otros paquetes y creer proyectos\n# install.packages(\"sketchy\")\n\n# cargar paquete\nlibrary(sketchy)\n\n# instalar/ cargar paquetes\nload_packages(\n  packages = c(\n    \"remotes\",\n    \"RColorBrewer\",\n    \"ggplot2\",\n    \"viridis\",\n    \"MASS\",\n    \"psych\",\n    \"lme4\",\n    \"caret\",\n    \"glmnet\",\n    \"lmerTest\",\n    \"sjPlot\",\n    \"car\",\n    \"nnet\",\n    \"neuralnet\",\n    \"randomForest\",\n    \"dimRed\",\n    github = \"maRce10/sketchy\"\n  )\n)\n\n\n\nCreá un proyecto para el curso corriendo este código:\n\n\n\nCódigo\nlibrary(sketchy)\n\nmake_compendium(\n  name = \"r_avanzado\",\n  path = \"DIRECTORIO_DONDE_HACER_EL_PROYECTO\",\n  Rproj = TRUE,\n  readme = TRUE\n)\n\n\n(en realidad este es tambien un compendio de investigación)\nAbrí el proyecto en Rstudio:\n\nEste proyecto debe usarse cada vez que se trabaja código del curso ✌️\n\n\n2 Recursos adicionales\n\nIntroducción a Rstudio video\nkaggle: juegos de datos de ejemplo link:\nDatos para classificar personalidad\nR data sets: link"
  },
  {
    "objectID": "ggplot2.html",
    "href": "ggplot2.html",
    "title": "Gráficos con ggplot2",
    "section": "",
    "text": "Comprender la lógica detras de la estructura los gráficos con ggplot2\nSer capaz de intregrar en un gŕafico diferentes fuentes de información que representen la complejidad de los datos"
  },
  {
    "objectID": "ggplot2.html#ggplot2",
    "href": "ggplot2.html#ggplot2",
    "title": "Gráficos con ggplot2",
    "section": "ggplot2",
    "text": "ggplot2\n\nUn paquete de R diseñado específicamente para producir gráficos\nA diferencia de otros paquetes, ggplot2 tiene su propia gramática\nLa gramática se basa en la “Gramática de los gráficos” (Wilkinson 2005)\nMódulos independientes que pueden combinarse de muchas formas\nEsta gramática proporciona una gran flexibilidad"
  },
  {
    "objectID": "ggplot2.html#gramática-de-gráficos",
    "href": "ggplot2.html#gramática-de-gráficos",
    "title": "Gráficos con ggplot2",
    "section": "0.1 Gramática de gráficos",
    "text": "0.1 Gramática de gráficos\nLa idea principal es empezar con una capa base de datos brutos y luego añadir más capas de anotaciones y resúmenes estadísticos. El paquete nos permite producir gráficos utilizando la misma estructura de pensamiento que utilizamos al diseñar un análisis, reduciendo la distancia de cómo visualizamos un gráfico en la cabeza y el producto final.\nAprender la gramática no sólo es útil para producir un gráfico de interés, sino también para pensar en otros gráficos más complejos. La ventaja de esta gramática es la posibilidad de crear nuevos gráficos compuestos por nuevas combinaciones de elementos."
  },
  {
    "objectID": "ggplot2.html#componentes-del-gráfico",
    "href": "ggplot2.html#componentes-del-gráfico",
    "title": "Gráficos con ggplot2",
    "section": "0.2 Componentes del gráfico",
    "text": "0.2 Componentes del gráfico\nTodos los gráficos ggplot2 contienen los siguientes componentes:\n\nDatos - El objeto R con la información que necesita ser trazada\nCapas - Los datos específicos que serán graficados (ej. ‘x’ & ‘y’)\nEscala - Rango de datos a incluir\nCoordenadas - Sistema de coordenadas (no se utiliza muy a menudo)\nParcelas (facets) - Determina cómo dividir los datos en subparcelas en un multipanel\nTema - Controla el estilo del gráfico\n\n \nEstos componentes se juntan utilizando “+”.\nLa sintaxis más habitual incluye los datos dentro de la llamada “ggplot” y una capa “geom_”.\n \nPrimero instala/carga el paquete:\n\n\nCódigo\n# install\ninstall.packages(\"ggplot2\")\n\n# load library\nlibrary(ggplot2)"
  },
  {
    "objectID": "ggplot2.html#gráficos-de-dispersión",
    "href": "ggplot2.html#gráficos-de-dispersión",
    "title": "Gráficos con ggplot2",
    "section": "0.3 Gráficos de dispersión",
    "text": "0.3 Gráficos de dispersión\nUtilicemos el conjunto de datos “iris” para crear gráficos de dispersión:\n\n\nCódigo\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n \nThis plot is defined by 3 components: 1. “data”- iris 1. “aes” - Sepal.length vs Petal.length 1. “layer” - Points (geom)"
  },
  {
    "objectID": "ggplot2.html#atributos-estéticos",
    "href": "ggplot2.html#atributos-estéticos",
    "title": "Gráficos con ggplot2",
    "section": "0.4 Atributos estéticos",
    "text": "0.4 Atributos estéticos\nTambién podemos añadir otros atributos estéticos como el color, la forma y el tamaño. Estos atributos se pueden incluir dentro de aes():\n\n\nCódigo\n# color by species\nggplot(\n  data = iris,\n  mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nCódigo\n# color and shape by species\nggplot(\n  data = iris,\n  mapping = aes(\n    x = Sepal.Length,\n    y = Petal.Length,\n    color = Species,\n    shape = Species\n  )\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n \nTenga en cuenta que los argumentos estéticos también pueden incluirse en la capa “geom”:\n\n\nCódigo\nggplot(\n  data = iris,\n  mapping = aes(x = Sepal.Length, y = Petal.Length)\n) +\n  geom_point(aes(color = Species, shape = Species))\n\n\n\n\n\n\n\n\n\n \nTambién podemos incluir un valor fijo:\n\n\nCódigo\nggplot(\n  data = iris,\n  mapping = aes(x = Sepal.Length, y = Petal.Length)\n) +\n  geom_point(color = \"red2\")\n\n\n\n\n\n\n\n\n\n \nAlgunos atributos funcionan mejor con algunos tipos de datos:\n\nColor y forma: variables categóricas\nTamaño: variables continuas\n\n \n\n\nEjercicio 1\nUtilizando el conjunto de datos “hylaeformis”:\n\n\nCódigo\n# lear desde el sitio del curso\nhylaeformis_data &lt;- read.csv(\n  paste0(\"https://raw.githubusercontent.com/maRce10/\", \"r_avanzado_2023/master/data/hylaeformis_data.csv\")\n)\n\n# or bajar manualmente y leer copia local\nhylaeformis_data &lt;- read.csv(\"hylaeformis_data.csv\", stringsAsFactors = FALSE)\n\nhead(hylaeformis_data, 20)\n\n\n\n1.1 Create a scatter plot of vs “meanfreq” (mean frequency)\n1.1 Crear un gráfico de dispersión de duración (“duration”) vs frecuencia promedio (“meanfreq”)\n\n1.2 Añadir un atributo estético para mostrar un color diferente para cada localidad\n\n1.3 Añade otro atributo estético para mostrar el rango de frecuencia dominante (“dfrange”) como tamaño los símbolos"
  },
  {
    "objectID": "ggplot2.html#gráficos-multipanel-facetting",
    "href": "ggplot2.html#gráficos-multipanel-facetting",
    "title": "Gráficos con ggplot2",
    "section": "0.5 Gráficos multipanel (Facetting)",
    "text": "0.5 Gráficos multipanel (Facetting)\n\nOtra forma de visualizar variables categóricas\nPermite crear gráficos multipanel para cada nivel de la variable\n2 tipos: “grid” & “wrap”\n\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species)\n\n\n\n\n\n\n\n\n\nCódigo\n# o\n\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_grid(~Species)\n\n\n\n\n\n\n\n\n\n \nLa escala puede ser fija o libre para los ejes x e y, y puede modificarse el número de columnas y filas:\n\n\nCódigo\n# free x\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species, scales = \"free_x\")\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# free x and 3 rows\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species, scales = \"free_y\", nrow = 3)\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# both free and 2 rows\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species, scales = \"free\", nrow = 2)\n\n\n\n\n\n\n\n\n\n \nTenga en cuenta que también podemos guardar el componente básico como un objeto R y añadir otros componentes más adelante en el código:\n\n\nCódigo\np &lt;- ggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point()\n\np + facet_wrap(~Species, scales = \"free_x\", nrow = 3)"
  },
  {
    "objectID": "ggplot2.html#geoms-adicionales",
    "href": "ggplot2.html#geoms-adicionales",
    "title": "Gráficos con ggplot2",
    "section": "0.6 “geoms” adicionales",
    "text": "0.6 “geoms” adicionales\n\ngeom_smooth() - añade las líneas de mejor ajuste (incluyendo CI)\ngeom_boxplot() - Distribución de frecuencias\ngeom_histogram() & geom_freqpoly() - distribuciones de frecuencia\ngeom_bar() - distribución de frecuencias de variables categóricas\ngeom_path() & geom_line() - añade líneas a los gráficos de dispersión\n\n \n\n0.6.1 geom_smooth()\nLas líneas de regresión de mejor ajuste pueden añadirse con geom_smooth():\n\n\nCódigo\n# con CI\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  facet_wrap(~Species, scales = \"free\", nrow = 3)\n\n\n\n\n\n\n\n\n\nCódigo\n# sin CI\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  facet_wrap(~Species, scales = \"free\", nrow = 3)\n\n\n\n\n\n\n\n\n\n \n\nEjercicio 2\nUtilizando el conjunto de datos de ejemplo “msleep”:\n\n2.1 Crear un gráfico de dispersión de peso corporal (“bodywt”) frente a peso cerebral (“brainwt”)\n\n2.2 Añadir orden (“order”) como estética del color\n\n2.3 Añadir un componente “faceta” para dividir los gráficos por orden utilizando escalas libres\n\n2.4 Elimine los órdenes con menos de 4 especies en el conjunto de datos y haga un gráfico similar al 2.3\n\n2.5 Añadir una línea de mejor ajuste a cada gráfico del panel\n\n\n\n\n0.6.2 Boxplots\nDe nuevo, sólo se necesita un nuevo componente “geom” para crear un boxplot:\n\n\nCódigo\nggplot(iris, aes(Species, Petal.Length)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\nUna alternativa interesante son los gráficos de violines:\n\n\nCódigo\nggplot(iris, aes(Species, Petal.Length)) +\n  geom_violin()\n\n\n\n\n\n\n\n\n\n \n\n\n0.6.3 Histogramas\nLo mismo ocurre con los histrogramas y los gráficos de frecuencias:\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_histogram()\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_freqpoly()\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_histogram() +\n  geom_freqpoly()\n\n\n\n\n\n\n\n\n\n \nPodemos controlar la anchura de las barras:\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_histogram(binwidth = 1, fill = adjustcolor(\"red2\", alpha.f = 0.3))\n\n\nWarning: Duplicated aesthetics after name standardisation: fill\n\n\n\n\n\n\n\n\n\n \nY compara la distribución de los distintos grupos dentro del mismo histograma:\n\n\nCódigo\nggplot(iris, aes(Petal.Length, fill = Species)) +\n  geom_histogram(binwidth = 0.4)\n\n\n\n\n\n\n\n\n\n \n\n\n0.6.4 Gráfico de barras\nMuestran la distribución de variables discretas (categóricas):\n\n\nCódigo\ntab &lt;- table(msleep$order)\n\ndf &lt;-\n  as.data.frame(table(msleep$order[msleep$order %in% names(tab)[tab &gt; 3]]))\n\nggplot(df, aes(Var1, Freq)) +\n  geom_bar(stat = \"identity\")"
  },
  {
    "objectID": "ggplot2.html#personalización-de-ggplots",
    "href": "ggplot2.html#personalización-de-ggplots",
    "title": "Gráficos con ggplot2",
    "section": "0.7 Personalización de ggplots",
    "text": "0.7 Personalización de ggplots\nAdemás de las funciones básicas (por ejemplo, componentes) descritas anteriormente, ggplot tiene muchas otras herramientas (tanto argumentos como funciones adicionales) para personalizar aún más los gráficos. Prácticamente todo se puede modificar. Aquí vemos algunas de las herramientas más comunes.\n \n\n0.7.1 Temas\nggplot2 viene con algunos temas por defecto que se pueden aplicar fácilmente para modificar el aspecto de nuestros gráficos:\n\n\nCódigo\np &lt;- ggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point()\n\np + theme_classic()\n\n\n\n\n\n\n\n\n\nCódigo\np + theme_bw()\n\n\n\n\n\n\n\n\n\nCódigo\np + theme_minimal()\n\n\n\n\n\n\n\n\n\n \nLa mayoría de los temas difieren en el uso de cuadrículas, líneas de borde y patrones de etiquetado de ejes.\n \n\n\n0.7.2 Personalización de ejes\nLos límites de los ejes pueden modificarse como sigue:\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  xlim(c(0, 10))\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n  geom_point() +\n  xlim(c(0, 10)) +\n  ylim(c(0, 9))\n\n\n\n\n\n\n\n\n\n \nLos ejes también pueden transformarse:\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n  geom_point() +\n  scale_x_continuous(trans = \"log\") +\n  scale_y_continuous(trans = \"log2\")\n\n\n\n\n\n\n\n\n\n \no invertidos:\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n  geom_point() +\n  scale_y_reverse()\n\n\n\n\n\n\n\n\n\n\n\n0.7.3 Guardar ggplots\nLos ggplots pueden exportarse como archivos de imagen utilizando la función ggsave:\n\n\nCódigo\nggplot(\n  data = msleep[msleep$order %in% names(tab)[tab &gt; 5], ],\n  mapping = aes(x = bodywt, y = brainwt)\n) +\n  geom_point() +\n  facet_wrap(~order, scales = \"free\")\n\n\nWarning: Removed 21 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nCódigo\n# Export\nggsave(\"plot.png\", width = 5, height = 5)\n\n\nWarning: Removed 21 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n \nEl tipo de archivo de imagen se identificará por la extensión en el nombre del archivo\n \nPersonalización adicional del eje:\n\n\nCódigo\n# Log2 scaling of the y axis (with visually-equal spacing)\nrequire(scales)\n\np + scale_y_continuous(trans = log2_trans())\n\n\n\n\n\n\n\n\n\nCódigo\n# show exponents\np + scale_y_continuous(\n  trans = log2_trans(),\n  breaks = trans_breaks(\"log2\", function(x) 2^x),\n  labels = trans_format(\"log2\", math_format(2^.x))\n)\n\n\n\n\n\n\n\n\n\nCódigo\n# Percent\np + scale_y_continuous(labels = percent)\n\n\n\n\n\n\n\n\n\nCódigo\n# dollar\np + scale_y_continuous(labels = dollar)\n\n\n\n\n\n\n\n\n\nCódigo\n# scientific\np + scale_y_continuous(labels = scientific)\n\n\n\n\n\n\n\n\n\nCódigo\n### Agregar \"tick marks\" ###\n\n# Cargar librerías\nlibrary(MASS)\n\ndata(Animals)\n\n# x and y axis are transformed and formatted\np2 &lt;- ggplot(Animals, aes(x = body, y = brain)) +\n  geom_point(size = 4) +\n  scale_x_log10(\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x))\n  ) +\n  scale_y_log10(\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x))\n  ) +\n  theme_bw()\n\n# log-log plot without log tick marks\np2\n\n\n\n\n\n\n\n\n\nCódigo\n# Show log tick marks\np2 + annotation_logticks()\n\n\n\n\n\n\n\n\n\nCódigo\n# # Log ticks on left and right\np2 + annotation_logticks(sides = \"lr\")\n\n\n\n\n\n\n\n\n\nCódigo\n# All sides\np2 + annotation_logticks(sides = \"trbl\")\n\n\n\n\n\n\n\n\n\n \n\n\n0.7.4 Otros gráficos\nSe pueden generar muchos otros tipos de gráficos. Aquí muestro un ejemplo de gráficos de contorno y de “mapa de calor”:\n\n\nCódigo\nhead(faithful)\n\n\n\n\n\n\neruptions\nwaiting\n\n\n\n\n3.600\n79\n\n\n1.800\n54\n\n\n3.333\n74\n\n\n2.283\n62\n\n\n4.533\n85\n\n\n2.883\n55\n\n\n\n\n\n\nCódigo\nggplot(faithfuld, aes(eruptions, waiting)) +\n  geom_contour(aes(z = density, colour = after_stat(level)))\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(faithfuld, aes(eruptions, waiting)) +\n  geom_raster(aes(fill = density))"
  },
  {
    "objectID": "ggplot2.html#otros-paquetes-de-gráficos-en-r",
    "href": "ggplot2.html#otros-paquetes-de-gráficos-en-r",
    "title": "Gráficos con ggplot2",
    "section": "0.8 Otros paquetes de gráficos en R",
    "text": "0.8 Otros paquetes de gráficos en R\n\nggvis (ggplots interactivos)\nvcd (Warnes 2015)\nplotrix (Lemon et al. 2006)\ngplots (Warnes 2015)\n\nConsulte la CRAN Graphics Task View para obtener una lista más completa de herramientas gráficas en R."
  },
  {
    "objectID": "ggplot2.html#references",
    "href": "ggplot2.html#references",
    "title": "Gráficos con ggplot2",
    "section": "0.9 References",
    "text": "0.9 References\n\nLemon J (2006) Plotrix: a package in the red light district of R. R-News 6(4):8–12\nWarnes GR, Bolker B, Bonebakker L, Gentleman R, Liaw WHA, Lumley T, Maechler M, Magnusson A, Moeller S, Schwartz M, Venables B (2015) gplots: various R programming tools for plotting data. R package version 2.17.0. https://CRAN.R-project.org/package=gplots\nWickham H (2010) A layered grammar of graphics. J Comput Graph Stat 19(1):3–28\nWilkinson L (2005) The grammar of graphics. Statistics and computing, 2nd edn. Springer, New York\n\n\n\nInformación de la sesión\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] scales_1.3.0       viridis_0.6.5      viridisLite_0.4.2  MASS_7.3-55       \n[5] RColorBrewer_1.1-3 ggplot2_3.5.1      knitr_1.48         kableExtra_1.4.0  \n\nloaded via a namespace (and not attached):\n [1] Matrix_1.6-5      gtable_0.3.5      jsonlite_1.8.9    dplyr_1.1.4      \n [5] compiler_4.3.2    tidyselect_1.2.1  xml2_1.3.6        stringr_1.5.1    \n [9] gridExtra_2.3     textshaping_0.3.7 splines_4.3.2     systemfonts_1.1.0\n[13] yaml_2.3.10       fastmap_1.2.0     lattice_0.20-45   R6_2.5.1         \n[17] labeling_0.4.3    generics_0.1.3    isoband_0.2.7     htmlwidgets_1.6.4\n[21] tibble_3.2.1      munsell_0.5.1     svglite_2.1.3     pillar_1.9.0     \n[25] rlang_1.1.4       utf8_1.2.4        stringi_1.8.4     xfun_0.47        \n[29] cli_3.6.3         mgcv_1.8-39       withr_3.0.1       magrittr_2.0.3   \n[33] digest_0.6.37     grid_4.3.2        rstudioapi_0.16.0 nlme_3.1-155     \n[37] lifecycle_1.0.4   vctrs_0.6.5       evaluate_1.0.0    glue_1.8.0       \n[41] farver_2.1.2      ragg_1.2.7        fansi_1.0.6       colorspace_2.1-1 \n[45] rmarkdown_2.28    tools_4.3.2       pkgconfig_2.0.3   htmltools_0.5.8.1"
  },
  {
    "objectID": "como_simular_datos.html",
    "href": "como_simular_datos.html",
    "title": "Simulación de datos",
    "section": "",
    "text": "Paquetes a utilizar en este manual:\nCódigo\n# instalar/cargar paquetes\n\nsketchy::load_packages(\n  c(\"ggplot2\", \n    \"viridis\"\n    )\n  )"
  },
  {
    "objectID": "como_simular_datos.html#generación-de-números-aleatorios-en-r",
    "href": "como_simular_datos.html#generación-de-números-aleatorios-en-r",
    "title": "Simulación de datos",
    "section": "1.1 Generación de números aleatorios en R",
    "text": "1.1 Generación de números aleatorios en R\nLa estadística nos permite inferir patrones en los datos. Solemos utilizar conjuntos de datos reales para enseñar estadística. Sin embargo, puede ser circular entender el funcionamiento interno de una herramienta estadística probando su capacidad para inferir un patrón que no estamos seguros de encontrar en los datos (y no tenemos idea del mecanismo que produjo ese patrón). Las simulaciones nos permiten crear escenarios controlados en los que conocemos con seguridad los patrones presentes en los datos y los procesos subyacentes que los han generado.\nR ofrece algunas funciones básicas para la simulación de datos. Las más utilizadas son las funciones generadoras de números aleatorios. Los nombres de estas funciones comienzan con r (r____()). Por ejemplo, runif():\n\n\nCódigo\n# simular variable uniforme\nunif_var &lt;- runif(n = 100, min = 0, max = 10)\n\n\n \nEl resultado es un vector numérico de longitud 100 (n = 100):\n\n\nCódigo\n# imprimir variable\nunif_var\n\n\n  [1] 9.889093 3.977455 1.156978 0.697487 2.437494 7.920104 3.400624 9.720625\n  [9] 1.658555 4.591037 1.717481 2.314771 7.728119 0.963015 4.534478 0.847007\n [17] 5.606659 0.087046 9.857371 3.165848 6.394489 2.952232 9.967037 9.060213\n [25] 9.887391 0.656457 6.270388 4.904750 9.710244 3.622208 6.799935 2.637199\n [33] 1.857143 1.851432 3.792967 8.470244 4.980761 7.905856 8.384639 4.569039\n [41] 7.994758 3.819431 7.597012 4.367756 9.042177 3.195349 0.825691 8.162891\n [49] 8.984762 9.664964 5.730689 7.200795 7.740586 6.277608 7.229893 3.868313\n [57] 1.627908 1.872283 3.912495 2.739012 1.919177 5.043918 7.638404 6.936689\n [65] 5.440542 6.590872 4.687284 4.818055 3.370636 4.245263 2.870151 6.011915\n [73] 8.407423 6.208370 1.345516 5.677224 4.434263 4.379754 6.236172 9.326533\n [81] 8.884926 8.785406 2.421769 7.414538 3.876563 0.789517 0.948356 7.621427\n [89] 3.478940 4.167667 3.440162 0.084109 9.115750 1.822054 7.228034 5.719633\n [97] 5.400364 3.549474 8.240918 1.861368\n\n\n \nPodemos explorar el resultado graficando un histograma:\n\n\nCódigo\n# crear histograma\nggplot(data = data.frame(unif_var), mapping = aes(x = unif_var)) + geom_histogram()\n\n\n\n\n\n\n\n\n\n \nMuestra una distribución uniforme que va de 0 a 10.\nTambién podemos simular números aleatorios procedentes de una distribución normal utilizando rnorm():\n\n\nCódigo\n# crear una variable normal\nnorm_var &lt;- rnorm(n = 1000, mean = 2, sd = 1)\n\n# graficar histograma\nggplot(data = data.frame(norm_var), mapping = aes(x = norm_var)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n \nTenga en cuenta que todas las funciones generadoras de números aleatorios tienen el argumento ‘n’, que determina la longitud del vector generado (es decir, el número de números aleatorios), además de algunos argumentos adicionales relacionados con parámetros específicos de la distribución.\nLas variables continuas (es decir, los vectores numéricos) pueden convertirse en variables discretas (es decir, números enteros) simplemente redondeándolas:\n\n\nCódigo\nv1 &lt;- rnorm(n = 5, mean = 10, sd = 3)\n\nv1\n\n\n[1] 15.4269  8.5450 15.1387  8.9203  9.3693\n\n\nCódigo\nround(x = v1, digits = 0)\n\n\n[1] 15  9 15  9  9\n\n\n \n\nEjercicio 1\n\n¿Qué hacen las funciones rbinom() y rexp()?\nEjecútela y haga histogramas de sus resultados\n¿Qué hacen los argumentos ‘mean’ y ‘sd’ en rnorm()? Juegue con diferentes valores y comprueba el histograma para hacerse una idea de su efecto en la simulación"
  },
  {
    "objectID": "como_simular_datos.html#generación-de-variables-categóricas",
    "href": "como_simular_datos.html#generación-de-variables-categóricas",
    "title": "Simulación de datos",
    "section": "1.2 Generación de variables categóricas",
    "text": "1.2 Generación de variables categóricas\nLa forma más sencilla de generar variables categóricas es utilizar el vector de ejemplo letters' (oLETTERS’) para asignar niveles de categoría. Podemos hacerlo utilizando la función rep(). Por ejemplo, el siguiente código crea un vector categórico (caracteres) con dos niveles, cada uno con 4 observaciones:\n\n\nCódigo\nrep(letters[1:2], each = 4)\n\n\n[1] \"a\" \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"b\"\n\n\n \nTambién podemos replicar este patrón utilizando el argumento ‘times’. Este código replica el vector anterior 2 veces:\n\n\nCódigo\nrep(letters[1:2], each = 4, times = 2)\n\n\n [1] \"a\" \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"b\" \"a\" \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"b\"\n\n\n \nOtra opción es simular una variable a partir de una distribución binomial y luego convertirla en un factor:\n\n\nCódigo\n# correr rbinom\nbinom_var &lt;- rbinom(n = 50, size = 1, prob = 0.5)\n\nbinom_var\n\n\n [1] 1 0 0 1 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 1 0 0\n[39] 1 1 0 0 0 0 0 1 0 1 1 1\n\n\n\n\nCódigo\n# convertir a factor\ncateg_var &lt;- factor(binom_var, labels = c(\"a\", \"b\"))\n\ncateg_var\n\n\n [1] b a a b b a a a a a a a b b b a a b a b a a a a a a a b a b b b a a a b a a\n[39] b b a a a a a b a b b b\nLevels: a b"
  },
  {
    "objectID": "como_simular_datos.html#muestreo-aleatorio",
    "href": "como_simular_datos.html#muestreo-aleatorio",
    "title": "Simulación de datos",
    "section": "1.3 Muestreo aleatorio",
    "text": "1.3 Muestreo aleatorio\nLa otra herramienta importante de R para jugar con datos simulados es sample(). Esta función permite tomar muestras de tamaños específicos de vectores. Por ejemplo, tomemos el ejemplo del vector ‘letters’:\n\n\nCódigo\nletters\n\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n \nPodemos tomar una muestra de este vector como es:\n\n\nCódigo\n# tomar muestra\nsample(x = letters, size = 10)\n\n\n [1] \"i\" \"r\" \"q\" \"a\" \"c\" \"m\" \"y\" \"z\" \"u\" \"v\"\n\n\n \nEl argumento ‘size’ nos permite determinar el tamaño de la muestra. Tenga en cuenta que obtendremos un error si el tamaño es mayor que el propio vector:\n\n\nCódigo\nsample(x = letters, size = 30)\n\n\nError in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when 'replace = FALSE'\n\n\n \nEsto sólo puede hacerse cuando el muestreo es con reemplazo (replacement). El muestreo con reemplazo puede aplicarse estableciendo el argumento replace = TRUE:\n\n\nCódigo\nsample(x = letters, size = 30, replace = TRUE)\n\n\n [1] \"j\" \"i\" \"h\" \"i\" \"k\" \"u\" \"n\" \"i\" \"w\" \"k\" \"c\" \"t\" \"m\" \"p\" \"i\" \"h\" \"d\" \"w\" \"c\"\n[20] \"q\" \"j\" \"e\" \"e\" \"j\" \"k\" \"c\" \"l\" \"t\" \"r\" \"h\""
  },
  {
    "objectID": "como_simular_datos.html#iterar-un-proceso",
    "href": "como_simular_datos.html#iterar-un-proceso",
    "title": "Simulación de datos",
    "section": "1.4 Iterar un proceso",
    "text": "1.4 Iterar un proceso\nA menudo, las simulaciones deben repetirse varias veces para descartar resultados espurios debidos al azar o simplemente para probar diferentes parámetros. Las funciones de simulación de datos mencionadas anteriormente pueden ejecutarse varias veces (por ejemplo, iteradas) utilizando la función replicate():\n\n\nCódigo\n# replicar\nrepl_rnorm &lt;- replicate(n = 3, expr = rnorm(2), simplify = FALSE)\n\n# ver clase\nclass(repl_rnorm)\n\n\n[1] \"list\"\n\n\nCódigo\n# imprimir\nrepl_rnorm\n\n\n[[1]]\n[1]  1.19184 -0.33992\n\n[[2]]\n[1]  0.78911 -0.63213\n\n[[3]]\n[1] -1.49312 -0.13441"
  },
  {
    "objectID": "como_simular_datos.html#hacer-que-las-simulaciones-sean-reproducibles",
    "href": "como_simular_datos.html#hacer-que-las-simulaciones-sean-reproducibles",
    "title": "Simulación de datos",
    "section": "1.5 Hacer que las simulaciones sean reproducibles",
    "text": "1.5 Hacer que las simulaciones sean reproducibles\nEl último truco que necesitamos para ejecutar simulaciones en R es la capacidad de reproducir una simulación (es decir, obtener exactamente los mismos datos y resultados simulados). Esto puede ser útil para que otros investigadores puedan ejecutar nuestros análisis exactamente de la misma manera. Esto puede hacerse fácilmente con la función set.seed(). Pruebe a ejecutar el siguiente código. Debería obtener la misma salida:\n\n\nCódigo\n# definir semilla\nset.seed(10)\n\n# crear variable uniforme\nrunif(n = 2)\n\n\n[1] 0.50748 0.30677"
  },
  {
    "objectID": "como_simular_datos.html#juegos-de-datos-con-variables-numéricas-y-categóricas",
    "href": "como_simular_datos.html#juegos-de-datos-con-variables-numéricas-y-categóricas",
    "title": "Simulación de datos",
    "section": "2.1 Juegos de datos con variables numéricas y categóricas",
    "text": "2.1 Juegos de datos con variables numéricas y categóricas\nAhora que sabemos cómo simular variables continuas y categóricas. Podemos juntarlas para crear conjuntos de datos simulados. Esto se puede hacer utilizando la función data.frame():\n\n\nCódigo\n# crear variable categorica\ngrupo &lt;- rep(letters[1:2], each = 3)\n\n# crear variable continuaa\ntamano &lt;- rnorm(n = 6, mean = 5, sd = 1)\n\n# poner juntas en un data frame\ndf &lt;- data.frame(grupo, tamano)\n\n# imprimir\ndf\n\n\n\n\n\n\ngrupo\ntamano\n\n\n\n\na\n4.8158\n\n\na\n3.6287\n\n\na\n4.4008\n\n\nb\n5.2946\n\n\nb\n5.3898\n\n\nb\n3.7919\n\n\n\n\n\n\nPor supuesto, podríamos añadir más variables a este cuadro de datos:\n\n\nCódigo\n# crear variable categorica\ngrupo &lt;- rep(letters[1:2], each = 3)\nindividuo &lt;- rep(LETTERS[1:6])\n\n# crear variables continuas\ntamano &lt;- rnorm(n = 6, mean = 5, sd = 1)\npeso &lt;- rnorm(n = 6, mean = 100, sd = 10)\n\n# poner todo en un data frame\ndf &lt;- data.frame(grupo, individuo, tamano, peso)\n\n# imprimir\ndf\n\n\n\n\n\n\ngrupo\nindividuo\ntamano\npeso\n\n\n\n\na\nA\n4.6363\n109.874\n\n\na\nB\n3.3733\n107.414\n\n\na\nC\n4.7435\n100.893\n\n\nb\nD\n6.1018\n90.451\n\n\nb\nE\n5.7558\n98.049\n\n\nb\nF\n4.7618\n109.255\n\n\n\n\n\n\nY eso es un juego de datos simulados en su forma más básica. Se parece mucho al tipo de datos con los que trabajamos en biología."
  },
  {
    "objectID": "como_simular_datos.html#prueba-de-concepto-el-teorema-del-límite-central",
    "href": "como_simular_datos.html#prueba-de-concepto-el-teorema-del-límite-central",
    "title": "Simulación de datos",
    "section": "3.1 Prueba de concepto: el Teorema del Límite Central",
    "text": "3.1 Prueba de concepto: el Teorema del Límite Central\nEl Teorema del Límite Central afirma que, si tomamos muestras aleatorias de una población, los promedios de esas muestras seguirán una distribución normal, aunque la población no esté distribuida normalmente. Además, la distribución normal resultante debe tener un promedio cercano al promedio de la población. El teorema es un concepto clave para la estadística inferencial, ya que implica que los métodos estadísticos que funcionan para las distribuciones normales pueden ser aplicables a muchos problemas que implican otros tipos de distribuciones. No obstante, el objetivo aquí es sólo mostrar cómo se pueden utilizar las simulaciones para entender el comportamiento de los métodos estadísticos.\nPara comprobar si esas afirmaciones básicas sobre el Teorema del Límite Central son ciertas, podemos utilizar datos simulados en R. Vamos a simular una población de 1000 observaciones con una distribución uniforme:\n\n\nCódigo\n# simular popublacion uniforme\nunif_pop &lt;- runif(1000, min = 0, max = 10)\n\n# ver histograma\nggplot(data = data.frame(unif_pop), mapping = aes(x = unif_pop)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n \nPodemos tomar muestras aleatorias usando sample() así:\n\n\nCódigo\nsample(x = unif_pop, size = 30)\n\n\n [1] 9.28420 1.02626 2.57517 3.32485 6.89990 2.29404 0.33737 8.21366 3.30364\n[10] 8.03793 2.59174 7.81770 5.65426 0.63831 2.83470 4.20434 4.76330 4.42193\n[19] 6.97830 7.92625 0.68121 3.52323 6.51103 5.38289 7.97210 1.80062 4.21282\n[28] 3.33866 8.91223 4.71163\n\n\n \nEste proceso puede ser replicado varias veces con replicate():\n\n\nCódigo\n# replicar\nsamples &lt;- replicate(n = 100, expr = mean(sample(x = unif_pop, size = 30)))\n\n\n \nEl código anterior toma 100 muestras con 30 valores cada una. Ahora podemos comprobar la distribución de las muestras:\n\n\nCódigo\n# ver distribucion/ histograma\nggplot(data = data.frame(samples), mapping = aes(x = samples)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n \n… asi como el promedio:\n\n\nCódigo\nmean(samples)\n\n\n[1] 5.0212\n\n\n \nComo era de esperar, las muestras siguen una distribución normal con una media cercana a la media de la población, que es:\n\n\nCódigo\nmean(unif_pop)\n\n\n[1] 5.0527\n\n\n \nProbemos con una distribución más compleja. Por ejemplo, una distribución bimodal:\n\n\nCódigo\n# usar semilla\nset.seed(123)\n\n# simular variables\nnorm1 &lt;- rnorm(n = 1000, mean = 10, sd = 3)\nnorm2 &lt;- rnorm(n = 1000, mean = 20, sd = 3)\n\n# juntar en una sola variable\nbimod_pop &lt;- c(norm1, norm2)\n\n# ver histograma\nggplot(data = data.frame(bimod_pop), mapping = aes(x = bimod_pop)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# replicar muestreo\nsamples &lt;- replicate(200, mean(sample(bimod_pop, 10)))\n\n# ver histograma\nggplot(data = data.frame(samples), mapping = aes(x = samples)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# ver promedios\nmean(samples)\n\n\n[1] 15.231\n\n\nCódigo\nmean(bimod_pop)\n\n\n[1] 15.088\n\n\n \n\nEjercicio 2\n \n\nIntenta explorar el Teorema del Límite Central como en el caso anterior, pero esta vez utilizando:\n\nUna distribución exponencial (rexp())\nUna distribución log-normal (rlnorm())\n\n\n \n\nPara cada distribución: grafique un histograma y compare los promedios de la población y de las muestras"
  },
  {
    "objectID": "como_simular_datos.html#referencias",
    "href": "como_simular_datos.html#referencias",
    "title": "Simulación de datos",
    "section": "3.2 Referencias",
    "text": "3.2 Referencias\n\nR’s rbinom – Simulate Binomial or Bernoulli trials\nR’s rnorm – selecting values from a normal distribution\nR’s exp – Simulating Exponential Distributions\nSimulating data in R"
  },
  {
    "objectID": "fundamentos_de_r.html",
    "href": "fundamentos_de_r.html",
    "title": "Elementos básicos del lenguaje R",
    "section": "",
    "text": "Familiarizarse con los bloques básicos usados en la programación en R\nConocer las fuentes principales de documentación estandarizada en R"
  },
  {
    "objectID": "fundamentos_de_r.html#section",
    "href": "fundamentos_de_r.html#section",
    "title": "Elementos básicos del lenguaje R",
    "section": "2.1  ",
    "text": "2.1"
  },
  {
    "objectID": "fundamentos_de_r.html#objetos-que-contienen-datos",
    "href": "fundamentos_de_r.html#objetos-que-contienen-datos",
    "title": "Elementos básicos del lenguaje R",
    "section": "3.1 Objetos que contienen datos",
    "text": "3.1 Objetos que contienen datos\nLa estructura de datos básica en R es el vector. Con este se contruyen todas las otras clases de objetos. Para entender las clases es útil pensar en el número de dimensiones (1, 2 o mas) y tipos de datos que pueden contener: homogéneos (un único tipo de elemento) o homogéneos (o múltiples tipos de elementos).\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    D(Objetos de Datos) --&gt; D1(1 dimension)\n    D --&gt; D2(2 dimensiones)\n    D1 --&gt; V(Vector)\n    D1 --&gt; L(Lista)\n    D2 --&gt; M(Matriz)\n    D2 --&gt;  DF(\"Cuadro de Datos &lt;br&gt;(Data Frame)\")\n\n    style D fill:#40498E66, stroke:#000, stroke-width:2px, color:#FFF, width:180px\n    style D1 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style D2 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style DF fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style V fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style M fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style L fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHomogéneo\nHeterogéneo\n\n\n\n\n1d\nVector atómico\nLista\n\n\n2d\nMatriz\nCuadro de datos (data frame)\n\n\nnd\narreglo (Array)\n\n\n\n\n\n\n\n\n3.1.1 Objetos de 1 dimensión\nHay dos tipos básicos de vectores: vectores atómicos y listas.\nTienen tres propiedades comunes:\n\nTipo, typeof() (clase/modo ~)\nLongitud, length() (número de elementos)\nAttributes, attributes() (metadatos)\n\nSe diferencian en los tipos de sus elementos: todos los elementos de un vector atómico deben ser del mismo tipo, mientras que los elementos de una lista pueden tener diferentes tipos.\n\n3.1.1.1 Vectores atomicos\nTipos de vectores atómicos:\n\nLógico (booleano)\nEntero\nNumérico (doble)\nCaracteres\nFactores\n\nLos vectores se construyen con la función c(), Pueden ser numérico:\n\n\nCódigo\nx &lt;- 1\nx1 &lt;- c(1)\n\nall.equal(x, x1)\n\n\n[1] TRUE\n\n\nCódigo\nclass(x)\n\n\n[1] \"numeric\"\n\n\nDe caracteres:\n\n\nCódigo\ny &lt;- \"algo\"\n\nclass(y)\n\n\n[1] \"character\"\n\n\nLógico:\n\n\nCódigo\nz &lt;- TRUE\n\nclass(z)\n\n\n[1] \"logical\"\n\n\nO factor:\n\n\nCódigo\nq &lt;- factor(1)\n\nclass(q)\n\n\n[1] \"factor\"\n\n\n \nPor tanto, los números o cadenas individuales son en realidad vectores de longitud uno:\n\n\nCódigo\nclass(1)\n\n\n[1] \"numeric\"\n\n\nCódigo\nclass(\"a\")\n\n\n[1] \"character\"\n\n\nLos vectores sólo pueden contener elementos del mismo tipo. Los tipos diferentes de elementos serán forzados al tipo más flexible:\n\n\nCódigo\nx &lt;- c(1, 2, \"a\")\n\nx\n\n\n[1] \"1\" \"2\" \"a\"\n\n\nCódigo\nclass(x)\n\n\n[1] \"character\"\n\n\n \nLos valores que faltan se especifican con NA, que es un vector lógico de longitud 1. NA siempre será interpretado al tipo correcto si se utiliza dentro de c():\n\n\nCódigo\nv &lt;- c(10, 11, NA)\n\nclass(v)\n\n\n[1] \"numeric\"\n\n\nCódigo\nv &lt;- c(\"a\", \"b\", NA)\n\nclass(v)\n\n\n[1] \"character\"\n\n\n\n\n3.1.1.2 Factores\nLos vectores con factores son muy simulares a los de caracteres. Sin embargo, un factor sólo puede contener valores predefinidos, conocidos como niveles. Los atributos se utilizan para definir los niveles del factor.\nLos factores se construyen sobre vectores enteros utilizando dos atributos:\n\nclase “factor”: hace que se comporten de forma diferente a los vectores de caracteres normales\nniveles: define el conjunto de valores permitidos\n\n\n\nCódigo\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n\n[1] a b b a\nLevels: a b\n\n\nCódigo\nlevels(x)\n\n\n[1] \"a\" \"b\"\n\n\nCódigo\nstr(x)\n\n\n Factor w/ 2 levels \"a\",\"b\": 1 2 2 1\n\n\n \nLos factores parecen vectores de caracteres, pero en realidad son números enteros:\n\n\nCódigo\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\n\nc(x)\n\n\n[1] a b b a\nLevels: a b\n\n\n\n\n3.1.1.3 Listas\nPuede contener objetos de diferentes clases y tamaños. Las listas se construyen con list():\n\n\nCódigo\nl &lt;- list(\"a\", 1, FALSE)\n\nl\n\n\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] FALSE\n\n\nCódigo\nclass(l)\n\n\n[1] \"list\"\n\n\nCódigo\nstr(l)\n\n\nList of 3\n $ : chr \"a\"\n $ : num 1\n $ : logi FALSE\n\n\nEn realidad pueden ser vistas como cajones donde se pueden poner cualquier otro tipo de objeto:\n\n\nCódigo\nl &lt;- list(c(\"a\", \"b\"), c(1, 2, 3, 4), c(FALSE, TRUE, FALSE))\n\nl\n\n\n[[1]]\n[1] \"a\" \"b\"\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] FALSE  TRUE FALSE\n\n\nCódigo\nstr(l)\n\n\nList of 3\n $ : chr [1:2] \"a\" \"b\"\n $ : num [1:4] 1 2 3 4\n $ : logi [1:3] FALSE TRUE FALSE\n\n\n\n\n\n3.1.2 Objetos de 2 dimensiones\n\n\n3.1.3 Matrices\nTodas los elementos son del mismo tipo:\n\n\nCódigo\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\ndim(m)\n\n\n[1] 2 3\n\n\nCódigo\nm\n\n\n     [,1] [,2] [,3]\n[1,]    1    3   12\n[2,]    2   11   13\n\n\nCódigo\nclass(m)\n\n\n[1] \"matrix\" \"array\" \n\n\nCódigo\nm &lt;- matrix(c(1, 2, 3, 11, 12, \"13\"), nrow = 2)\nm\n\n\n     [,1] [,2] [,3]\n[1,] \"1\"  \"3\"  \"12\"\n[2,] \"2\"  \"11\" \"13\"\n\n\n \n\n\n3.1.4 Cuadros de datos (data frames)\nCaso especial de las listas. Puede contener elementos de diferentes tipos:\n\n\nCódigo\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\ndim(m)\n\n\n[1] 5 3\n\n\nCódigo\nm\n\n\n\n\n\n\nID\nsize\nobserved\n\n\n\n\na\n1\nFALSE\n\n\nb\n2\nTRUE\n\n\nc\n3\nFALSE\n\n\nd\n4\nFALSE\n\n\ne\n5\nFALSE\n\n\n\n\n\n\nCódigo\nclass(m)\n\n\n[1] \"data.frame\"\n\n\nCódigo\nis.data.frame(m)\n\n\n[1] TRUE\n\n\nCódigo\nis.list(m)\n\n\n[1] TRUE\n\n\nCódigo\nstr(m)\n\n\n'data.frame':   5 obs. of  3 variables:\n $ ID      : chr  \"a\" \"b\" \"c\" \"d\" ...\n $ size    : num  1 2 3 4 5\n $ observed: logi  FALSE TRUE FALSE FALSE FALSE\n\n\n \nPero los vectores deben tener la misma longitud:\n\n\nCódigo\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5, 6),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\n\nError in data.frame(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), size = c(1, 2, 3, : arguments imply differing number of rows: 5, 6\n\n\n \n\n\n3.1.5 Ejercicio 1\n \n\nCree un vector numérico con 8 elementos que contenga números positivos y negativos\nCree un vector de caracteres con los nombres de las provincias de Costa Rica\nAñada al vector de punto anterior un NA\nCree una matriz numérica con 3 columnas y 3 filas\nCree una matriz de caracteres con 4 columnas y 3 filas\n¿Qué tipo de objeto es ‘iris’ y cuales son sus dimensiones? (pista: iris es un objeto disponible por omisión en su ambiente)\nCree un cuadro de datos (data frame) con una columna numérica, una columna de caracteres y una columna con factores"
  },
  {
    "objectID": "fundamentos_de_r.html#funciones-objetos-que-hacen-tareas",
    "href": "fundamentos_de_r.html#funciones-objetos-que-hacen-tareas",
    "title": "Elementos básicos del lenguaje R",
    "section": "3.2 Funciones: objetos que hacen tareas",
    "text": "3.2 Funciones: objetos que hacen tareas\nTodas las funciones se crean con la función function() y siguen la misma estructura:\n\n* Modified from Grolemund 2014  \n\n3.2.1 Funciones integradas\n\n3.2.1.1 Funciones básicas\nR viene con muchas funciones que puedes usar para hacer tareas sofisticadas:\n\n\nCódigo\n# built in functions\nbi &lt;- builtins(internal = FALSE)\n\nlength(bi)\n\n\n[1] 1388\n\n\n \nAlgunas funciones vienen de forma predeterminada con R básico. Nuevas funciones pueden ser cargadas como parte de paquetes adicionales o incluso creadas por el usuario.\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    F(Funciones) --&gt; BF(Funciones Integradas)\n    BF --&gt; OP(Operadores)\n    BF --&gt; BA(Funciones Básicas)\n    F --&gt; PF(Paquetes)\n    F --&gt; UF(Funciones Definidas por el Usuario)\n\n    class R,D,D1,D2,F largeText;\n\n    style F fill:#357BA266, stroke:#000, stroke-width:2px, color:#FFF, width:120px\n    style BF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n    style BA fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000\n    style OP fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000    \n    style PF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000000\n    style UF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n3.2.1.2 Operadores\nLos operadores son funciones:\n\n\nCódigo\n1 + 1\n\n\n[1] 2\n\n\nCódigo\n'+'(1, 1)\n\n\n[1] 2\n\n\nCódigo\n2 * 3\n\n\n[1] 6\n\n\nCódigo\n'*'(2, 3)\n\n\n[1] 6\n\n\n \n\n3.2.1.2.1 Operadores mas utilizados\nOperadores aritméticos:\n\n\n\n\n\n\nOperador\nDescrición\n\n\n\n\n+\nsuma\n\n\n-\nresta\n\n\n*\nmultiplicación\n\n\n/\ndivisión\n\n\n^ or **\nexponente\n\n\n\n\n\n\n\n\n\n\nCódigo\n1 - 2\n\n\n[1] -1\n\n\nCódigo\n1 + 2\n\n\n[1] 3\n\n\nCódigo\n2 ^ 2\n\n\n[1] 4\n\n\nCódigo\n2 ** 2\n\n\n[1] 4\n\n\nCódigo\n2:3 %in% 2:4\n\n\n[1] TRUE TRUE\n\n\n \nOperadores lógicos:\n\n\n\nOperador\nDescrición\n\n\n\n\n&lt;\nmenor que\n\n\n&lt;=\nmenor o igual que\n\n\n&gt;\nmayor que\n\n\n&gt;=\nmayor o igual que\n\n\n==\nexactamente igual que\n\n\n!=\ndiferente que\n\n\n!x\nNo es x\n\n\nx | y\nx O y\n\n\nx & y\nx Y y\n\n\nx %in% y\ncorrespondencia\n\n\n\n\n\nCódigo\n1 &lt; 2 \n\n\n[1] TRUE\n\n\nCódigo\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCódigo\n1 &lt;= 2 \n\n\n[1] TRUE\n\n\nCódigo\n1 == 2\n\n\n[1] FALSE\n\n\nCódigo\n1 != 2\n\n\n[1] TRUE\n\n\nCódigo\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCódigo\n5 %in% 1:6\n\n\n[1] TRUE\n\n\nCódigo\n5 %in% 1:4\n\n\n[1] FALSE\n\n\n \n\n\n\n\n3.2.2 Vectorización\nLa mayoría de las funciones están vectorizadas:\n\n\nCódigo\n1:6 * 1:6\n\n\n\n* Modified from Grolemund & Wickham 2017\n \n\n\n[1]  1  4  9 16 25 36\n\n\n\n\nCódigo\n1:6 - 1:6\n\n\n[1] 0 0 0 0 0 0\n\n\nR recicla vectores de longitud desigual:\n\n\nCódigo\n1:6 * 1:5\n\n\n\n* Modified from Grolemund & Wickham 2017\n\n \n\n3.2.3 Funciones de paquetes adicionales\nEstas son funciones que son incluidas en paquetes adicionales que se pueden instalar y cargar en R. Para ser utilizadas el paquete debe ser instalado y cargado.Por ejemplo para usar la función corTest del paquete “psych” primero debemos instalar. Los paquetes son instalados del servidor de CRAN (Comprehensive R Archive Network) con la función install.packages():\n\n\nCódigo\ninstall.packages(\"psych\")\n\n\n.. y cargar el paquete:\n\n\nCódigo\nlibrary(psych)\n\n\nUna vez instalado y cargado ‘psych’, podemos llamar a la función corTest:\n\n\nCódigo\ncorTest(iris$Sepal.Length, iris$Sepal.Width)\n\n\nCall:corTest(x = iris$Sepal.Length, y = iris$Sepal.Width)\nCorrelation matrix \n[1] -0.12\nSample Size \n[1] 150\nThese are the unadjusted probability values.\n  The probability values  adjusted for multiple tests are in the p.adj object. \n[1] 0.15\n\n To see confidence intervals of the correlations, print with the short=FALSE option\n\n\nEl uso de paquetes externos es la caracteristica mas util de R ya que permite hacer uso de un número casi infinito de funciones especializadas en diferentes tareas así como de campos muy diversos de la ciencia y la industria.\nPodemos explorar los paquetes disponibles para R en la página de CRAN (hacer click en el enlace “packages”).\n\n\n3.2.4 Ejercicio 2\n \n\nBusque un paquete que le interese en CRAN\nInstale el paquete y carguelo\nCorra el codigo de ejemplo de una de sus funciones"
  },
  {
    "objectID": "fundamentos_de_r.html#extraer-subconjuntos-usando-indexación-indexing",
    "href": "fundamentos_de_r.html#extraer-subconjuntos-usando-indexación-indexing",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.1 Extraer subconjuntos usando indexación (indexing)",
    "text": "4.1 Extraer subconjuntos usando indexación (indexing)\nLos elementos dentro de los objetos pueden ser llamados por medio de la indexación. Para sub-conjuntar un vector simplemente llame a la posición del objeto usando corchetes:\n\n\nCódigo\nx &lt;- c(1, 3, 4, 10, 15, 20, 50, 1, 6)\n\nx[1]\n\n\n[1] 1\n\n\nCódigo\nx[2]\n\n\n[1] 3\n\n\nCódigo\nx[2:3]\n\n\n[1] 3 4\n\n\nCódigo\nx[c(1,3)]\n\n\n[1] 1 4\n\n\n \nLos elementos se pueden eliminar de la misma manera:\n\n\nCódigo\nx[-1]\n\n\n[1]  3  4 10 15 20 50  1  6\n\n\nCódigo\nx[-c(1,3)]\n\n\n[1]  3 10 15 20 50  1  6\n\n\n \nLas matrices y los marcos de datos requieren 2 índices [fila, columna]:\n\n\nCódigo\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\nm[1, ]\n\n\n[1]  1  3 12\n\n\nCódigo\nm[, 1]\n\n\n[1] 1 2\n\n\nCódigo\nm[1, 1]\n\n\n[1] 1\n\n\nCódigo\nm[-1, ]\n\n\n[1]  2 11 13\n\n\nCódigo\nm[, -1]\n\n\n     [,1] [,2]\n[1,]    3   12\n[2,]   11   13\n\n\nCódigo\nm[-1, -1]\n\n\n[1] 11 13\n\n\nCódigo\ndf &lt;- data.frame(\n  provincia = c(\"San José\", \"Guanacaste\", \"Guanacaste\"), \n  canton = c(\"Montes de Oca\", \"Nicoya\", \"Liberia\"), \n    distrito = c(\"San Rafael\", \"Nosara\", \"Nacascolo\")\n  )\n\ndf\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[1, ]\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\n\n\n\n\nCódigo\ndf[, 1]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCódigo\ndf[1, 1]\n\n\n[1] \"San José\"\n\n\nCódigo\ndf[-1, ]\n\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\n2\nGuanacaste\nNicoya\nNosara\n\n\n3\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[, -1]\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\nMontes de Oca\nSan Rafael\n\n\nNicoya\nNosara\n\n\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[-1, -1]\n\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\n2\nNicoya\nNosara\n\n\n3\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[,\"provincia\"]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCódigo\ndf[,c(\"provincia\", \"canton\")]\n\n\n\n\n\n\nprovincia\ncanton\n\n\n\n\nSan José\nMontes de Oca\n\n\nGuanacaste\nNicoya\n\n\nGuanacaste\nLiberia\n\n\n\n\n\n\n \nLas listas requieren 1 índice entre dobles corchetes [[índice]]:\n\n\nCódigo\nl &lt;- list(c(\"a\", \"b\"),\n          c(1, 2, 3),\n          c(FALSE, TRUE, FALSE, FALSE))\n\nl[[1]]\n\n\n[1] \"a\" \"b\"\n\n\nCódigo\nl[[3]]\n\n\n[1] FALSE  TRUE FALSE FALSE\n\n\n \nLos elementos dentro de las listas también pueden ser subconjuntos en la misma cadena de código:\n\n\nCódigo\nl[[1]][1:2]\n\n\n[1] \"a\" \"b\"\n\n\nCódigo\nl[[3]][2]\n\n\n[1] TRUE"
  },
  {
    "objectID": "fundamentos_de_r.html#explorar-objectos",
    "href": "fundamentos_de_r.html#explorar-objectos",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.2 Explorar objectos",
    "text": "4.2 Explorar objectos\nLas siguientes funciones de R básico (predeterminadas) nos pueden ayudar a explorar la estructura de los objetos:\n\n\nCódigo\nstr(df)\n\n\n'data.frame':   3 obs. of  3 variables:\n $ provincia: chr  \"San José\" \"Guanacaste\" \"Guanacaste\"\n $ canton   : chr  \"Montes de Oca\" \"Nicoya\" \"Liberia\"\n $ distrito : chr  \"San Rafael\" \"Nosara\" \"Nacascolo\"\n\n\nCódigo\nnames(df)\n\n\n[1] \"provincia\" \"canton\"    \"distrito\" \n\n\nCódigo\ndim(df)\n\n\n[1] 3 3\n\n\nCódigo\nnrow(df)\n\n\n[1] 3\n\n\nCódigo\nncol(df)\n\n\n[1] 3\n\n\nCódigo\nhead(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ntail(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ntable(df$provincia)\n\n\n\nGuanacaste   San José \n         2          1 \n\n\nCódigo\nclass(df)\n\n\n[1] \"data.frame\"\n\n\n\n\nCódigo\nView(df)"
  },
  {
    "objectID": "fundamentos_de_r.html#ejercicio-3",
    "href": "fundamentos_de_r.html#ejercicio-3",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.3 Ejercicio 3",
    "text": "4.3 Ejercicio 3\n \n\nUtilice los datos de ejemplo iris para crear un subconjunto de datos con sólo las observaciones de la especie setosa\nAhora cree un subconjunto de datos que contenga las observaciones tanto de “setosa” como de “versicolor”\nTambién con iris cree un subconjunto de datos con las observaciones para las que iris$Sepal.length es mayor que 6\n¿Cuántas observaciones tienen una longitud de sépalo superior a 6?"
  },
  {
    "objectID": "fundamentos_de_r.html#section-1",
    "href": "fundamentos_de_r.html#section-1",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.4  ",
    "text": "4.4"
  },
  {
    "objectID": "fundamentos_de_r.html#nombres-de-archivos",
    "href": "fundamentos_de_r.html#nombres-de-archivos",
    "title": "Elementos básicos del lenguaje R",
    "section": "5.1 Nombres de archivos",
    "text": "5.1 Nombres de archivos\nLos nombres de los archivos deben terminar en .R y, por supuesto, ser auto-explicatorios:\n\nBien: graficar_probabilidad_posterior.R\nMal: graf.R"
  },
  {
    "objectID": "fundamentos_de_r.html#nombres-de-objetos",
    "href": "fundamentos_de_r.html#nombres-de-objetos",
    "title": "Elementos básicos del lenguaje R",
    "section": "5.2 Nombres de objetos",
    "text": "5.2 Nombres de objetos\nVariables y funciones:\n\nMinúsculas\nUtilice un guión bajo\nEn general, nombres para las variables y verbos para las funciones\nProcure que los nombres sean concisos y significativos (no siempre es fácil)\nAvoid using names of existing functions of variables\n\n\n\nCódigo\n  - Bien: dia_uno: dia_1, peso_promedio(),\n  \n  - Mal: diauno, dia1, primer.dia_delmes"
  },
  {
    "objectID": "fundamentos_de_r.html#syntaxis",
    "href": "fundamentos_de_r.html#syntaxis",
    "title": "Elementos básicos del lenguaje R",
    "section": "5.3 Syntaxis",
    "text": "5.3 Syntaxis\n\n5.3.1 Espacios\n\nUtilice espacios alrededor de los operadores y para los argumentos dentro de una función\nPonga siempre un espacio después de una coma, y nunca antes (como en el inglés normal)\nColoque un espacio antes del paréntesis izquierdo, excepto en una llamada a una función\n\n\n\nCódigo\n  - Bien: \n          a &lt;- rnorm(n = 10, sd = 10, mean = 1)\n          total &lt;- sum(x[1, ])\n\n  - Mal: \n         a&lt;-rnorm(n=10,sd=10,mean=1) \n         total &lt;- sum(x[,1])  \n\n\n \n\n5.3.1.1 Corchetes\n\nLa llave de apertura nunca debe ir en su propia línea\nLa llave de cierre debe ir siempre en su propia línea\nPuede omitir las llaves cuando un bloque consiste en una sola declaración\n\n\n\nCódigo\n  - Bien:\n              if (is.null(ylim)) {\n              ylim &lt;- c(0, 0.06)\n            }\n                      \n            if (is.null(ylim))\n              ylim &lt;- c(0, 0.06)\n          \n  - Mal:\n            \n         if (is.null(ylim)) ylim &lt;- c(0, 0.06)\n                    \n         if (is.null(ylim)) {ylim &lt;- c(0, 0.06)} \n\n         if (is.null(ylim)) {\n           ylim &lt;- c(0, 0.06)\n           } \n\n\n \n\n\n5.3.1.2 Crear objetos\n\nUse &lt;-, no =\n\n\n\nCódigo\n  - GOOD:\n         x &lt;- 5 \n          \n  - BAD:\n         x = 5\n\n\n \n\n\n5.3.1.3 Sugerencias para añadir comentarios\n\nComente su código\nLas líneas enteras comentadas deben comenzar con # y un espacio\nLos comentarios cortos pueden colocarse después del código precedido por dos espacios, #, y luego un espacio\n\n\n\nCódigo\n# Create histogram of frequency of campaigns by pct budget spent.\nhist(df$pct.spent,\n     breaks = \"scott\",  # method for choosing number of buckets\n     main   = \"Histograma: individuos por unidad de tiempo\",\n     xlab   = \"Número de individuos\",\n     ylab   = \"Frecuencia\")\n\n\n \n\n\n5.3.1.4 Disposición general y ordenación (estilo de google)\n\nComentario de la declaración de derechos de autor (?)\nComentario del autor\nComentario de la descripción del archivo, incluyendo el propósito del programa, las entradas y las salidas\ndeclaraciones source() y library()\nDefiniciones de funciones\nSentencias ejecutadas, si procede (por ejemplo, print, plot)"
  },
  {
    "objectID": "fundamentos_de_r.html#package-documentation",
    "href": "fundamentos_de_r.html#package-documentation",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.1 Package documentation",
    "text": "6.1 Package documentation\n\n \nReference manuals\nLos manuales de referencia son colecciones de la documentación de todas las funciones de un paquete (sólo 1 por paquete):\n\nmanual de dynaSpec\nmanual de baRulho"
  },
  {
    "objectID": "fundamentos_de_r.html#documentación-de-las-funciones",
    "href": "fundamentos_de_r.html#documentación-de-las-funciones",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.2 Documentación de las funciones",
    "text": "6.2 Documentación de las funciones\nTodas las funciones (por defecto o de paquetes cargados) deben tener una documentación que siga un formato estándar:\n\n\nCódigo\n?mean\n\nhelp(\"mean\")\n\n\n\nEsta documentación también puede mostrarse en Rstudio pulsando F1 cuando el cursor está en el nombre de la función\n \nSi no recuerda el nombre de la función pruebe con apropos():\n\n\nCódigo\napropos(\"mean\")\n\n\n [1] \".colMeans\"      \".rowMeans\"      \"circadian.mean\" \"circular.mean\" \n [5] \"colMeans\"       \"geometric.mean\" \"harmonic.mean\"  \"kmeans\"        \n [9] \"mean\"           \"mean.Date\"      \"mean.default\"   \"mean.difftime\" \n[13] \"mean.POSIXct\"   \"mean.POSIXlt\"   \"rowMeans\"       \"weighted.mean\" \n[17] \"winsor.mean\"    \"winsor.means\""
  },
  {
    "objectID": "fundamentos_de_r.html#viñetas-vignettes",
    "href": "fundamentos_de_r.html#viñetas-vignettes",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.3 Viñetas (vignettes)",
    "text": "6.3 Viñetas (vignettes)\nLas viñetas son documentos ilustrativos o casos de estudio que detallan el uso de un paquete (opcional, pueden ser varios por paquete).\nLas viñetas se pueden llamar directamente desde R:\n\n\nCódigo\nvgn &lt;- browseVignettes() \n\n\n\n\nCódigo\nvignette()\n\n\nTambién deberían aparecer en la página del paquete en CRAN."
  },
  {
    "objectID": "fundamentos_de_r.html#demonstraciones",
    "href": "fundamentos_de_r.html#demonstraciones",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.4 Demonstraciones",
    "text": "6.4 Demonstraciones\nLos paquetes también pueden incluir demostraciones de código extendidas (“demos”). Para listar las demos de un paquete ejecute demo(\"nombre del paquete\"):\n\n\nCódigo\ndemo(package=\"stats\")\n\n# call demo directly\ndemo(\"nlm\")"
  },
  {
    "objectID": "fundamentos_de_r.html#ejercicio-4",
    "href": "fundamentos_de_r.html#ejercicio-4",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.5 Ejercicio 4",
    "text": "6.5 Ejercicio 4\n \n\n¿Qué hace la función cut()?\n¿Para qué se utiliza el argumento breaks en cut()?\nEjecuta las 4 primeras líneas de código de los ejemplos proporcionados en la documentación de cut().\n¿Cuántas viñetas tiene el paquete warbleR?"
  },
  {
    "objectID": "fundamentos_de_r.html#referencias",
    "href": "fundamentos_de_r.html#referencias",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.6 Referencias",
    "text": "6.6 Referencias\n\nAdvanced R, H Wickham\nGoogle’s R Style Guide\n\nHands-On Programming with R (Grolemund, 2014)\n\n\nInformación de la sesión\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] psych_2.3.12\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       nlme_3.1-155      svglite_2.1.3     cli_3.6.3        \n [5] knitr_1.48        rlang_1.1.4       xfun_0.47         stringi_1.8.4    \n [9] highr_0.11        jsonlite_1.8.9    glue_1.8.0        colorspace_2.1-1 \n[13] htmltools_0.5.8.1 scales_1.3.0      rmarkdown_2.28    grid_4.3.2       \n[17] evaluate_1.0.0    munsell_0.5.1     kableExtra_1.4.0  fastmap_1.2.0    \n[21] yaml_2.3.10       lifecycle_1.0.4   stringr_1.5.1     compiler_4.3.2   \n[25] htmlwidgets_1.6.4 rstudioapi_0.16.0 lattice_0.20-45   systemfonts_1.1.0\n[29] digest_0.6.37     viridisLite_0.4.2 R6_2.5.1          parallel_4.3.2   \n[33] mnormt_2.1.1      magrittr_2.0.3    tools_4.3.2       xml2_1.3.6"
  },
  {
    "objectID": "programa.html#recursos-adicionales",
    "href": "programa.html#recursos-adicionales",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Badillo et al (2020). An introduction to machine learning"
  },
  {
    "objectID": "programa.html#recursos-adicionales-1",
    "href": "programa.html#recursos-adicionales-1",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Roediger et al (2001). Factors that determine false recall: A multiple regression analysis"
  },
  {
    "objectID": "programa.html#recursos-adicionales-2",
    "href": "programa.html#recursos-adicionales-2",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Chen et al (2023). Identifying the top determinants of psychological resilience among community older adults during COVID-19 in Taiwan: A random forest approach"
  },
  {
    "objectID": "programa.html#recursos-adicionales-3",
    "href": "programa.html#recursos-adicionales-3",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Choi et al. (2020). Introduction to machine learning, neural networks, and deep learning\nVideo: Random Forest Algorithm Clearly Explained"
  },
  {
    "objectID": "programa.html#recursos-adicionales-4",
    "href": "programa.html#recursos-adicionales-4",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nVideo: Convolutional Neural Networks (CNNs) explained\nVideo: Neural Network In 5 Minutes"
  },
  {
    "objectID": "programa.html#recursos-adicionales-5",
    "href": "programa.html#recursos-adicionales-5",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Yarkoni & Westfall. 2017. Choosing prediction over explanation in psychology: Lessons from machine learning\nVideo: ¿Que es una red neuronal?"
  },
  {
    "objectID": "programa.html#recursos-adicionales-6",
    "href": "programa.html#recursos-adicionales-6",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Yarkoni & Westfall. 2017. Choosing prediction over explanation in psychology: Lessons from machine learning\nVideo: Clustering in Machine Learning"
  },
  {
    "objectID": "evaluacion_de_modelos.html",
    "href": "evaluacion_de_modelos.html",
    "title": "Evaluación de modelos",
    "section": "",
    "text": "Familiarizarse con las metricas de evaluación de modelos de aprendizaje estadístico\nSer capaz de evaluar modelos de regresión y clasificación en R\nPaquetes a utilizar en este manual:\nCódigo\n# instalar/cargar paquetes\n\nsketchy::load_packages(\n  c(\"ggplot2\", \n    \"viridis\", \n    \"nnet\",\n    \"caret\",\n    \"glmnet\",\n    \"pROC\",\n    \"nnet\",\n    \"Metrics\")\n  )\nLa idea es evaluar la capacidad del modelo para hacer predicciones precisas y generalizar bien a datos no vistos. Por lo tanto, evaluar correctamente los modelos permite entender qué tan bien el modelo se ajusta a los datos e idealmente, entender si sus predicciones son útiles para datos no vistos. La naturaleza de la métrica depende de la estructura de los datos predichos (si estos son continuos o categóricos):\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    A(Evaluación de modelos) --&gt; B(Respuesta continua)\n    A --&gt; C(\"Respuesta categórica\")\n    B --&gt; D(RMSE)\n    B --&gt; E(R cuadrado)\n    C --&gt; F(\"Matriz de confusión\")\n    C --&gt; G(\"Precisión, Recall, F1\")\n    C --&gt; H(\"Pérdida logarítmica\")\n\n    style A fill:#40498E66, stroke:#000, stroke-width:2px, color:#FFF, width:180px\n    style B fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF \n    style C fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF\n    style D fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style E fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style F fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style G fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style H fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000"
  },
  {
    "objectID": "evaluacion_de_modelos.html#raíz-del-error-cuadrático-medio-rmse",
    "href": "evaluacion_de_modelos.html#raíz-del-error-cuadrático-medio-rmse",
    "title": "Evaluación de modelos",
    "section": "1.1 Raíz del Error Cuadrático Medio (RMSE)",
    "text": "1.1 Raíz del Error Cuadrático Medio (RMSE)\nLa raíz cuadrada del error cuadrático medio (RMSE por sus siglas en inglés) es quizás la medida mas comunmente utilizada para medir la precisión en la predicción de una variable continua. Las unidades de esta métrica son las mismas que la variable de respuesta. La podemos calcular fácilmente:\n\n\nCódigo\n# Generar datos simulados\nset.seed(123)\nx &lt;- rnorm(100)\ny &lt;- 3 * x + rnorm(100, sd = 0.5)\n\n# Crear un marco de datos\ndatos &lt;- data.frame(x = x, y = y)\n\n# correr modelo\nmod &lt;- lm(y ~ x, data = datos)\n\n# Step 2: Obtener predicciones\ny_pred &lt;- predict(mod)\n\n# Step 3: Calcular RMSE\nsqrt(mean((datos$y - y_pred)^2))\n\n\n[1] 0.48048\n\n\nLa raíz cuadrada del error cuadrático medio penaliza más los errores grandes, ya que los errores se elevan al cuadrado. Esto lo hace útil para detectar errores grandes que podrían ser problemáticos. Sin embargo, es sensible a outliers, ya que los errores grandes tienen un impacto más significativo en el resultado."
  },
  {
    "objectID": "evaluacion_de_modelos.html#coeficiente-de-determinación-r2",
    "href": "evaluacion_de_modelos.html#coeficiente-de-determinación-r2",
    "title": "Evaluación de modelos",
    "section": "1.2 Coeficiente de determinación R2",
    "text": "1.2 Coeficiente de determinación R2\nEl R2 indica qué proporción de la variabilidad en la variable respuesta es explicada por el modelo. Se calcula así:\n\n\nCódigo\nr2 &lt;- 1 - sum((datos$y - y_pred)^2) / sum((datos$y - mean(datos$y))^2)\n    \n# imprimir R^2\nr2\n\n\n[1] 0.96932\n\n\nEste es el mismo valor que se obtiene al evaluar el modelo con la función summary:\n\n\nCódigo\nsummary(mod)$r.squared\n\n\n[1] 0.96932\n\n\nEntre R2 sea mas cercano a 1 indica el modelo tiene mejor ajuste. Sin embargo, es importante tener en cuenta que un R2 alto no garantiza que el modelo sea útil o que generalice bien a nuevos datos. No es una buena métrica para modelos no lineales, ya que puede no reflejar bien la calidad del ajuste en estos casos.\n\nEjercicio 1\nLos datos mtcars se tomaron de la revista Motor Trend US de 1974, y contienen informacion sobre 10 características del diseño y desempeño de 32 marcas de carros.\n\n\nCódigo\n# cargar datos\ndata(mtcars)\n\n\n\nAjusta un modelo de regresión lineal con los datos de mtcars donde la variable respuesta sea mpg (millas por galón) y las variables predictoras sean hp (caballos de fuerza) y wt (peso).\n\n\nAjuste 2 modelos más, cada uno con 2 variables predictoras más que el modelo ajustado en el paso 1.\nCompare los modelos generados en los puntos 1 y 2 usando la raíz cuadrada del error cuadrático medio (RMSE) y el R2."
  },
  {
    "objectID": "evaluacion_de_modelos.html#matriz-de-confusión",
    "href": "evaluacion_de_modelos.html#matriz-de-confusión",
    "title": "Evaluación de modelos",
    "section": "2.1 Matriz de confusión",
    "text": "2.1 Matriz de confusión\nLa matriz de confusión organiza las predicciones y los resultados observados en categorías que indican si el valor predicho es una ocurrencia del evento (positivo vs negativo) y si coincide o no con el valor observado (verdadero vs falso).\n\n\n\n\n\n\n\n\n\nEsta matriz la podemos estimar usando la función confusionMatrix del paquete caret:\n\n\nCódigo\n# hacer la matriz de confusion\nmat_conf &lt;-\n    confusionMatrix(factor(pred_cat), factor(datos_tab_titanic$Survived))\n\n# imprimir resultado\nmat_conf$table\n\n\n          Reference\nPrediction   No  Yes\n       No  1364  367\n       Yes  126  344\n\n\nPodemos graficar esta matriz con un gradiente de colores donde los valores esten dado como proporciones, lo cual mas fácil su interpretación:\n\n\nCódigo\n# convertir a data frame\nconf_df &lt;- as.data.frame(mat_conf$table)\n\n# agregar totales por categoria\nconf_df$total &lt;-\n    sapply(conf_df$Reference, function(x)\n        sum(datos_tab_titanic$Survived ==\n                x))\n\n# calcular proporciones\nconf_df$proportion &lt;- conf_df$Freq / conf_df$total\n\n# graficar\nggplot(conf_df, aes(x = Reference, y = Prediction, fill = proportion)) +\n  geom_tile() + \n  coord_equal() + \n  scale_fill_distiller(palette = \"Greens\", direction = 1) + \n  geom_text(aes(label = round(proportion, 2)), color = \"black\", size = 3) + \n  labs(x = \"Observado\", y = \"Predicho\", fill = \"Proporción\") \n\n\n\n\n\n\n\n\n\nVarias métricas se derivan de los valores contenidos en la matriz de confusion."
  },
  {
    "objectID": "evaluacion_de_modelos.html#exactitud-accuracy",
    "href": "evaluacion_de_modelos.html#exactitud-accuracy",
    "title": "Evaluación de modelos",
    "section": "2.2 Exactitud (Accuracy)",
    "text": "2.2 Exactitud (Accuracy)\nLa exactitud es la proporción de predicciones correctas en relación con el total de predicciones.\nLa fórmula es:\n\n \\(\\frac{VP + VN}{VP + VN + FP + FN}\\) \n\nEsta también es estimada por la función confusionMatrix:\n\n\nCódigo\nmat_conf$overall[\"Accuracy\"]\n\n\nAccuracy \n 0.77601"
  },
  {
    "objectID": "evaluacion_de_modelos.html#precisión-precision-y-sensibilidad-sensitivity-o-recall",
    "href": "evaluacion_de_modelos.html#precisión-precision-y-sensibilidad-sensitivity-o-recall",
    "title": "Evaluación de modelos",
    "section": "2.3 Precisión (Precision) y Sensibilidad (Sensitivity o Recall)",
    "text": "2.3 Precisión (Precision) y Sensibilidad (Sensitivity o Recall)\nLa precisión es la proporción de verdaderos positivos entre todas las predicciones positivas:\n\n \\(\\frac{VP}{VP + FP}\\) \n\nLa sensibilidad es la proporción de verdaderos positivos entre todas las observaciones positivas:\n\n \\(\\frac{VP}{VP + FN}\\) \n\nAmbas son estimadas por la función confusionMatrix:\n\n\nCódigo\nmat_conf$byClass[c(\"Precision\", \"Sensitivity\")]\n\n\n  Precision Sensitivity \n    0.78798     0.91544"
  },
  {
    "objectID": "evaluacion_de_modelos.html#índice-f1-o-f-score",
    "href": "evaluacion_de_modelos.html#índice-f1-o-f-score",
    "title": "Evaluación de modelos",
    "section": "2.4 Índice F1 (o F-Score)",
    "text": "2.4 Índice F1 (o F-Score)\nEl índice F1 es la media armónica entre la precisión y la sensibilidad:\n\n \\(2 \\times \\frac{\\text{Precisión} \\times \\text{Sensibilidad}}{\\text{Precisión} + \\text{Sensibilidad}}\\) \n\n\n\nCódigo\nprecision &lt;- mat_conf$byClass[\"Precision\"]\nsensitivity &lt;- mat_conf$byClass[\"Sensitivity\"]\n\n\nf1_score &lt;- (2 * precision * sensitivity) / (precision + sensitivity)\n\nf1_score\n\n\nPrecision \n  0.84694 \n\n\nTambien lo podemos extraer del resultado de la función confusionMatrix:\n\n\nCódigo\n mat_conf$byClass[\"F1\"]\n\n\n     F1 \n0.84694"
  },
  {
    "objectID": "evaluacion_de_modelos.html#área-bajo-la-curva-roc-auc-roc",
    "href": "evaluacion_de_modelos.html#área-bajo-la-curva-roc-auc-roc",
    "title": "Evaluación de modelos",
    "section": "2.5 Área Bajo la Curva ROC (AUC-ROC)",
    "text": "2.5 Área Bajo la Curva ROC (AUC-ROC)\nEl AUC métrica originalmente diseñada para evaluar la precision en la predicción de variables binarias. Esta mide la capacidad del modelo para discriminar entre clases. Se calcula basándose en la curva ROC (Receiver Operating Characteristic). La curva ROC compara la tasa de verdaderos positivos contra la tasa de falsos positivos a diferentes umbrales.La curva ROC es una representación gráfica que evalúa el desempeño de un modelo de clasificación binaria. La curva muestra la relación entre la Tasa de Verdaderos Positivos (True Positive Rate, TPR), también llamada sensibilidad, y la Tasa de Falsos Positivos (False Positive Rate, FPR) para diferentes umbrales de decisión. Los umbrales de decisión son los valores que determinan si una observación se clasifica como positiva o negativa. Podemos ejemplificar su uso con el modelo de regresión logística ajustado mas arriba:\n\n\nCódigo\n# estimar las probabilidades\npred_vals &lt;- predict(object = modelo_log, newdata = datos_tab_titanic, type = \"response\")\n\n# Curva ROC\nroc_curve &lt;- roc(datos_tab_titanic$Survived, pred_vals)\n\n# Extraer los datos de la curva ROC\nroc_data &lt;- data.frame(\n  tpr = roc_curve$sensitivities, # True Positive Rate (Sensibilidad)\n  fpr = 1 - roc_curve$specificities, # False Positive Rate (1 - Especificidad)\n  thresholds = roc_curve$thresholds\n)\n\n# Graficar la curva ROC con ggplot2\nggplot(roc_data, aes(x = fpr, y = tpr)) +\n  geom_line(color = \"red\") +\n  geom_abline(linetype = \"dashed\", color = \"gray\") + # Línea diagonal\n  labs(\n    x = \"Tasa de Falsos Positivos (FPR)\",\n    y = \"Tasa de Verdaderos Positivos (TPR)\"\n  ) +\n  scale_x_continuous(limits = c(0, 1), expand = c(0, 0)) +  # Limitar el eje X entre 0 y 1\n  scale_y_continuous(limits = c(0, 1), expand = c(0, 0)) +  # Limitar el eje Y entre 0 y \n  theme_classic() +\n  theme(panel.grid = element_blank()) # Remover cuadrícula\n\n\n\n\n\n\n\n\n\nPodemos estimar el área bajo la curva con la función auc del paquete pROC:\n\n\nCódigo\n# estimar AUC\npROC::auc(roc_curve)\n\n\nArea under the curve: 0.747\n\n\nValores mas cercanos a 1 indican un mejor desempeño del modelo en discriminar entre clases tomando en cuenta la incertidumbre relacionada a la escogencia de un umbral de decisión.\nEn los modelos que predicen más de dos categorías (clasificación multiclase), no se puede aplicar la curva ROC directamente como en el caso binario. Aun así, hay métodos extendidos para calcular una métrica similar a la AUC para clasificación multiclase. Esta métrica se puede extender para modelos que predicen multiples clases. Por ejemplo el metodo de “uno vs el resto” (one vs rest) calcula una curva ROC para cada categoría de manera binaria, considerando una clase como “positiva” y las demás como “negativas”. Luego, se calcula el AUC para cada una de estas curvas ROC y se promedia. Para ejemplificar el uso de este método usaremos una regresión multinomial para predecir la especie de las observaciones del juego de datos iris:\n\n\nCódigo\n# Ajustar el modelo de regresión multinomial\nmodelo_multinom &lt;- multinom(Species ~ ., data = iris)\n\n\n# weights:  18 (10 variable)\ninitial  value 164.791843 \niter  10 value 16.177348\niter  20 value 7.111438\niter  30 value 6.182999\niter  40 value 5.984028\niter  50 value 5.961278\niter  60 value 5.954900\niter  70 value 5.951851\niter  80 value 5.950343\niter  90 value 5.949904\niter 100 value 5.949867\nfinal  value 5.949867 \nstopped after 100 iterations\n\n\nCódigo\n# Predecir las probabilidades para cada clase\npred_prob &lt;- predict(modelo_multinom, newdata = iris, type = \"prob\")\n\n# Aplicar multiclass.roc (One-vs-Rest)\nroc_multiclass &lt;- multiclass.roc(iris$Species, pred_prob)\n\n# Ver resultados\nroc_multiclass\n\n\n\nCall:\nmulticlass.roc.default(response = iris$Species, predictor = pred_prob)\n\nData: multivariate predictor pred_prob with 3 levels of iris$Species: setosa, versicolor, virginica.\nMulti-class area under the curve: 0.999"
  },
  {
    "objectID": "evaluacion_de_modelos.html#pérdida-logarítmica-log-loss",
    "href": "evaluacion_de_modelos.html#pérdida-logarítmica-log-loss",
    "title": "Evaluación de modelos",
    "section": "2.6 Pérdida logarítmica (log-loss)",
    "text": "2.6 Pérdida logarítmica (log-loss)\nMide el rendimiento de un modelo de clasificación al penalizar predicciones erróneas basadas en la probabilidad que asigna el modelo a cada clase.\n\n \\(-\\frac{1}{n} \\sum_{i=1}^{n} \\left[ y_i \\log(p_i) + (1 - y_i) \\log(1 - p_i) \\right]\\) \n\nDonde \\({y_i}\\) es el valor real (0 o 1) y \\({p_i}\\) es la probabilidad asignada a la clase positiva. Es útil cuando se desea medir la confianza del modelo en sus predicciones y no solo si acierta o falla. Aunque puede ser más complejo de interpretar en comparación con otras métricas.\n\n\nCódigo\n# Convertir las etiquetas reales a una matriz de indicadores (one-hot encoding)\ny_obs &lt;- model.matrix(~Species-1, data = iris)\n\n# Calcular el log-loss\nlog_loss_value &lt;- logLoss(y_obs, pred_prob)\nlog_loss_value\n\n\n[1] 0.026444\n\n\nEl valor del pérdida logarítmica representa qué tan bien o mal el modelo predice las clases correctas. Un valor más bajo (mas cerano a 0) indica un mejor ajuste, mientras que un valor alto sugiere que el modelo está asignando bajas probabilidades a las clases correctas. El valor de pérdida logarítmica puede tomar cualquier valor real no negativo, y en general se encuentra entre 0 y ∞."
  },
  {
    "objectID": "evaluacion_de_modelos.html#ejercicio-2",
    "href": "evaluacion_de_modelos.html#ejercicio-2",
    "title": "Evaluación de modelos",
    "section": "Ejercicio 2",
    "text": "Ejercicio 2\n\nAjusta un modelo de regresión logística con los datos de mtcars donde la variable respuesta sea am (automático vs manual) y las variables predictoras hp (caballos de fuerza) y wt (peso).\n\n\n\nCódigo\n# ajustar modelo\nmod_mtcars_log &lt;- glm(am ~ hp + wt, data = mtcars, family = binomial)\n\n\n\nCalcule la matriz de confusión, la exactitud, precisión, indice F1, area bajo la curva y pérdida logarítmica para el modelo del punto anterior.\nGrafique el area bajo la curva para el modelo del punto 1.\nAjuste 2 modelos más, cada uno con 2 variables predictoras más que el modelo ajustado en el punto 1 de este ejercicio.\nCompare los modelos generados en los puntos 1 y 4 usando las mismas métricas calculadas en el punto 2."
  }
]