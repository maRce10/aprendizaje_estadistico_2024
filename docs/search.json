[
  {
    "objectID": "reportes_dinamicos.html",
    "href": "reportes_dinamicos.html",
    "title": "Reportes dinámicos",
    "section": "",
    "text": "Familiarizarse con el formato para reportes dinámicos Rmarkdown/quarto\nSer capaz de documentar el manejo y análisis de datos en R usando Rmarkdown/quarto\nPaquetes a utilizar en este manual:\nCódigo\n# cargar paquetes\n\nsketchy::load_packages(\n    c(\n      \"leaflet\",\n      \"remotes\",\n      \"hadley/emo\",\n      \"maRce10/sketchy\",\n      \"knitr\",\n      \"rmarkdown\",\n      \"rmdformats\",\n      \"revealjs\",\n      \"rticles\",\n      \"tufte\"\n    )\n)"
  },
  {
    "objectID": "reportes_dinamicos.html#ventajas-de-los-reportes-dinámicos-con-rmarkdownquarto",
    "href": "reportes_dinamicos.html#ventajas-de-los-reportes-dinámicos-con-rmarkdownquarto",
    "title": "Reportes dinámicos",
    "section": "1.1 Ventajas de los reportes dinámicos con Rmarkdown/quarto:",
    "text": "1.1 Ventajas de los reportes dinámicos con Rmarkdown/quarto:\n\nEl código R se puede incrustar en el informe, por lo que no es necesario mantener el informe y el código de R por separado\nIncluir el código R directamente en un informe proporciona una estructura intuitiva para reproducir los análisis\nEl texto del informe está escrito como texto normal, por lo que no se requieren conocimientos de programación (i.e. R o HTML) para comprenderlos\nEl resultado es un archivo HTML que incluye imágenes, bloques de código con los comandos de R, los resultados de estos códigos y texto. No se necesitan archivos adicionales, todo está incorporado en el archivo HTML.\nLos informes son fáciles de compartir por correo o publicarlos en línea\nEstos informes facilitan la colaboración y mejoran la reproducibilidad (entender los análisis es mucho mas fácil cuando hay texto explicativo, código de R, los resultados del código y los gráficos en un mismo archivo)\nSe actualizan fácilmente para incluir nuevos análisis y/o integrar nuevos datos"
  },
  {
    "objectID": "reportes_dinamicos.html#ejercicio-1",
    "href": "reportes_dinamicos.html#ejercicio-1",
    "title": "Reportes dinámicos",
    "section": "2.1 Ejercicio 1",
    "text": "2.1 Ejercicio 1\nCree un nuevo archivo R Markdown o quarto, escriba algunas líneas de texto y haga clic en “Knit” para ver cómo se verá su reporte."
  },
  {
    "objectID": "reportes_dinamicos.html#crear-encabezados-de-varios-tamaños",
    "href": "reportes_dinamicos.html#crear-encabezados-de-varios-tamaños",
    "title": "Reportes dinámicos",
    "section": "3.1 Crear encabezados de varios tamaños",
    "text": "3.1 Crear encabezados de varios tamaños\nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:"
  },
  {
    "objectID": "reportes_dinamicos.html#encabezado-2",
    "href": "reportes_dinamicos.html#encabezado-2",
    "title": "Reportes dinámicos",
    "section": "4.1 Encabezado 2",
    "text": "4.1 Encabezado 2\n\n4.1.1 Encabezado 3"
  },
  {
    "objectID": "reportes_dinamicos.html#opciones-del-texto",
    "href": "reportes_dinamicos.html#opciones-del-texto",
    "title": "Reportes dinámicos",
    "section": "4.2 Opciones del texto",
    "text": "4.2 Opciones del texto\n \nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:\nHacer texto en negrita, itálico, tachado, o superíndice"
  },
  {
    "objectID": "reportes_dinamicos.html#añadir-una-imagen",
    "href": "reportes_dinamicos.html#añadir-una-imagen",
    "title": "Reportes dinámicos",
    "section": "4.3 Añadir una imagen",
    "text": "4.3 Añadir una imagen\nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:\n\n\n\n\n\n\n\n\n\nTambién podemos añadir una imagen con la función include_graphics() del paquete knitr.\nCódigo:\n\n\nCódigo\ninclude_graphics(\"./images/rmarkdown_icon.png\")\n\n\nResultado:\n\n\n\n\n\n\n\n\n\nNote que esta opción nos permite hacer uso de los argumentos del bloque de código dedicados a la graficación, y po r tanto es una opción mas flexible."
  },
  {
    "objectID": "reportes_dinamicos.html#crear-enlaces-hyperlinks",
    "href": "reportes_dinamicos.html#crear-enlaces-hyperlinks",
    "title": "Reportes dinámicos",
    "section": "4.4 Crear enlaces (‘hyperlinks’)",
    "text": "4.4 Crear enlaces (‘hyperlinks’)\nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:\nCrear un enlace a figshare"
  },
  {
    "objectID": "reportes_dinamicos.html#ejercicio-2",
    "href": "reportes_dinamicos.html#ejercicio-2",
    "title": "Reportes dinámicos",
    "section": "4.5 Ejercicio 2",
    "text": "4.5 Ejercicio 2\n2.1 Cree unos encabezados y sub-encabezados en su documento Rmarkdown\n2.2 Añada texto con algunas palabras en negrita y en italica\n2.3 Incruste una imagen de su organismo favorito (o un gif)\n2.4 Añada un enlace URL"
  },
  {
    "objectID": "reportes_dinamicos.html#incrustar-código",
    "href": "reportes_dinamicos.html#incrustar-código",
    "title": "Reportes dinámicos",
    "section": "4.6 Incrustar código",
    "text": "4.6 Incrustar código\nPara incrustar el código de R, tenemos que definir un área donde se encuentra el código. Esta ‘área’ se conoce como un bloque de código (o ‘chunk’) y se define mediante:\n\n\n\n\n\n\n\n\n\n \nObserve que el recuadro de R está en gris, mientras que el resto está en fondo blanco. Todo lo que se incluye en el segmento se evalúa y muestra de acuerdo con las especificaciones, aunque estas se pueden modificar.\n \nPodemos, por ejemplo, agregar una nueva columna al conjunto de datos de ejemplo de iris:\n\n\n\n\n\n\n\n\n\nResultado:\n\n\nCódigo\ndata(iris)\n\niris$random.var &lt;- rnorm(n = nrow(iris))\n\nhead(iris)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\nrandom.var\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n-2.88831\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n-0.00326\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n-1.06776\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n-0.63799\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n0.83498\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n-1.45957\n\n\n\n\n\n\n \nCuando se procesa su documento, el segmento de código se muestra en un cuadro gris y los resultados de ese código se muestran en un cuadro blanco. ¿Qué pasa si solo desea que se muestre la salida de su código? ¿O que su código se muestre pero no se ejecute realmente? Hay argumentos que puede agregar a cada uno de sus bloques para especificar estas y otras opciones:"
  },
  {
    "objectID": "reportes_dinamicos.html#ocultar-código",
    "href": "reportes_dinamicos.html#ocultar-código",
    "title": "Reportes dinámicos",
    "section": "4.7 Ocultar código",
    "text": "4.7 Ocultar código\nAñadir el argumento echo=FALSE\nCódigo:\n\n\n\n\n\n\n\n\n\nResultado:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\nrandom.var\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n-1.03174\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n-0.45448\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n1.36253\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n-0.15313\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n0.48837\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n-0.90335\n\n\n\n\n\n\n \nPuede ver que el código está oculto pero se muestran los resultados.\nEsta guía sobre las opciones de los bloques de código puede ser muy útil:\n\n\n\n\n\n\n\n\n\n \nEn este enlace se detallan todos los argumentos disponibles para personalizar los bloques de código."
  },
  {
    "objectID": "reportes_dinamicos.html#incrustar-gráficos",
    "href": "reportes_dinamicos.html#incrustar-gráficos",
    "title": "Reportes dinámicos",
    "section": "4.8 Incrustar gráficos",
    "text": "4.8 Incrustar gráficos\nLos gráficos se pueden incrustar en documentos Rmarkdown simplemente usando funciones de graficación como lo haría en un script de R normal.\n\n4.8.0.1 Código:\n\n\n\n\n\n\n\n\n\n \n\n\n4.8.0.2 Resultado:"
  },
  {
    "objectID": "reportes_dinamicos.html#ejercicio-3",
    "href": "reportes_dinamicos.html#ejercicio-3",
    "title": "Reportes dinámicos",
    "section": "4.9 Ejercicio 3",
    "text": "4.9 Ejercicio 3\n3.1 Utilice los argumentos eval, collapse con diferentes valores (TRUE o FALSE) en un segmento donde corre head(iris). ¿Cómo afectan el resultado?\n3.2 Haga lo mismo con los argumentos out.width, fig.width,dpi y fig.height en un segmento que cree un gráfico. ¿Cómo afecta esta vez?"
  },
  {
    "objectID": "reportes_dinamicos.html#incrustar-código-de-r-en-el-texto",
    "href": "reportes_dinamicos.html#incrustar-código-de-r-en-el-texto",
    "title": "Reportes dinámicos",
    "section": "4.10 Incrustar código de R en el texto",
    "text": "4.10 Incrustar código de R en el texto\nEs posible que haya notado a lo largo de este tutorial que tengo pequeños fragmentos de texto que parecen “bloques de código”. Esto se conoce como incrustación de código en texto.\nEsto se puede hacer de dos maneras:\n\n4.10.0.1 1.Dar un texto con la apariencia de un segmento de código:\n\n\n\n4.10.0.2 Código:\n\n\n\n\n\n\n\n\n\n \n\n\n4.10.0.3 Resultado:\nEl promedio del largo del sépalo es mean(iris$Sepal.Length)\n \n\n\n4.10.0.4 2. Evaluar el código en el texto\n\n\n4.10.0.5 Código:\n\n\n\n\n\n\n\n\n\n\n\n4.10.0.6 Resultado:\nEl promedio del largo de sépalo para setosa es 5.006."
  },
  {
    "objectID": "reportes_dinamicos.html#metadatos-yaml",
    "href": "reportes_dinamicos.html#metadatos-yaml",
    "title": "Reportes dinámicos",
    "section": "5.1 Metadatos (YAML)",
    "text": "5.1 Metadatos (YAML)\nHay tres componentes básicos de un documento de R Markdown: los metadatos, el texto y el código. Los metadatos se escriben entre el par de tres guiones (“- - -”) generalmente al inicio del documento. La sintaxis de los metadatos es YAML (YAML Ain’t Markup Language), por lo que a veces también se denomina metadatos YAML. La sangría es importante en YAML, así que debe añadirla a los subcampos (con respecto a un campo superior).\nEste encabezado muestra las opciones mas comúnmente usadas en los metadatos YAML:\n\n\nCódigo\n---\ntitle: \"Un titulo descriptivo y sin faltas ortograficas\"\nauthor: \"Marcelo Araya\"\ndate: \"`r Sys.Date()`\"\noutput: # Varios outputs mostrados solo para el ejemplo\n  html_document:\n    fig_caption: yes\n    number_sections: yes\n    toc: yes\n    toc_float: yes\n    df_print: paged\n---\n\n\nEn este enlace se explican en detalle las opciones disponibles en el encabezado YAML de archivos Rmarkdown."
  },
  {
    "objectID": "reportes_dinamicos.html#emojis",
    "href": "reportes_dinamicos.html#emojis",
    "title": "Reportes dinámicos",
    "section": "5.2 Emojis",
    "text": "5.2 Emojis\nEl paquete emo permite añadir emojis al evaluar un código:\n\nCódigo\nemo::ji(\"costa_rica\")\n\n🇨🇷\nTambien se puede incrustar en el texto 🇨🇷, como lo vimos mas arriba ⬆️ (ji(\"up_arrow\"))"
  },
  {
    "objectID": "reportes_dinamicos.html#cuadros-con-knitrkable",
    "href": "reportes_dinamicos.html#cuadros-con-knitrkable",
    "title": "Reportes dinámicos",
    "section": "5.3 Cuadros con knitr::kable",
    "text": "5.3 Cuadros con knitr::kable\nEl paquete knitr también provee una función para mostrar datos tabulares de forma ordenada y ‘limpia’ en los reportes dínamicos:\n\n\nCódigo\nknitr::kable(iris[1:10, ])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nSepal.Length\nSepal.Width\nPetal.Length\nPetal.Width\nSpecies\nrandom.var\n\n\n\n\n5.1\n3.5\n1.4\n0.2\nsetosa\n-1.03174\n\n\n4.9\n3.0\n1.4\n0.2\nsetosa\n-0.45448\n\n\n4.7\n3.2\n1.3\n0.2\nsetosa\n1.36253\n\n\n4.6\n3.1\n1.5\n0.2\nsetosa\n-0.15313\n\n\n5.0\n3.6\n1.4\n0.2\nsetosa\n0.48837\n\n\n5.4\n3.9\n1.7\n0.4\nsetosa\n-0.90335\n\n\n4.6\n3.4\n1.4\n0.3\nsetosa\n0.44255\n\n\n5.0\n3.4\n1.5\n0.2\nsetosa\n-1.51609\n\n\n4.4\n2.9\n1.4\n0.2\nsetosa\n0.30707\n\n\n4.9\n3.1\n1.5\n0.1\nsetosa\n-0.05960\n\n\n\n\n\n\n \nEl paquete kableExtra complementa esta función con muchas herramientas para personalizar el formato de las tablas en reportes dinámicos en R."
  },
  {
    "objectID": "reportes_dinamicos.html#opciones-adicionales-en-knitr",
    "href": "reportes_dinamicos.html#opciones-adicionales-en-knitr",
    "title": "Reportes dinámicos",
    "section": "5.4 Opciones adicionales en knitr",
    "text": "5.4 Opciones adicionales en knitr\nEl argumento opts_knit de knitr permite definir opciones globales (aplicables a todos los bloques a menos que se re-definan):\n\n\nCódigo\nopts_chunk$set(root.dir = \"..\", eval = TRUE, echo = FALSE)"
  },
  {
    "objectID": "reportes_dinamicos.html#presentaciones-y-otros-opciones-de-formato",
    "href": "reportes_dinamicos.html#presentaciones-y-otros-opciones-de-formato",
    "title": "Reportes dinámicos",
    "section": "5.5 Presentaciones y otros opciones de formato",
    "text": "5.5 Presentaciones y otros opciones de formato\nNote en la ventana de creación de un nuevo documento Rmarkdown las opciones adicionales de formato:\n\n\n\n\n\n\n\n\n\n \nLos reportes dinámicos se pueden generar en otros formatos incluyendo presentaciones, pdf y documentos de word."
  },
  {
    "objectID": "reportes_dinamicos.html#plantillas-de-rmarkdown",
    "href": "reportes_dinamicos.html#plantillas-de-rmarkdown",
    "title": "Reportes dinámicos",
    "section": "5.6 Plantillas de Rmarkdown",
    "text": "5.6 Plantillas de Rmarkdown\nEl paquete Rmarkdown puede generar resultados en HTML, PDF, MS Word, viñetas de paquetes de R, presentaciones Beamer y HTML5. Los formatos adicionales (o ‘variantes’ de estos formatos) están disponibles en otros paquetes de R. Algunos de esos paquetes son:\n\nrmdformats\nreveljs\nartículos\ntufte\n\nUna vez estos paquetes han sido instalados, los nuevos formatos estarán disponibles a través del nuevo cuadro de diálogo Rmarkdown:"
  },
  {
    "objectID": "reportes_dinamicos.html#html-widgets",
    "href": "reportes_dinamicos.html#html-widgets",
    "title": "Reportes dinámicos",
    "section": "6.1 HTML widgets",
    "text": "6.1 HTML widgets\nLos HTML Widgets se implementan con el paquete R htmlwidgets, que conecta herramientas de JavaScript que crean aplicaciones interactivas, como gráficos y tablas Se han desarrollado varios paquetes que emplean HTML widgets como dygraphs, DT y leaflet. En este sitio (https://www.htmlwidgets.org) se muestran una variedad de widgets disponibles así como instrucciones de como desarrollarlos.\nEl siguiente código utiliza el paquete leaflet para generar un mapa interactivo:\n\nCódigo\nsketchy::load_packages(\"leaflet\")\n\nll_map &lt;- leaflet()\n\nll_map &lt;- addTiles(map = ll_map)\n\nll_map &lt;-\n  setView(\n    map = ll_map,\n    lat = 5.527448,\n    lng = -87.057245,\n    zoom = 13\n  )\n\naddPopups(\n  map = ll_map,\n  lat = 5.527448,\n  lng = -87.057245,\n  popup = 'Isla del Coco'\n)"
  },
  {
    "objectID": "reportes_dinamicos.html#aplicaciones-shiny",
    "href": "reportes_dinamicos.html#aplicaciones-shiny",
    "title": "Reportes dinámicos",
    "section": "6.2 Aplicaciones shiny",
    "text": "6.2 Aplicaciones shiny\nEl paquete shiny crea aplicaciones web interactivas en R. Para llamar al código shiny desde un documento R Markdown, agregue ‘runtime’: shiny a los metadatos YAML, como en este ejemplo:\n\n\nCódigo\n---\ntitle: \"Documento Shiny\"\noutput: html_document\nruntime: shiny\n---\n\n\n \nEl siguiente código crea una aplicación shiny dentro del documento Rmarkdown:\n\n\nCódigo\nsketchy::load_packages(\"shiny\")\n\nui &lt;- fluidPage(\n  \n  titlePanel(\"Ejemplo\"),\n  \n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(inputId = \"bins\",\n                  label = \"Numero de barras:\",\n                  min = 1,\n                  max = 50,\n                  value = 30)\n      \n    ),\n    mainPanel(\n      plotOutput(outputId = \"distPlot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n \n  output$distPlot &lt;- renderPlot({\n    \n    x    &lt;- faithful$waiting\n    bins &lt;- seq(min(x), max(x), length.out = input$bins + 1)\n    \n    hist(x, breaks = bins, col = \"#3E4A89FF\", border = \"white\",\n         xlab = \"Tiempo de espera para la siguiente erupcion\",\n         main = \"Histograma del tiempo de espera\")\n  })\n}\n\n# Crear Shiny app\nshinyApp(ui = ui, server = server)\n\n\n \nNote que esta aplicación no funciona en documentos estáticos de Rmarkdown. En el sitio https://shiny.rstudio.com/gallery pueden encontrar muchos ejemplos de aplicaciones shiny. Estas aplicaciones son complejas de incluir en archivos auto-contenidos y por ello no son tan amigables para reportes dinámicos como los que podemos generar con R markdown."
  },
  {
    "objectID": "reportes_dinamicos.html#proyectos-de-rstudio",
    "href": "reportes_dinamicos.html#proyectos-de-rstudio",
    "title": "Reportes dinámicos",
    "section": "8.1 Proyectos de Rstudio",
    "text": "8.1 Proyectos de Rstudio\nLos proyectos de Rstudio crean carpetas donde se guardan los archivos relacionados a un análisis específico (código y datos) y hacen de esta carpeta el directorio de trabajo por defecto cuando se abre el proyecto. Se pueden crear de esta forma:\n\n\n\n\n\n\n\n\n\nLuego aparecera una seria de ventanas donde pueden escoger que tipo de proyecto y el nombre de este:"
  },
  {
    "objectID": "reportes_dinamicos.html#compendios-de-investigación",
    "href": "reportes_dinamicos.html#compendios-de-investigación",
    "title": "Reportes dinámicos",
    "section": "8.2 Compendios de investigación",
    "text": "8.2 Compendios de investigación\nLos compendios de investigación son estructuras de carpetas pre-definidas que permiten seguir un orden lógico e intuitivo para organizar los archivos usados y generados en un análisis de datos de un proyecto de investigación. El paquete sketchy genera estos compendios, permitiendo al usuario seleccionar entre una gama de compendios comunes en la comunidad científica. Este ejemplo crea el compendio básico (uno de los 14 que vienen con el paquete):\n\n\nCódigo\npath &lt;- tempdir()\n\nmake_compendium(\n  name = \"proyecto_x\",\n  path = path,\n  format = \"basic\",\n  Rproj = TRUE\n)\n\n\nCreating directories ...\nproyecto_x\n│   \n├── data/  \n│   ├── processed/  # modified/rearranged data\n│   └── raw/  # original data\n├── manuscript/  # manuscript/poster figures\n├── output/  # all non-data products of data analysis\n└── scripts/  # code\nDone.\n\n\nEl paquete crea archivos Rmarkdown con plantillas para el análisis de datos (carpeta “scripts”) y escritura de manuscritos (carpeta “manuscript”). Corra path en la consola de R para ver la dirección de la carpeta donde se creo el compendio."
  },
  {
    "objectID": "reportes_dinamicos.html#ejercicio-4",
    "href": "reportes_dinamicos.html#ejercicio-4",
    "title": "Reportes dinámicos",
    "section": "8.3 Ejercicio 4",
    "text": "8.3 Ejercicio 4\n\nCree un reporte dinámico que incluya un mapa dinámico de Costa Rica usando el paquete leaflet\nReproduzca alguno de los ejemplos disponibles en el sitio del paquete dygraphs (https://rstudio.github.io/dygraphs/) e incrústelo en su reporte dinámico\nInstale el paquete kableExtra y incruste en su reporte el códifo de ejemplo en la documentación de la función kable_styling() de ese paquete\nCree una presentación Rmarkdown utilizando la opción “Presentation” en la ventana de creación\nGenere un reporte dinámico en formato PDF\nCree un proyecto de Rstudio para organizar los contenidos del curso\nCree un compendio de investigación con sketchy"
  },
  {
    "objectID": "reportes_dinamicos.html#referencias",
    "href": "reportes_dinamicos.html#referencias",
    "title": "Reportes dinámicos",
    "section": "8.4 Referencias",
    "text": "8.4 Referencias\n\nR Markdown: The Definitive Guide\nRmarkdown custom format\nRmarkdown website\nJacolien van Rij: Rmarkdown variants\nDanielle Quinn: R Lessons\nVaidyanathan, Ramnath, Yihui Xie, JJ Allaire, Joe Cheng, and Kenton Russell. 2019. Htmlwidgets: HTML Widgets for R. https://github.com/ramnathv/htmlwidgets.\n\n\n\nInformación de la sesión\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n [1] tufte_0.13       rticles_0.26     revealjs_0.9     rmdformats_1.0.4\n [5] rmarkdown_2.27   knitr_1.48       sketchy_1.0.3    emo_0.0.0.9000  \n [9] remotes_2.5.0    leaflet_2.2.1   \n\nloaded via a namespace (and not attached):\n [1] jsonlite_1.8.8      compiler_4.3.2      crayon_1.5.3       \n [4] stringr_1.5.1       assertthat_0.2.1    jquerylib_0.1.4    \n [7] yaml_2.3.10         fastmap_1.2.0       R6_2.5.1           \n[10] generics_0.1.3      htmlwidgets_1.6.4   bookdown_0.37      \n[13] lubridate_1.9.3     xaringanExtra_0.7.0 rlang_1.1.4        \n[16] stringi_1.8.4       xfun_0.47           timechange_0.2.0   \n[19] cli_3.6.3           magrittr_2.0.3      crosstalk_1.2.1    \n[22] digest_0.6.37       rstudioapi_0.16.0   packrat_0.9.2      \n[25] lifecycle_1.0.4     vctrs_0.6.5         evaluate_0.24.0    \n[28] glue_1.7.0          purrr_1.0.2         tools_4.3.2        \n[31] htmltools_0.5.8.1"
  },
  {
    "objectID": "modelos_de_regresion.html",
    "href": "modelos_de_regresion.html",
    "title": "Modelos de regresión",
    "section": "",
    "text": "Paquetes a utilizar en este manual:\nCódigo\n# instalar/cargar paquetes\n\nsketchy::load_packages(\n  c(\"ggplot2\", \n    \"viridis\", \n    \"lmerTest\", \n    \"sjPlot\")\n  )"
  },
  {
    "objectID": "modelos_de_regresion.html#modelo-solo-con-intercepto",
    "href": "modelos_de_regresion.html#modelo-solo-con-intercepto",
    "title": "Modelos de regresión",
    "section": "1.1 Modelo solo con intercepto",
    "text": "1.1 Modelo solo con intercepto\nPrimero vamos a crear una variable numérica de respuesta:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\n\n#  variables aleatorias\ny &lt;- rnorm(n = n, mean = 0, sd = 1)\n\n# put it in a data frame\ny_data &lt;- data.frame(y)\n\n\n \nEsta única variable puede introducirse en un modelo de regresión sólo con intercepto. Para ello, debemos suministrar la fórmula del modelo y los datos a lm():\n\n\nCódigo\n# run model\ny_mod &lt;- lm(formula = y ~ 1, data = y_data)\n\n\n \nLo que equivale a:\n\n\\(\\hat{Y} \\sim \\beta_{o}\\)\n\n \nPodemos obtener el resumen por defecto de los resultados del modelo ejecutando summary() en el objeto de salida ‘y_mod’:\n\n\nCódigo\nsummary(y_mod)\n\n\n\nCall:\nlm(formula = y ~ 1, data = y_data)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-2.001 -0.594 -0.107  0.664  2.135 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)   0.0344     0.1309    0.26     0.79\n\nResidual standard error: 0.926 on 49 degrees of freedom\n\n\n \nPuede ser bastante informativo graficar los tamaños de efecto (aunque en este caso sólo tenemos uno):\n\n\nCódigo\nci_df &lt;- data.frame(param = names(y_mod$coefficients), \n                    est = y_mod$coefficients, confint(y_mod))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nPara evaluar la importancia de la asociación nos centramos en la tabla de coeficientes:\n\n\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept) 0.034404    0.13094 0.26275  0.79385\n\n\n\nEn este ejemplo no hay predictores en el modelo, por lo que sólo tenemos una estimación para el intercepto (\\(\\beta_0\\))\nEl modelo nos dice que el intercepto se estima en 0.0344 y que este valor no es significativamente diferente de 0 (valor p = 0.79385)\nEn este caso el intercepto es simplemente la media de la variable de respuesta\n\n\n\nCódigo\nmean(y_data$y)\n\n\n[1] 0.034404\n\n\n \n\nRara vez tenemos predicciones sobre el intercepto, por lo que tendemos a ignorar esta estimación.\n\n\n \n\n\nCaso de estudio\n\n \n\nRuhs, E. C., Martin, L. B., & Downs, C. J. (2020). The impacts of body mass on immune cell concentrations in birds. Proceedings of the Royal Society B, 287(1934), 20200655.\n\n“Encontramos que un modelo sólo con intercepto (intercept-only model) explicaba mejor las concentraciones de linfocitos y eosinófilos en las aves, indicando que las concentraciones de estos tipos de células eran independientes de la masa corporal.”\n\n\n\n\n\n\n\n\n\n \n\n \n\nEjercicio 3\n \n\nCambie el argumento ‘mean’ en la llamada de la función “rnorm()` en la simulación para el modelo de solo intercepto un valor distinto de 0 y observe cómo cambian los valores en la tabla de coeficientes\nCambia el argumento sd en la llamada a la función rnorm() por un valor más alto y observe cómo cambian los valores en la tabla de coeficientes"
  },
  {
    "objectID": "modelos_de_regresion.html#añadir-un-predictor-no-asociado",
    "href": "modelos_de_regresion.html#añadir-un-predictor-no-asociado",
    "title": "Modelos de regresión",
    "section": "1.2 Añadir un predictor no asociado",
    "text": "1.2 Añadir un predictor no asociado\nPodemos crear 2 variables numéricas no relacionadas así:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\n\n#  variables aleatorias\ny &lt;-  rnorm(n = n, mean = 0, sd = 1)\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\n\n# crear data frame\nxy_datos &lt;- data.frame(x1, y)\n\n\n \nEstas dos variables pueden introducirse en un modelo de regresión para evaluar la asociación entre ellas:\n\n\nCódigo\n# construir model\nxy_mod &lt;- lm(formula = y ~ x1, data = xy_datos)\n\n# graficar\nggplot(xy_datos, aes(x = x1, y = y)) + \n  geom_smooth(method = \"lm\", se = FALSE) + \n  geom_point() # graficar points\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \nQue es equivalente a esto:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1}\\)\n\n \nImprimamos el resumen de este modelo:\n\n\nCódigo\nsummary(xy_mod)\n\n\n\nCall:\nlm(formula = y ~ x1, data = xy_datos)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-2.004 -0.624 -0.123  0.687  2.106 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)   0.0398     0.1340    0.30     0.77\nx1           -0.0367     0.1475   -0.25     0.80\n\nResidual standard error: 0.935 on 48 degrees of freedom\nMultiple R-squared:  0.00129,   Adjusted R-squared:  -0.0195 \nF-statistic: 0.0618 on 1 and 48 DF,  p-value: 0.805\n\n\n \n… y graficar los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod$coefficients), \n                    est = xy_mod$coefficients, confint(xy_mod))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \nDeberíamos “diagnosticar” la idoneidad del modelo inspeccionando más de cerca la distribución de los residuales. La función plot_model() del paquete sjPlot hace un buen trabajo para crear gráficos de diagnóstico para modelos lineales:\n\n\nCódigo\nplot_model(xy_mod, type = \"diag\")\n\n\n[[1]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nCuadro con coeficientes:\n\n\n             Estimate Std. Error  t value Pr(&gt;|t|)\n(Intercept)  0.039774    0.13396  0.29690  0.76782\nx1          -0.036679    0.14750 -0.24867  0.80467\n\n\n \n\nEn este ejemplo hemos añadido un predictor al modelo, por lo que hemos obtenido una estimado adicional (y una fila extra, ‘x1’)\nEl modelo nos dice que la estimación de ‘x1’ es -0.03668 y que no es significativamente diferente de 0 (p = 0.80467)"
  },
  {
    "objectID": "modelos_de_regresion.html#simular-un-predictor-asociado",
    "href": "modelos_de_regresion.html#simular-un-predictor-asociado",
    "title": "Modelos de regresión",
    "section": "1.3 Simular un predictor asociado",
    "text": "1.3 Simular un predictor asociado\nPodemos utilizar la fórmula del modelo lineal anterior para simular dos variables continuas asociadas así:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -4\nb1 &lt;- 3\nerror &lt;- rnorm(n = n, sd = 3)\n\n# variables aleatorias\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\ny &lt;- b0 + b1 * x1 + error\n\n# crear data frame\nxy_datos2 &lt;- data.frame(x1, y)\n\n\n \nNote que también hemos añadido un término de error, por lo que la asociación no es perfecta. Vamos a correr el modelo y graficar la asociación entre las dos variables:\n\n\nCódigo\n# construir model\nxy_mod2 &lt;- lm(formula = y ~ x1, data = xy_datos2)\n\n# graficar\nggplot(xy_datos2, aes(x = x1, y = y)) + \n  geom_smooth(method = \"lm\", se = FALSE) +  \n  geom_point() # graficar points\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \nLa fórmula es la misma que la del modelo anterior:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1}\\)\n\n \nEste es el resumen del modelo:\n\n\nCódigo\nsummary(xy_mod2)\n\n\n\nCall:\nlm(formula = y ~ x1, data = xy_datos2)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n -6.01  -1.87  -0.37   2.06   6.32 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   -3.881      0.402   -9.66  7.9e-13 ***\nx1             2.890      0.442    6.53  3.9e-08 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.8 on 48 degrees of freedom\nMultiple R-squared:  0.471, Adjusted R-squared:  0.459 \nF-statistic: 42.7 on 1 and 48 DF,  p-value: 3.85e-08\n\n\n \n.. el gráfico con los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod2$coefficients), \n                    est = xy_mod2$coefficients, confint(xy_mod2))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \n… y los gráficos diagnósticos del modelo:\n\n\nCódigo\nplot_model(xy_mod2, type = \"diag\")\n\n\n[[1]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes (estimados):\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -3.8807    0.40188 -9.6562 7.8616e-13\nx1            2.8900    0.44249  6.5311 3.8537e-08\n\n\n\nEl modelo nos dice que \\(beta_1\\) (el tamaño de efecto de ‘x1’) es 2.88996 y que es significativamente diferente de 0 (p = 3.85365^{-8})\nLos valores simulados de los parámetros de regresión pueden compararse con el resumen del modelo lm() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) (the effect size of ‘x1’) was set to 3 and was estimated as 2.89 by the model\n\n\n\n \n\n\nCaso de estudio\n\n \n\nKeenan EL, Odom KJ, Araya-Salas M, Horton KG, Strimas-Mackey M, Meatte MA, Mann NI, Slater PJ, Price JJ, and Templeton CN. 2020. Breeding season length predicts duet coordination and consistency in Neotropical wrens (Troglodytidae). Proceeding of the Royal Society B. 20202482\n\n\n\n\n\n\n\n\n\n\n \n“… la coordinación y la consistencia de los duetos son mayores en las especies con temporadas de apareamiento especialmente largas.”\n\n\n\n\n\n\n\n\n\n \n\n \n\nEjercicio 4\n \n\nAumente el tamaño de la muestra (n) a 1000 o más\n¿Cómo cambiaron los estimados del tamaño de efecto (\\(\\beta\\))?\n¿Cómo cambió los intervalos de confianza del tamaño de efecto?\nAhora cambie n a 15 y compruebe de nuevo las estimaciones del modelo (esta vez compruebe también el valor p)"
  },
  {
    "objectID": "modelos_de_regresion.html#varios-predictores-regresión-múltiple",
    "href": "modelos_de_regresion.html#varios-predictores-regresión-múltiple",
    "title": "Modelos de regresión",
    "section": "1.4 Varios predictores: regresión múltiple",
    "text": "1.4 Varios predictores: regresión múltiple\nLa regresión lineal múltiple es una extensión del modelo de regresión lineal simple que puede tomar varios predictores:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1} + \\cdots + \\beta_{n} * x_{n}\\)\n\n \nLa fórmula parece compleja, pero sólo quiere decir que cualquier parámetro adicional tendrá su propia estimación (\\(\\beta\\)). La fórmula para una regresión lineal de dos predictores se ve así:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1} + \\beta_{2} * x_{2}\\)\n\n \n… y se puede simular así:\n\n\nCódigo\n# semila\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -4\nb1 &lt;- 3\nb2 &lt;- -2\nerror &lt;- rnorm(n = n, mean = 0, sd = 3)\n\n# variables aleatorias\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\nx2 &lt;-  rnorm(n = n, mean = 0, sd = 1)\ny &lt;- b0 + b1 * x1 + b2 * x2 + error\n\n# crear un data frame\nxy_datos_multp &lt;- data.frame(x1, x2, y)\n\n# construir el modelo\nxy_mod_multp &lt;- lm(formula = y ~ x1 + x2, data = xy_datos_multp)\n\nsummary(xy_mod_multp)\n\n\n\nCall:\nlm(formula = y ~ x1 + x2, data = xy_datos_multp)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-5.986 -1.893 -0.363  2.002  6.413 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   -3.865      0.417   -9.27  3.5e-12 ***\nx1             2.901      0.453    6.41  6.4e-08 ***\nx2            -1.932      0.414   -4.67  2.6e-05 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.83 on 47 degrees of freedom\nMultiple R-squared:  0.612, Adjusted R-squared:  0.595 \nF-statistic:   37 on 2 and 47 DF,  p-value: 2.23e-10\n\n\n \n… graficar los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod_multp$coefficients), \n                    est = xy_mod_multp$coefficients, confint(xy_mod_multp))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \n… y los gráficos diagnósticos:\n\n\nCódigo\nplot_model(xy_mod_multp, type = \"diag\")\n\n\n[[1]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \nHay un punto importante que es necesario enfatizar aquí: la regresión múltiple estima el efecto de un predictor después de tener en cuenta el efecto de los demás predictores del modelo. En otras palabras, los nuevos predictores del modelo tratarán de explicar la variación de los datos que no fue explicada por los otros predictores. Así que el resultado de la regresión múltiple no es equivalente a los resultados de las regresiones lineales simples sobre los predictores por separado. Esto puede demostrarse fácilmente corriendo esas regresiones:\n\n\nCódigo\ncoef(xy_mod_multp)# Resumen del modelo de multiple \n\n\n(Intercept)          x1          x2 \n    -3.8652      2.9015     -1.9324 \n\n\nCódigo\n# Regresión simple de Y con A\nmod_x1 &lt;- lm(y ~ x1, data = xy_datos_multp)\ncoef(mod_x1)  # Resumen del modelo de regresión \n\n\n(Intercept)          x1 \n    -3.4228      3.2310 \n\n\nCódigo\n# Regresión simple de Y con A\nmod_x2 &lt;- lm(y ~ x2, data = xy_datos_multp)\ncoef(mod_x2)  # Resumen del modelo de regresión\n\n\n(Intercept)          x2 \n    -3.5456     -2.3468 \n\n\nComo vemos los tamaños de efecto para el mismo predictor difieren entre la regresión multiple y la simple. Esto se debe a que en la regresion multiple ajusta los predictores para que se comporten como si fueran ortogonales entre sí. Esto lo podemos simular sacando los residuales de cada predictor en una regresión contra todos los otros predictores en la regresión multiple. En nuestro caso es fácil ya que solo tenemos 2 predictores:\n\n\nCódigo\n# Regresión de x1 sobre x2 para obtener los residuales\nmod_resid_x1 &lt;- lm(x1 ~ x2, data = xy_datos_multp)\n\n# Obtener los residuales\nxy_datos_multp$residuales_x1 &lt;- resid(mod_resid_x1)  \n\n# Regresión de x2 sobre x1 para obtener los residuales\nmod_resid_x2 &lt;- lm(x2 ~ x1, data = xy_datos_multp)\n\n# Obtener los residuales \nxy_datos_multp$residuales_x2 &lt;- resid(mod_resid_x2)  \n\n\nAhora si corremos las regresiones simples con estos residuales, los tamaños de efecto coinciden con los obtenidos en la regresión multiple:\n\n\nCódigo\n# Regresión de Y sobre los residuales de A\nmod_resid_reg_x1 &lt;- lm(y ~ residuales_x1, data = xy_datos_multp)\n\n# Regresión de Y sobre los residuales de B\nmod_resid_reg_x2 &lt;- lm(y ~ residuales_x2, data = xy_datos_multp)\n\n# Resúmenes finales de los modelos para comparar\ncoef(xy_mod_multp)[-1]\n\n\n     x1      x2 \n 2.9015 -1.9324 \n\n\nCódigo\nc(coef(mod_resid_reg_x1)[-1], coef(mod_resid_reg_x2)[-1])\n\n\nresiduales_x1 residuales_x2 \n       2.9015       -1.9324 \n\n\nPor comodidad, hemos utilizado coef() para extraer sólo los estimado de la regresión, pero los valores son los mismos que obtenemos con summary(model).\nEste punto se demuestra además por el hecho de que, si uno de los predictores no tiene ninguna influencia en la respuesta, el efecto del predictor adicional convergerá a su efecto en una regresión lineal simple. Para simular este escenario, fijamos b2 en 0:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -4\nb1 &lt;- 3\nb2 &lt;- 0\nerror &lt;- rnorm(n = n, mean = 0, sd = 1)\n\n#  variables aleatorias\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\nx2 &lt;-  rnorm(n = n, mean = 0, sd = 1)\ny &lt;- b0 + b1 * x1 + b2 * x2 + error\n\n# crear data frame\nxy_datos &lt;- data.frame(x1, x2, y)\n\n# construir modelos\nxy_mod &lt;- lm(formula = y ~ x1 + x2, data = xy_datos)\nx1y_mod &lt;- lm(formula = y ~ x1, data = xy_datos)\n\n# shortcut to coefficients\ncoef(xy_mod)\n\n\n(Intercept)          x1          x2 \n  -3.955064    2.967166    0.022549 \n\n\nCódigo\ncoef(x1y_mod)\n\n\n(Intercept)          x1 \n    -3.9602      2.9633 \n\n\nEl estimado de \\(\\beta_1\\) fue casi el mismo en la regresión múltiple (2.96717) y en la regresión de un solo predictor (2.96332)\n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes (estimados):\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -3.8652    0.41695 -9.2702 3.4856e-12\nx1            2.9015    0.45260  6.4108 6.4137e-08\nx2           -1.9324    0.41422 -4.6650 2.5851e-05\n\n\n\nEl modelo encontró que \\(\\beta_1\\) (el tamaño de efecto de ‘x1’) es 2.9015 y que es significativamente diferente de 0 (p = 6.41368^{-8}). Este es el efecto de ‘x1’ sobre ‘y’ una vez removida la variación explicada por ‘x2’.\nTambién se encontró que el \\(\\beta_2\\) (el tamaño de efecto de ‘x2’) es -1.93235 y que también es significativamente diferente de 0 (p = 2.58513^{-5}). Este es el efecto de ‘x2’ sobre ‘y’ una vez removida la variación explicada por ‘x1’.\nLos valores simulados de los parámetros de regresión pueden compararse con el resumen del modelo lm() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) se fijó en 3 y se estimó como 2.901.\n\\(\\beta_2\\) (el tamaño de efecto de ‘x2’) se fijó en 0 y se estimó como -1.932.\n\n\n\n \n\n\nCaso de estudio\n\n \n\nAraya-Salas M, P González-Gómez, K Wojczulanis-Jakubas, V López III & T Wright. 2018. Spatial memory is as important as weapon and body size for territorial ownership in a lekking hummingbird. Scientific Reports. 13, e0189969\n\n“La memoria espacial, el tamaño corporal y el largo de la punta del pico … predijeron positivamente la probabilidad de adquirir y defender un territorio.”\n\n\n\n\n\n\n\n\n\n \n\n\nEjercicio 5\n \nLa siguiente simulación genera un par de predictores continuos altamente colineales:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 30\nb0 &lt;- -4\nb1 &lt;- 3\nb2 &lt;- -2\nerror &lt;- rnorm(n = n, mean = 0, sd = 1)\n\n#  variables aleatorias colineales\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\nx2 &lt;-  x1 + rnorm(n = n, mean = 0, sd = 0.2) # hacer x2 colineal con x1\ny &lt;- b0 + b1 * x1 + b2 * x2 + error\n\n# crear data frame\nxy_datos &lt;- data.frame(x1, x2, y)\n\ncor(x1, x2)\n\n\n[1] 0.97812\n\n\n\n\nCódigo\n# graficar\nggplot(data = xy_datos, aes(x = x1, y = x2)) +\n    geom_point(size = 3)\n\n\n\n\n\n\n\n\n\n\n\n\nConstruya un modelo lineal multiple (con lm()) con ‘y’ como respuesta y ‘x1’ y ‘x2’ como predictores\nCompare los betas estimados por el modelo con los usados para generar los datos. ¿Es una buena estimación?. También observe los valores de p. ¿Esperaría que fueran significativos?"
  },
  {
    "objectID": "modelos_de_regresion.html#añadir-un-predictor-categórico",
    "href": "modelos_de_regresion.html#añadir-un-predictor-categórico",
    "title": "Modelos de regresión",
    "section": "1.5 Añadir un predictor categórico",
    "text": "1.5 Añadir un predictor categórico\nPara los predictores categóricos podemos crear primero una variable binaria (0, 1) y luego añadir etiquetas a cada valor:\n\n\nCódigo\n# definir semilla\nset.seed(13)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -3\nb1 &lt;- 2\nerror &lt;- rnorm(n = n, mean = 0, sd = 3)\n\n#  variables aleatorias\nx1_num &lt;- sample(0:1, size = n, replace = TRUE)\ny &lt;- b0 + b1 * x1_num + error\n\nx1 &lt;- factor(x1_num, labels = c(\"a\", \"b\"))\n\n# crear data frame\nxy_datos_cat &lt;- data.frame(x1, x1_num, y)\n\nhead(xy_datos_cat)\n\n\n\n\n\n\nx1\nx1_num\ny\n\n\n\n\nb\n1\n0.66298\n\n\na\n0\n-3.84082\n\n\na\n0\n2.32549\n\n\nb\n1\n-0.43804\n\n\na\n0\n0.42758\n\n\na\n0\n-1.75342\n\n\n\n\n\n\n \nY así es como se escribe formalmente:\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1}\\)\n\n \nLo mismo que con los predictores continuos.\nPodemos explorar el patrón de los datos utilizando un diagrama de cajas (boxplot):\n\n\nCódigo\n# graficar\nggplot(xy_datos_cat, aes(x = x1, y = y)) + \n  geom_boxplot()\n\n\n\n\n\n\n\n\n\n \n… y obtener los estimados del modelo:\n\n\nCódigo\n# construir modelos\nxy_mod_cat &lt;- lm(formula = y ~ x1, data = xy_datos_cat)\n\nsummary(xy_mod_cat)\n\n\n\nCall:\nlm(formula = y ~ x1, data = xy_datos_cat)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-5.898 -1.909 -0.094  1.809  5.506 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   -2.997      0.558   -5.37  2.3e-06 ***\nx1b            1.814      0.842    2.16    0.036 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.95 on 48 degrees of freedom\nMultiple R-squared:  0.0882,    Adjusted R-squared:  0.0693 \nF-statistic: 4.65 on 1 and 48 DF,  p-value: 0.0362\n\n\n \n… graficar los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod_cat$coefficients), \n                    est = xy_mod_cat$coefficients, confint(xy_mod_cat))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \n… y los gráficos diagnósticos del modelo:\n\n\nCódigo\nplot_model(xy_mod_cat, type = \"diag\")[[2]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes (estimados):\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -2.9974    0.55825 -5.3693 2.2677e-06\nx1b           1.8140    0.84160  2.1554 3.6172e-02\n\n\n\nEl modelo encontró que \\(\\beta_1\\) (el tamaño de efecto de ‘x1’) es 1.814 y que es significativamente diferente de 0 (p = 0.03617)\nLos valores simulados de los parámetros de regresión pueden compararse con el resumen del modelo lm() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) se fijó en 2 y se estimó como 1.814.\n\nTenga en cuenta que en este caso el intercepto se refiere a la estimación del nivel ‘a’ en el predictor categórico, que se utilizó como base:\n\n\n\nCódigo\n# graficar\nggplot(xy_datos_cat, aes(x = x1, y = y)) + \n  geom_boxplot() +\ngeom_hline(yintercept = xy_mod_cat$coefficients[1], col = \"blue\")\n\n\n\n\n\n\n\n\n\n\n\n\nPor lo tanto, el intercepto es el mismo que la media de y para la categoría ‘a’:\n\n\n\nCódigo\nmean(xy_datos_cat$y[xy_datos_cat$x1 == \"a\"])\n\n\n[1] -2.9974\n\n\n\nObserve también que la etiqueta del estimado es ‘x1b’, no ‘x1’ como en los predictores continuos. Esto se debe a que en este caso el estimado se refiere a la diferencia entre los dos niveles de la variable categórica (‘a’ y ‘b’). Más concretamente, nos dice que en promedio las observaciones de la categoría ‘b’ son 1.814 más altas que las observaciones de la categoría ‘a’.\n\n \n\n \n\n\nCaso de estudio\n\n \n\nRico-Guevara A, & M Araya-Salas. 2015. Bills as daggers? A test for sexually dimorphic weapons in a lekking hummingbird species. Behavioral Ecology. 26 (1): 21-29.\n\n“Los machos con puntas de pico más grandes y puntiagudas tuvieron más éxito en ganar control de territorios en el lek.”\n\n\n\n\n\n\n\n\n\n \n\n \n\nEjercicio 6\n \n\nLos datos desbalanceados cuando hay categorías (es decir, algunas categorías tienen muchas más observaciones que otras) pueden ser problemáticos para la inferencia estadística. Modifique el código arriba para simular un juego de datos muy desbalanceado y compruebe la precisión del modelo.\n\n\n\n\n\n\nVariables indicadoras (Dummy variables)\n\n\nEn un modelo de regresión, los predictores categóricos también se representan como vectores numéricos. Más concretamente, los predictores categóricos se codifican como 0s y 1s, en los que 1 significa “pertenece a la misma categoría” y 0 “pertenece a una categoría diferente”. Mantuvimos el vector numérico original (‘x1_num’) al simular el juego de datos con el predictor categórico:\n\n\nCódigo\nhead(xy_datos_cat)\n\n\n\n\n\n\nx1\nx1_num\ny\n\n\n\n\nb\n1\n0.66298\n\n\na\n0\n-3.84082\n\n\na\n0\n2.32549\n\n\nb\n1\n-0.43804\n\n\na\n0\n0.42758\n\n\na\n0\n-1.75342\n\n\n\n\n\n\nObserve que las “b” de la columna “x1” se convierten en 1 en la columna “x1_num” y las “a” se convierten en 0. Esto se denomina variable indicadora y el proceso se conoce como ‘codificación indicadora’ (dummy coding).\nEn realidad, podemos utilizar el vector numérico en el modelo de regresión y obtener exactamente los mismos resultados:\n\n\nCódigo\n# summary model with categorical variable\nsummary(xy_mod_cat)$coefficients\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -2.9974    0.55825 -5.3693 2.2677e-06\nx1b           1.8140    0.84160  2.1554 3.6172e-02\n\n\nCódigo\n# construir modelos with dummy variable\nxy_mod_num &lt;- lm(formula = y ~ x1_num, data = xy_datos_cat)\n\n# summary with dummy coding\nsummary(xy_mod_num)$coefficients\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -2.9974    0.55825 -5.3693 2.2677e-06\nx1_num        1.8140    0.84160  2.1554 3.6172e-02\n\n\n \nLas cosas se complican un poco más cuando se codifica un predictor categórico con más de dos niveles. Pero la lógica es la misma."
  },
  {
    "objectID": "modelos_de_regresion.html#interacciones",
    "href": "modelos_de_regresion.html#interacciones",
    "title": "Modelos de regresión",
    "section": "1.6 Interacciones",
    "text": "1.6 Interacciones\nUna interacción estadística se refiere a un efecto de una variable predictora que está mediado por una segunda variable.\n\n\\(\\hat{Y} \\sim \\beta_{o} + \\beta_{1} * x_{1} + \\beta_{2} * x_{2} + \\beta_{3} * x_{1} * x_{2}\\)\n\n \nEsto es más fácil de entender si se observa la interacción de una variable continua y una binaria:\n\n\nCódigo\n# definir semilla\nset.seed(123)\n\n# numero de observaciones\nn &lt;- 50\nb0 &lt;- -4\nb1 &lt;- 3\nb2 &lt;- 1.7\nb3 &lt;- -3\nerror &lt;- rnorm(n = n, mean = 0, sd = 3)\n\n#  variables aleatorias\nx1 &lt;- rbinom(n = n, size = 1, prob = 0.5)\nx2 &lt;-  rnorm(n = n, mean = 0, sd = 1)\n\n# interaccion se añade como el producto dex1 y x2\ny &lt;- b0 + b1 * x1 + b2 * x2 + b3 * x1 * x2 + error\n\nx1 &lt;- factor(x1, labels = c(\"a\", \"b\"))\n\n# crear data frame\nxy_datos_intr &lt;- data.frame(x1, x2, y)\n\nhead(xy_datos_intr)\n\n\n\n\n\n\nx1\nx2\ny\n\n\n\n\nb\n1.02557\n-4.0147\n\n\na\n-0.28477\n-5.1746\n\n\na\n-1.22072\n-1.3991\n\n\nb\n0.18130\n-1.0242\n\n\na\n-0.13889\n-3.8483\n\n\nb\n0.00576\n4.1377\n\n\n\n\n\n\nCódigo\n# construir modelos\nxy_mod_intr &lt;- lm(formula = y ~ x1 + x2 + x1 * x2, data = xy_datos_intr)\n\n# guardar resumen para graficar lineas de mejor ajuste\nxy_summ_intr &lt;- summary(xy_mod_intr)\n\nxy_summ_intr\n\n\n\nCall:\nlm(formula = y ~ x1 + x2 + x1 * x2, data = xy_datos_intr)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-6.222 -1.664 -0.158  1.650  6.383 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   -4.193      0.570   -7.35  2.7e-09 ***\nx1b            3.597      0.806    4.46  5.2e-05 ***\nx2             1.327      0.682    1.95   0.0576 .  \nx1b:x2        -2.972      0.962   -3.09   0.0034 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.83 on 46 degrees of freedom\nMultiple R-squared:  0.396, Adjusted R-squared:  0.357 \nF-statistic:   10 on 3 and 46 DF,  p-value: 3.29e-05\n\n\nTambién ayuda graficar los datos:\n\n\nCódigo\n# graficar\nggplot(data = xy_datos_intr, aes(x = x2, y = y, color = x1)) +\n    geom_point(size = 3) +\n    geom_smooth(method = \"lm\", se = FALSE)\n\n\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n… y los tamaños de efecto:\n\n\nCódigo\nci_df &lt;- data.frame(param = names(xy_mod_intr$coefficients), \n                    est = xy_mod_intr$coefficients, confint(xy_mod_intr))\n\nggplot(ci_df, aes(x=param, y=est)) + \n  geom_hline(yintercept = 0, color=\"red\", lty = 2) +\n  geom_pointrange(aes(ymin = X2.5.., ymax = X97.5..)) + \n  labs(x = \"Parámetro\", y = \"Tamaño de efecto\") + \n  coord_flip()\n\n\n\n\n\n\n\n\n\n \nTambién deberíamos revisar los gráficos de diagnóstico:\n\n\nCódigo\nplot_model(xy_mod_intr, type = \"diag\")\n\n\n[[1]]\n\n\n\n\n\n\n\n\n\n\n[[2]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n\n[[3]]\n\n\n\n\n\n\n\n\n\n\n[[4]]\n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes:\n\n\n            Estimate Std. Error t value   Pr(&gt;|t|)\n(Intercept)  -4.1930    0.57023 -7.3532 2.6978e-09\nx1b           3.5974    0.80607  4.4629 5.1950e-05\nx2            1.3274    0.68161  1.9474 5.7610e-02\nx1b:x2       -2.9720    0.96227 -3.0885 3.4061e-03\n\n\n\nEl modelo encontró que \\(\\beta_1\\) (el tamaño de efecto de ‘x1-b’ a ‘x1-a’) es 3.59741 y que es significativamente diferente de 0 (valor p = 5.19496^{-5})\nEl modelo encontró que \\(\\beta_2\\) (el tamaño de efecto de ‘x2’) es 1.32735 y que es significativamente diferente de 0 (p = 0.05761). Esto es en realidad la pendiente de la relación entre x2 e y cuando x1 = `a’\nEl modelo encontró que \\(\\beta_3\\) (el tamaño de efecto del término de interacción ‘x1 * x2’) es -2.97196 y que es significativamente diferente de 0 (p = 0.00341). Esta es la diferencia entre las pendientes de x2 vs y cuando x1 = ‘a’ y x2 vs y cuando x1 = ‘b’.\nLos valores simulados para los parámetros de regresión pueden compararse con el resumen del modelo lm() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) se simuló con un valor de 3 y se estimó en 3.597\n\\(\\beta_2\\) se simuló con un valor de 1.7 y se estimó en 1.327\n\\(\\beta_3\\) se simuló con un valor de -3 y se estimó en -2.972\n\n\n\n\n \n\n\nCaso de estudio\n\n \n\nChirino F, B Wilink, Araya-Salas M. In prep. Climatic factors affecting vocal activity in lemur leaf frogs.\n\n“El aumento de la luz de la luna disminuye la actividad vocal de Agalychnis lemur aunque esta relación es mediada por la temperatura.”"
  },
  {
    "objectID": "modelos_de_regresion.html#lectura-understanding-it-depends-in-ecology-a-guide-to-hypothesising-visualising-and-interpreting-statistical-interactions",
    "href": "modelos_de_regresion.html#lectura-understanding-it-depends-in-ecology-a-guide-to-hypothesising-visualising-and-interpreting-statistical-interactions",
    "title": "Modelos de regresión",
    "section": "Lectura: Understanding ‘it depends’ in ecology: a guide to hypothesising, visualising and interpreting statistical interactions",
    "text": "Lectura: Understanding ‘it depends’ in ecology: a guide to hypothesising, visualising and interpreting statistical interactions\nLos ecólogos utilizan habitualmente modelos estadísticos para detectar y explicar interacciones entre factores ecológicos, con el objetivo de evaluar si un efecto de interés cambia de signo o magnitud en distintos contextos. El artículo trata de los peligros de interpretan las interacciones estadísticas sin prestar atención a su propiedad fundamental de simetría, o a la escala de medida, ya sea aditiva o multiplicativa. Acá pueden acceder al artículo."
  },
  {
    "objectID": "modelos_de_regresion.html#modelos-lineales-generalizados-glm",
    "href": "modelos_de_regresion.html#modelos-lineales-generalizados-glm",
    "title": "Modelos de regresión",
    "section": "2.1 Modelos lineales generalizados (GLM)",
    "text": "2.1 Modelos lineales generalizados (GLM)\nLos GLM nos permiten modelar la asociación a variables respuesta que no siguen una distribución normal. Además, permiten modelar distribuciones que se asemejan más al proceso que generó los datos. El siguiente código crea un juego de datos con una respuesta que representa cuentas (por lo tanto, no normal):\n\n\nCódigo\n# definir semilla\nset.seed(1234)\n\n# numero de muestas\nn &lt;- 50\n\n# coeficientes\nb0 &lt;- 1.2\nb1 &lt;- 1.3\nb2 &lt;- 0\n\n\n#generar variables\ny &lt;- rpois(n = n, lambda = 6.5) # lambda = tasa promedio de exitos \nx2 &lt;- seq(-0.5, 0.5, , length(y))\nx1 &lt;- (log(y) - b0 - b2 * x2) / b1\n\n# crear data frame\nxy_datos_pois &lt;- data.frame(x1, x2, y)\n\nhead(xy_datos_pois)\n\n\n\n\n\n\nx1\nx2\ny\n\n\n\n\n0.14330\n-0.50000\n4\n\n\n0.57378\n-0.47959\n7\n\n\n0.57378\n-0.45918\n7\n\n\n0.57378\n-0.43878\n7\n\n\n0.76710\n-0.41837\n9\n\n\n0.57378\n-0.39796\n7\n\n\n\n\n\n\n \nTambién grafiquemos ‘x1’ vs ‘y’:\n\n\nCódigo\n# graficar\nggplot(xy_datos_pois, aes(x = x1, y = y)) + \n  geom_point() \n\n\n\n\n\n\n\n\n\n \nLa relación no parece muy lineal ni la varianza parece ser constante a través de ‘x1’.\nPodemos relajar el requisito de la distribución normal con GLMs. glm() es una función básica de R que nos ayuda a hacer el truco. Para este ejemplo la distribución más apropiada es Poisson. Esto se puede establecer en el argumento `family’ así:\n\n\nCódigo\nglm_pois  &lt;- glm(formula = y ~ x1 + x2, data = xy_datos_pois, family = poisson())\n\n\n \nQue es equivalente a esto:\n\n\\(\\hat{Y} \\sim_{poisson} \\beta_{o} + \\beta_{1} * x_{1} + \\beta_{2} * x_{2}\\)\n\n \nComo puede ver el único argumento extra comparado con lm() es family. El resto es simplemente la “fórmula” y los “datos” con los que ya estamos familiarizados. Así que, de nuevo, podemos aprovechar nuestros conocimientos sobre los modelos lineales para extenderlos a estructuras de datos más complejas.\nTambién necesitamos ejecutar summary() para obtener el resultado del modelo:\n\n\nCódigo\nsummary(glm_pois)\n\n\n\nCall:\nglm(formula = y ~ x1 + x2, family = poisson(), data = xy_datos_pois)\n\nCoefficients:\n            Estimate Std. Error z value Pr(&gt;|z|)    \n(Intercept) 1.20e+00   1.29e-01    9.31  &lt; 2e-16 ***\nx1          1.30e+00   2.20e-01    5.92  3.2e-09 ***\nx2          1.39e-16   1.90e-01    0.00        1    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 3.9471e+01  on 49  degrees of freedom\nResidual deviance: 2.2204e-16  on 47  degrees of freedom\nAIC: 186.9\n\nNumber of Fisher Scoring iterations: 3\n\n\n \n \n\n \n\nInterpretación del modelo\n\n \nCuadro de los coeficientes (estimados):\n\n\n              Estimate Std. Error    z value   Pr(&gt;|z|)\n(Intercept) 1.2000e+00    0.12889 9.3106e+00 1.2709e-20\nx1          1.3000e+00    0.21960 5.9200e+00 3.2198e-09\nx2          1.3882e-16    0.19016 7.3003e-16 1.0000e+00\n\n\n\nEl modelo nos dice que \\(\\beta_1\\) (el tamaño de efecto de ‘x1’) es 1.3 y que es significativamente diferente de 0 (p = 3.21981^{-9}). Esto se interpreta en realidad como que un aumento de 1 unidad de ‘x1’ resulta en ‘y’ (tasa) en un factor de exp(1.3) = 3.6693.\nEl modelo también nos dice que \\(\\beta_2\\) (el tamaño de efecto de ‘x2’) es 1.38824^{-16} y que es significativamente diferente de 0 (p = 1). Esto significa que un aumento en 1 unidad de ‘x2’ resulta en ‘y’ (tasa) en un factor de exp(1.38824^{-16}) = 1.\n\n\n \n\n\nCaso de estudio\n\n \n\nTopp, E. N., Tscharntke, T., & Loos, J. (2022). Fire and landscape context shape plant and butterfly diversity in a South African shrubland. Diversity and Distributions, 28(3), 357-371.\n\n“La riqueza de especies de mariposas es de tres a cuatro veces mayor cuando aumenta el hábitat natural en el paisaje circundante (en un radio de 2 km), mientras que la abundancia de mariposas se asociaba negativamente con el aumento del tiempo transcurrido desde el último incendio.”\n\n\n\n\n\n\n\n\n\n \n\n \n\nEjercicio 8\n \n\nIntente correr el modelo anterior lm() (con una distribución gaussiana), compare los resultados y compruebe los residuos (plot_model(model_name, type = \"diag\"))\n\n\n \nExisten muchas otras funciones de distribución y enlace:"
  },
  {
    "objectID": "modelos_de_regresion.html#modelos-de-efectos-variables-modelos-mixtos",
    "href": "modelos_de_regresion.html#modelos-de-efectos-variables-modelos-mixtos",
    "title": "Modelos de regresión",
    "section": "2.2 Modelos de efectos variables (modelos mixtos)",
    "text": "2.2 Modelos de efectos variables (modelos mixtos)\nA veces nuestros conjuntos de datos incluyen estructuras con varios niveles de organización. Por ejemplo, cuando tomamos muestras de varios individuos de diferentes poblaciones. En esos casos, la variación en el nivel estructural superior (poblaciones) podría impedir la detección de patrones en el nivel inferior (individuos).\nVamos a simular algunos datos que se asemejan a ese escenario. Tenemos dos predictores continuos (x1) y una respuesta continua (y). Cada muestra procede de 1 de 8 poblaciones diferentes (poblacion):\n\n\nCódigo\n# x&lt;- 1\n# definir semilla\nset.seed(28)\n\n# numero de observaciones\nn &lt;- 300\nb0 &lt;- 1\nb1 &lt;- 1.3\npoblacion &lt;- sample(0:8, size = n, replace = TRUE)\nerror &lt;- rnorm(n = n, mean = 0, sd = 2)\n\n#  variables aleatorias\nx1 &lt;-  rnorm(n = n, mean = 0, sd = 1)\ny &lt;- b0 + poblacion * 2 + b1 * x1 + error\n\n# add letters\npoblacion &lt;- letters[poblacion + 1]\n\n# create data set\nxy_datos_mixto &lt;- data.frame(x1, y, poblacion)\n\nhead(xy_datos_mixto, 10)\n\n\n\n\n\n\nx1\ny\npoblacion\n\n\n\n\n1.54607\n3.3378\na\n\n\n0.56834\n3.1399\na\n\n\n-0.63855\n15.2824\ni\n\n\n0.98424\n2.6610\na\n\n\n1.05355\n3.7312\nb\n\n\n-0.82294\n3.0189\na\n\n\n-1.32373\n3.2186\nc\n\n\n2.17854\n19.0542\ni\n\n\n2.26484\n15.4549\ni\n\n\n-0.77843\n11.6670\nh\n\n\n\n\n\n\n \nPodemos explorar la relación entre ‘y’ y ‘x1’ con un gráfico:\n\n\nCódigo\nggplot(data = xy_datos_mixto, aes(x = x1, y = y)) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n \n¿Puede ver claramente el patrón de asociación entre las dos variables que hemos utilizado para simular los datos? Podemos seguir explorando los datos con un modelo de regresión lineal simple:\n\n\nCódigo\nsummary(lm(y ~ x1, data = xy_datos_mixto))\n\n\n\nCall:\nlm(formula = y ~ x1, data = xy_datos_mixto)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-11.755  -5.119   0.186   4.602  12.409 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)    8.852      0.325   27.21   &lt;2e-16 ***\nx1             0.633      0.329    1.92    0.055 .  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 5.63 on 298 degrees of freedom\nMultiple R-squared:  0.0123,    Adjusted R-squared:  0.00895 \nF-statistic:  3.7 on 1 and 298 DF,  p-value: 0.0554\n\n\n \nA pesar de haber simulado un \\(\\beta_1\\) distinto de cero, no tenemos ninguna asociación significativa según este modelo y la estimación de \\(\\beta_1\\) está muy lejos de la simulada. Esta pobre inferencia se debe a que estamos ignorando una característica importante de nuestros datos, la agrupación de las muestras en “poblaciones”.\nLos modelos de efectos mixtos (también conocidos como modelos multinivel o modelos de efectos variables) pueden ayudarnos a tener en cuenta estas características adicionales, mejorando significativamente nuestro poder de inferencia. Coloreemos cada una de las poblaciones para ver cómo covarían las variables en cada subgrupo de datos:\n\n\nCódigo\nggplot(data = xy_datos_mixto, aes(x = x1, y = y, color = poblacion)) + \n  geom_point()\n\n\n\n\n\n\n\n\n\n \nParece haber un patrón claro de asociación positiva entre x1 e y. El patrón se hace un poco más evidente si mostramos cada población en su propio panel:\n\n\nCódigo\nggplot(data = xy_datos_mixto, aes(x = x1, y = y, color = poblacion)) +\n  geom_point() +\n  facet_wrap( ~ poblacion) +\n  geom_smooth(method = \"lm\", se = FALSE) \n\n\n`geom_smooth()` using formula = 'y ~ x'\n\n\n\n\n\n\n\n\n\n \nConstruyamos un modelo de efectos mixtos utilizando la población como intercepto variable:\n\n\nCódigo\nmix_eff_mod &lt;- lmer(formula = y ~ x1 + (1 | poblacion), data = xy_datos_mixto)\n\n\nQue es equivalente a esto:\n\n\\(\\hat{Y} \\sim_{gausiana} (\\beta_{o} + \\beta_{grupo}) + \\beta_{1} * x_{1}\\)\n\n \nPodemos ver el resultado del modelo igual que con un modelo lm():\n\n\nCódigo\nsummary(mix_eff_mod)\n\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: y ~ x1 + (1 | poblacion)\n   Data: xy_datos_mixto\n\nREML criterion at convergence: 1296.4\n\nScaled residuals: \n   Min     1Q Median     3Q    Max \n-3.524 -0.657 -0.032  0.612  3.245 \n\nRandom effects:\n Groups    Name        Variance Std.Dev.\n poblacion (Intercept) 30.07    5.48    \n Residual               3.76    1.94    \nNumber of obs: 300, groups:  poblacion, 9\n\nFixed effects:\n            Estimate Std. Error      df t value Pr(&gt;|t|)    \n(Intercept)    8.788      1.831   8.003     4.8   0.0014 ** \nx1             1.317      0.115 290.068    11.4   &lt;2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n   (Intr)\nx1 -0.003\n\n\n \nEl modelo detectó correctamente el patrón simulado y la estimación de \\(\\beta_1\\) (1.317) es muy cercana al valor simulado.\n \n\n\nCaso de estudio\n\n \n\nAraya-Salas M, P González-Gómez, K Wojczulanis-Jakubas, V López III & T Wright. 2018. Spatial memory is as important as weapon and body size for territorial ownership in a lekking hummingbird. Scientific Reports. 13, e0189969\n\n“… el tamaño corporal mostró una correlación negativa con la frecuencia baja del canto.”\n\n\n\n\n\n\n\n\n\n \n\n \n\n \n\nInterpretación del modelo\n\n \nCuadro con los coeficientes (estimados):\n\n\n            Estimate Std. Error       df t value   Pr(&gt;|t|)\n(Intercept)   8.7881     1.8315   8.0031  4.7983 1.3569e-03\nx1            1.3166     0.1151 290.0679 11.4395 2.9326e-25\n\n\n \n\nEl modelo encontró que \\(\\beta_1\\) (el tamaño de efecto de ‘x1’) es 1.31665 y que es significativamente diferente de 0 (p = 2.93263^{-25})\nLos valores simulados de los parámetros de regresión pueden compararse con el resumen del modelo lmer() para tener una idea de la precisión del modelo:\n\n\\(\\beta_1\\) se fijó en 1.3 y se estimó como 1.317.\n\nLa varianza del intercepto para cada población fue de 29.95624 y la desviación estándar de 5.47323\nLos interceptos estimados para cada población son:\n\n\n\nCódigo\nranef(mix_eff_mod)$poblacion\n\n\n\n\n\n\n\n(Intercept)\n\n\n\n\na\n-8.22835\n\n\nb\n-6.17134\n\n\nc\n-4.23048\n\n\nd\n-1.30838\n\n\ne\n0.24573\n\n\nf\n2.22552\n\n\ng\n3.91556\n\n\nh\n5.75609\n\n\ni\n7.79566\n\n\n\n\n\n\n \n\nPodemos compararlos con los promedios para cada población en los datos:\n\n\n\nCódigo\n# sumar interceptos por poblacion a el intercepto total\ninterceptos &lt;- ranef(mix_eff_mod)$poblacion + fixef(mix_eff_mod)[1]\n\n# calcular los promedios por poblacion en los datos \nprom_pobs &lt;- aggregate(y ~ poblacion, xy_datos_mixto, mean)\n\n# unir\ncbind(interceptos, prom_pobs= prom_pobs[,2])\n\n\n\n\n\n\n\n(Intercept)\nprom_pobs\n\n\n\n\na\n0.55975\n0.86151\n\n\nb\n2.61677\n2.76860\n\n\nc\n4.55762\n4.90112\n\n\nd\n7.47972\n7.73174\n\n\ne\n9.03384\n8.87649\n\n\nf\n11.01363\n10.77650\n\n\ng\n12.70366\n12.62651\n\n\nh\n14.54420\n14.62110\n\n\ni\n16.58376\n16.42520\n\n\n\n\n\n\n \n\nLa varianza entre los niveles del factor aleatorio (poblacion) es de 29.95624 y la desviación estándar de 5.47323\n\n \n\n \n\n2.2.1 La paradoja de Simpson\nLa paradoja de Simpson es un fenómeno en estadística en el que una tendencia aparece en varios grupos de datos pero desaparece o se invierte cuando se combinan los grupos. Se ha utilizado para ilustrar el tipo de resultados engañosos que puede generar el ignorar la estructura en los datos y las relaciones causales entre variables.\n\n\n\n\n\n\n\n\n\nTomado de wikipedia\n \nLa estructura de los datos debido a observaciones pertenecientes al mismo grupo puede ser tomada en cuenta usando el grupo como un factor aleatorio, tal y como se hizo en el ejemplo anterior.\n \n\n\nModelos lineales como abordaje estadístico estándar para la inferencia causal \n\n\n\n\n\n\n\n\n\n\n\n\\(\\hat{Y} \\sim_{función\\ de\\ enlace} (\\beta_{o} + \\beta_{grupo}) + \\beta_{1} * x_{1} + \\cdots + \\beta_{n} * x_{n}\\)\n\n\nEste modelo básico incluye una función de enlace que cuando es gausiana (i.e. normal) equivale a un modelo lineal y cuando no, a un modelo generalizado\nCuando el \\(\\beta_{grupo}\\) es diferente entre grupos (i.e. cuando el intercepto difiere entre grupos) es un modelo mixto con intercepto variable (i.e. aleatorio)\n\n \n\n \nEste manual solo pretende sugerir un abordaje estadístico centrado en los modelos de regresión desde el cual se pueden llevar a cabo adecuadamente la mayoría de los análisis estadísticos que usamos en biología. El manual no tiene como objetivo explicar en detalle las particularidades de los modelos generalizados y mixtos. Note que estos modelos, principalmente los mixtos, pueden adaptarse a otras estructuras de datos mas complejas no cubiertas aquí, como lo son las pendientes aleatorias, pendientes e interceptos aleatorios, estructuras de correlación (i.e. autocorrelación espacial o temporal, pedigrís o árboles filogenéticos), medidas repetidas y el uso de pseudoreplicas, entre otras."
  },
  {
    "objectID": "modelos_de_regresion.html#referencias",
    "href": "modelos_de_regresion.html#referencias",
    "title": "Modelos de regresión",
    "section": "2.3 Referencias",
    "text": "2.3 Referencias\n\nRichard McElreath’s Statistical Rethinking book\nR’s rbinom – Simulate Binomial or Bernoulli trials\nR’s rnorm – selecting values from a normal distribution\nR’s exp – Simulating Exponential Distributions\nSimulating data in R\nSpake, R., Bowler, D. E., Callaghan, C. T., Blowes, S. A., Doncaster, C. P., Antao, L. H., … & Chase, J. M. (2023). Understanding ‘it depends’ in ecology: a guide to hypothesising, visualising and interpreting statistical interactions. Biological Reviews.\nComplete introduction to linear regression in R\nLinear regression in R\nHarrison, X. A., Donaldson, L., Correa-Cano, M. E., Evans, J., Fisher, D. N., Goodwin, C. E., & Inger, R. (2018). A brief introduction to mixed effects modelling and multi-model inference in ecology. PeerJ, 6, e4794."
  },
  {
    "objectID": "funciones.html",
    "href": "funciones.html",
    "title": "Funciones",
    "section": "",
    "text": "Identificar los elementos básicos que componen una función\nComprender las características de los principales tipos de argumentos en las funciones\nSer capaz de construir funciones propias"
  },
  {
    "objectID": "funciones.html#nombre",
    "href": "funciones.html#nombre",
    "title": "Funciones",
    "section": "2.1 Nombre",
    "text": "2.1 Nombre\n\n\n\n\n\n\n\n\n\nLos nombres de las funciones tienen pocas restricciones. Siguen las mismas reglas que otros objetos en R. Algunas recomendaciones/reglas:\n\nNo utilice nombres de objetos comunes R (por ejemplo, iris, x) u objetos que ya están en el entorno\nNo use nombres de funciones de uso frecuente (por ejemplo, mean)\nNo puede comenzar con un número\nDebería sugerir lo que hace\nNo debe ser muy largo\n\nEn caso de que tenga varias funciones con el mismo nombre, puede llamarlas individualmente utilizando el nombre del paquete (o namespace) seguido de :::\n\n\nCódigo\n# crear funcion sd\nsd &lt;- function(x) x^10\n\n# no calcula desv. st.\nsd(1:5)\n\n\n[1]       1    1024   59049 1048576 9765625\n\n\nCódigo\n# sd\nstats::sd(1:5)\n\n\n[1] 1.5811\n\n\nCódigo\n# remover nueva sd\nrm(sd)\n\n# usar de nuevo\nsd(1:5)\n\n\n[1] 1.5811\n\n\n \nLa sintaxis namespace::function también se puede usar para llamar a funciones desde paquetes que se han instalado pero que no están cargados en el entorno actual.\n \nLas funciones pueden ser anónimas:\n\n\nCódigo\n(function(x) x^10)(1:5)\n\n\n[1]       1    1024   59049 1048576 9765625\n\n\n \nEsto es más útil cuando se usan las funciones Xapply:\n\n\nCódigo\nl &lt;- list(1:5, 1:4, 1:3)\n\nlapply(l, function(x) x^10)\n\n\n[[1]]\n[1]       1    1024   59049 1048576 9765625\n\n[[2]]\n[1]       1    1024   59049 1048576\n\n[[3]]\n[1]     1  1024 59049"
  },
  {
    "objectID": "funciones.html#argumentos",
    "href": "funciones.html#argumentos",
    "title": "Funciones",
    "section": "2.2 Argumentos",
    "text": "2.2 Argumentos\n\n\n\n\n\n\n\n\n\n \nPermiten a los usuarios ingresar objetos en la función. Los argumentos pueden o no tener valores predeterminados. Cuando los argumentos tienen valores predeterminados, no es necesario proporcionarlos:\n\n\nCódigo\nf1 &lt;- function(x, y = 2) x + y\n\nf1(1)\n\n\n[1] 3\n\n\n \nPor supuesto, se pueden modificar:\n\n\nCódigo\nf1(3, 4)\n\n\n[1] 7\n\n\n \nLos argumentos sin valor predeterminado deben ser proporcionados:\n\n\nCódigo\nf1()\n\n\nError in f1(): el argumento \"x\" está ausente, sin valor por omisión\n\n\n \nSi todos los argumentos tienen un valor predeterminado, se puede invocar la función sin proporcionar ningún argumento:\n\n\nCódigo\nf1 &lt;- function(x = -2, y = 2) x + y\n\nf1()\n\n\n[1] 0\n\n\n \nEse es el caso de dev.off() y Sys.time():\n\n\nCódigo\nSys.time()\n\n\n[1] \"2024-08-29 09:25:09.637 CST\"\n\n\n \nLos argumentos pueden especificarse implícitamente por posición o por nombres incompletos:\n\n\nCódigo\nf2 &lt;- function(a1, b1, b2) {\n  list(a1 = a1, b1 = b1, b2 = b2)\n}\n\n# por posicion\nstr(f2(1, 2, 3))\n\n\nList of 3\n $ a1: num 1\n $ b1: num 2\n $ b2: num 3\n\n\nCódigo\n# por posicion y nombre\nstr(f2(a = 1, 2, 3))\n\n\nList of 3\n $ a1: num 1\n $ b1: num 2\n $ b2: num 3\n\n\nCódigo\nstr(f2(1, a = 2, 3))\n\n\nList of 3\n $ a1: num 2\n $ b1: num 1\n $ b2: num 3\n\n\nCódigo\nstr(f2(1, 2, a = 3))\n\n\nList of 3\n $ a1: num 3\n $ b1: num 1\n $ b2: num 2\n\n\nCódigo\n# por posicion y nombre parcial\nstr(f2(1, a = 2, b1 = 3))\n\n\nList of 3\n $ a1: num 2\n $ b1: num 3\n $ b2: num 1\n\n\n \nSin embargo, esto no funciona si los nombres son ambiguos:\n\n\nCódigo\nf2(b = 1, 2, a = 3)\n\n\nError in f2(b = 1, 2, a = 3): el argumento 1 concuerda con multiples argumentos formales\n\n\n \nEs más seguro (y, por lo tanto, una mejor práctica) usar los nombres completos de los argumentos.\n \nLas funciones también pueden tomar argumentos lógicos. Estos son útiles para modificar el comportamiento de la función para que coincida con diferentes escenarios. Por ejemplo, mean() permite a los usuarios ignorar los NA:\n\n\nCódigo\nv1 &lt;- c(1, 2, 3, NA)\n\n# sin ignorar NAs\nmean(v1, na.rm = FALSE)\n\n\n[1] NA\n\n\nCódigo\n# ignorando NAs\nmean(v1, na.rm = TRUE)\n\n\n[1] 2"
  },
  {
    "objectID": "funciones.html#ejercicio-1",
    "href": "funciones.html#ejercicio-1",
    "title": "Funciones",
    "section": "2.3 Ejercicio 1",
    "text": "2.3 Ejercicio 1\n1.1 ¿Qué hace la función cor.test()?\n1.2 Úsela con “Sepal.Length” y “Sepal.Width” de los datos de ejemplo iris (use data(iris))\n1.3 ¿Qué argumentos deben proporcionarse?\n1.4 ¿Qué hace el argumento alternative? Use diferentes valores para este argumento y compare los resultados\n1.5 ¿Cómo se puede calcular la correlación de Spearman?\n1.6 ¿Qué tipo de objeto devuelve esta función?\n1.7 ¿Cómo puede obtener el valor de p directamente del resultado de la función (sin guardar el resultado como un objeto)?\n1.8 Escoga una función de R y lea su documentación con el fin de entender su uso, cada uno de sus argumentos (y que tipo de objetos requieren) y el resultado que produce (es probable que se le pida que explique esto al grupo)"
  },
  {
    "objectID": "funciones.html#cuerpo",
    "href": "funciones.html#cuerpo",
    "title": "Funciones",
    "section": "2.4 Cuerpo",
    "text": "2.4 Cuerpo\n\n\n\n\n\n\n\n\n\n \nEl cuerpo de una función puede contener:\n\nComprobación de argumentos\nManipulación de datos\nDefinición de resultados\n\n \nEl cuerpo de la función puede tomar el mismo tipo de código utilizado en cualquier rutina de R. Sin embargo, los objetos creados no estarán disponibles en el entorno.\nCuando se realizan varios cálculos, debemos incluir una declaración de retorno (return statement), que define explícitamente la salida de la función. Esto se hace usando la función return():\n\n\nCódigo\n# sin \"return statement\"\nf1 &lt;- function(x, y) {\n  z1 &lt;- 2 * x + y\n  z2 &lt;- x + 2 * y\n  z3 &lt;- 2 * x + 2 * y\n  z4 &lt;- x / y\n}\n\nf1(5, 3)\n\nf1_out &lt;- f1(5, 3)\n\nf1_out\n\n\n[1] 1.6667\n\n\nCódigo\n# con \"return statement\"\nf2 &lt;- function(x, y) {\n  z1 &lt;- 2 * x + y\n  z2 &lt;- x + 2 * y\n  z3 &lt;- 2 * x + 2 * y\n  z4 &lt;- x / y\n\n  return(c(z1, z2, z3, z4))\n}\n\nf2(5, 3)\n\n\n[1] 13.0000 11.0000 16.0000  1.6667\n\n\nCódigo\nf2_out &lt;- f2(5, 3)\n\nf2_out\n\n\n[1] 13.0000 11.0000 16.0000  1.6667\n\n\n \nPor lo tanto, cuando no se proporciona una declaración de retorno, la función devolverá el último objeto que se creó en el cuerpo de la función:\n\n\nCódigo\n# sin \"return statement\"\nf3 &lt;- function(x, y) {\n  z1 &lt;- 2 * x + y\n  z2 &lt;- x + 2 * y\n  z3 &lt;- 2 * x + 2 * y\n  z4 &lt;- x / y\n\n  c(z1, z2, z3, z4)\n}\n\nf3(5, 3)\n\n\n[1] 13.0000 11.0000 16.0000  1.6667\n\n\nCódigo\nf3_out &lt;- f3(5, 3)\n\nf3_out\n\n\n[1] 13.0000 11.0000 16.0000  1.6667\n\n\n \nEs más seguro usar return().\n \nCuando una función realiza varias tareas, podemos usar una lista para juntar los diferentes objetos. Esto es particularmente útil cuando se generan objetos de diferentes clases (por ejemplo, vectores y listas):\n\n\nCódigo\nf4 &lt;- function(x, y) {\n  # 1 elemento\n  z1 &lt;- x + y\n\n  # 2 elementos\n  z2 &lt;- c(x, y / 3)\n\n  # vector logico\n  z3 &lt;- z2 &lt; 10\n\n\n  l &lt;- list(z1, z2, z3)\n\n  return(l)\n}\n\nf4(10, 5)\n\n\n[[1]]\n[1] 15\n\n[[2]]\n[1] 10.0000  1.6667\n\n[[3]]\n[1] FALSE  TRUE\n\n\n \nPodemos acceder a elementos específicos de la salida de una función mediante indexación:\n\n\nCódigo\n# elemento 1\nf4(10, 5)[[1]]\n\n\n[1] 15\n\n\nCódigo\n# elemento 2\nf4(10, 5)[[2]]\n\n\n[1] 10.0000  1.6667\n\n\nCódigo\n# elemento 3\nf4(10, 5)[[3]]\n\n\n[1] FALSE  TRUE\n\n\n \nPor supuesto, también podemos guardar el resultado como un objeto y acceder a cada elemento mediante la indexación:\n\n\nCódigo\n# elemento 1\nout &lt;- f4(10, 5)\n\n# elemento 1\nout[[1]]\n\n\n[1] 15\n\n\nCódigo\n# elemento 2\nout[[2]]\n\n\n[1] 10.0000  1.6667"
  },
  {
    "objectID": "funciones.html#ejercicio-2",
    "href": "funciones.html#ejercicio-2",
    "title": "Funciones",
    "section": "2.5 Ejercicio 2",
    "text": "2.5 Ejercicio 2\n2.1 Cree una función llamada promedio que calcule el promedio de un vector numérico. Internamente solo puede utilizar las funciones sum() y length() (suma y división, no puede llamar la función mean())\n2.2 Cree una función que tome 2 argumentos numéricos (llámelos ‘x’ y ‘y’), eleve cada uno al cuadrado y luego los sume\n2.3 Agregue valores predeterminados a cada argumento\n2.4 Ejecute la función usando los valores predeterminados\n2.5 Ejecute la función usando un valor predeterminado y uno proporcionado en la llamada\n2.6 Ejecute la función proporcionando ambos valores en la llamada"
  },
  {
    "objectID": "funciones.html#ejercicio-3",
    "href": "funciones.html#ejercicio-3",
    "title": "Funciones",
    "section": "3.1 Ejercicio 3",
    "text": "3.1 Ejercicio 3\n3.1 Cree una función que tome 3 argumentos numéricos, multiplíquelos y luego calcule el logaritmo natural del resultado (función log())\n3.2 Agregue valores predeterminados a cada argumento\n3.3 Ejecute la función con uno de los argumentos con un número negativo. ¿Qué pasa? ¿Por qué?\n3.4 Agregue un argumento lógico que permita a los usuarios (si lo desean) convertir los argumentos de entrada a su valor absoluto (usando la función abs()). Agregue las modificaciones necesarias para que la función haga los cálculos con y sin valores absolutos."
  },
  {
    "objectID": "funciones.html#código-mas-limpio",
    "href": "funciones.html#código-mas-limpio",
    "title": "Funciones",
    "section": "4.1 Código mas limpio",
    "text": "4.1 Código mas limpio\nLos objetos creados dentro del cuerpo no están disponibles en el entorno actual:\n\n\nCódigo\n# primero remover todo los objetos\nrm(list = ls())\n\nf5 &lt;- function(x) {\n  sqr &lt;- x * x\n  lg_sqr &lt;- log(x)\n  return(lg_sqr)\n}\n\nf5(7)\n\n\n[1] 1.9459\n\n\nCódigo\nexists(\"sqr\")\n\n\n[1] FALSE\n\n\nCódigo\nexists(\"lg_sqr\")\n\n\n[1] FALSE\n\n\n\n\nCódigo\nx &lt;- 7\nsqr &lt;- x * x\nlg_sqr &lt;- log(x)\n\n\nexists(\"sqr\")\n\n\n[1] TRUE\n\n\nCódigo\nexists(\"lg_sqr\")\n\n\n[1] TRUE"
  },
  {
    "objectID": "funciones.html#facil-de-correr-y-compartir",
    "href": "funciones.html#facil-de-correr-y-compartir",
    "title": "Funciones",
    "section": "4.2 Facil de correr y compartir",
    "text": "4.2 Facil de correr y compartir\nSe pueden invocar funciones desde archivos de R externos sin estar definidas en el código actual con la función source(). En este ejemplo creamos la función fnctn_X:\n\n\nCódigo\nfnctn_X &lt;- function(sq_mt, vctr) {\n  # trasponer matriz y calcular est dev\n  stp1 &lt;- t(sq_mt)\n  stp2 &lt;- vctr * vctr\n\n  # guardar en lista\n  rslt &lt;- list(stp1, stp2)\n  return(rslt)\n}\n\nfnctn_X(sq_mt = cbind(c(1, 2), c(3, 4)), vctr = c(2, 3))\n\n\n[[1]]\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n[[2]]\n[1] 4 9\n\n\n \nGuarde el código anterior en un archivo R llamado ‘function_X.R’. Ahora la función se puede cargar usando source():\n\n\nCódigo\n# removamosla del ambiente\nrm(fnctn_X)\n\n# cargar funcion\nsource(\"function_X.R\")\n\n# run it\nfnctn_X(sq_mt = cbind(c(1, 2), c(3, 4)), vctr = c(2, 3))\n\n\n\n\n[[1]]\n     [,1] [,2]\n[1,]    1    2\n[2,]    3    4\n\n[[2]]\n[1] 4 9\n\n\n \nAdemás, este código se puede compartir fácilmente. Se puede enviar por correo electrónico o publicar en línea. Incluso se puede cargar desde repositorios en línea:\n\n\nCódigo\n# remover objetos\nrm(list = ls())\n\n# revisar si existe en ambiente actual\nexists(\"fnctn_X\")\n\n\n[1] FALSE\n\n\nCódigo\n# cargar desde el internet\nsource(\n  paste0(\n    \"https://raw.githubusercontent.com/maRce10/\",\n    \"r_avanzado_2023/master/data/function_x.r\"\n  )\n)\n\n\n# revisar si existe en ambiente actual\nexists(\"fnctn_X\")\n\n\n[1] TRUE"
  },
  {
    "objectID": "funciones.html#se-aplica-fácilmente-a-nuevos-objetos",
    "href": "funciones.html#se-aplica-fácilmente-a-nuevos-objetos",
    "title": "Funciones",
    "section": "4.3 Se aplica fácilmente a nuevos objetos",
    "text": "4.3 Se aplica fácilmente a nuevos objetos\nEsto ya debería ser obvio a este punto."
  },
  {
    "objectID": "funciones.html#otros-consejos",
    "href": "funciones.html#otros-consejos",
    "title": "Funciones",
    "section": "4.4 Otros consejos",
    "text": "4.4 Otros consejos\n\nConstruir funciones cortas:\n\nFácil de leer\nFácil de arreglar y actualizar\nSi es demasiado largo, probablemente debería dividirse en varias funciones\nGenera modularidad\n\nAñadir comentarios a todo el código  \nAgregar descripciones a cada uno de los argumentos que toma  \nFunción de prueba con diferentes valores/escenarios"
  },
  {
    "objectID": "funciones.html#ejercicio-4",
    "href": "funciones.html#ejercicio-4",
    "title": "Funciones",
    "section": "4.5 Ejercicio 4",
    "text": "4.5 Ejercicio 4\n4.1 Cree una funcion que calcule el promedio, la desviación estándar y el error estándar de un vector numérico. Estos valores deben ser devueltos como una lista con nombres.\n4.2 Permita a los usuarios ignorar los NAs (similar al argumento na.rm en mean(), pista: añada un argumento lógico)\n4.3 Haga que la función además produzca un histograma del vector numérico proporcionado por el usuario\n4.4 Haga que la función escoja un color al azar para las barras del histograma cada vez que se corre (pista: sample(vector.de.colores, 1))\n4.5 Añada un argumento a la función que permita el usuario, si lo desea, calcular la sumatoria (sum()) junto con el resto de los descriptores estadísticos\n4.6 Agregue el promedio y la desviación estándar al título del histograma (pista: use paste())\n4.7 Modifique la función para que también cree una linea vertical indicando el promedio del vector numérico proporcionado por el usuario\n4.8 Modifique la función para que añada un polígono transparente sobre el área que cubre el promedio +/- la desviación estándar (puede usar la función rect())\n4.9 Modifique la función con un argumento lógico que permita al usuario controlar si se crea un gráfico o no"
  },
  {
    "objectID": "funciones.html#lecturas-adicionales",
    "href": "funciones.html#lecturas-adicionales",
    "title": "Funciones",
    "section": "4.6 Lecturas adicionales",
    "text": "4.6 Lecturas adicionales\n\n Introduction to R guide to writing functions with information for a total beginner\nInformation on functions for intermediate and advanced users (Hadley Wickham).\nThe official R intro material on writing your own functions (ir a “Writing your own function”)"
  },
  {
    "objectID": "funciones.html#referencias",
    "href": "funciones.html#referencias",
    "title": "Funciones",
    "section": "4.7 Referencias",
    "text": "4.7 Referencias\n\nWickham, Hadley, and Garrett Grolemund. 2016. R for data science: import, tidy, transform, visualize, and model data. website\n\n\nInformación de la sesión\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] htmlwidgets_1.6.4 compiler_4.3.2    fastmap_1.2.0     cli_3.6.3        \n [5] tools_4.3.2       htmltools_0.5.8.1 rstudioapi_0.16.0 yaml_2.3.10      \n [9] rmarkdown_2.27    knitr_1.48        jsonlite_1.8.8    xfun_0.47        \n[13] digest_0.6.37     rlang_1.1.4       evaluate_0.24.0"
  },
  {
    "objectID": "ggplot2.html",
    "href": "ggplot2.html",
    "title": "Gráficos con ggplot2",
    "section": "",
    "text": "Comprender la lógica detras de la estructura los gráficos con ggplot2\nSer capaz de intregrar en un gŕafico diferentes fuentes de información que representen la complejidad de los datos"
  },
  {
    "objectID": "ggplot2.html#ggplot2",
    "href": "ggplot2.html#ggplot2",
    "title": "Gráficos con ggplot2",
    "section": "ggplot2",
    "text": "ggplot2\n\nUn paquete de R diseñado específicamente para producir gráficos\nA diferencia de otros paquetes, ggplot2 tiene su propia gramática\nLa gramática se basa en la “Gramática de los gráficos” (Wilkinson 2005)\nMódulos independientes que pueden combinarse de muchas formas\nEsta gramática proporciona una gran flexibilidad"
  },
  {
    "objectID": "ggplot2.html#gramática-de-gráficos",
    "href": "ggplot2.html#gramática-de-gráficos",
    "title": "Gráficos con ggplot2",
    "section": "0.1 Gramática de gráficos",
    "text": "0.1 Gramática de gráficos\nLa idea principal es empezar con una capa base de datos brutos y luego añadir más capas de anotaciones y resúmenes estadísticos. El paquete nos permite producir gráficos utilizando la misma estructura de pensamiento que utilizamos al diseñar un análisis, reduciendo la distancia de cómo visualizamos un gráfico en la cabeza y el producto final.\nAprender la gramática no sólo es útil para producir un gráfico de interés, sino también para pensar en otros gráficos más complejos. La ventaja de esta gramática es la posibilidad de crear nuevos gráficos compuestos por nuevas combinaciones de elementos."
  },
  {
    "objectID": "ggplot2.html#componentes-del-gráfico",
    "href": "ggplot2.html#componentes-del-gráfico",
    "title": "Gráficos con ggplot2",
    "section": "0.2 Componentes del gráfico",
    "text": "0.2 Componentes del gráfico\nTodos los gráficos ggplot2 contienen los siguientes componentes:\n\nDatos - El objeto R con la información que necesita ser trazada\nCapas - Los datos específicos que serán graficados (ej. ‘x’ & ‘y’)\nEscala - Rango de datos a incluir\nCoordenadas - Sistema de coordenadas (no se utiliza muy a menudo)\nParcelas (facets) - Determina cómo dividir los datos en subparcelas en un multipanel\nTema - Controla el estilo del gráfico\n\n \nEstos componentes se juntan utilizando “+”.\nLa sintaxis más habitual incluye los datos dentro de la llamada “ggplot” y una capa “geom_”.\n \nPrimero instala/carga el paquete:\n\n\nCódigo\n# install\ninstall.packages(\"ggplot2\")\n\n# load library\nlibrary(ggplot2)"
  },
  {
    "objectID": "ggplot2.html#gráficos-de-dispersión",
    "href": "ggplot2.html#gráficos-de-dispersión",
    "title": "Gráficos con ggplot2",
    "section": "0.3 Gráficos de dispersión",
    "text": "0.3 Gráficos de dispersión\nUtilicemos el conjunto de datos “iris” para crear gráficos de dispersión:\n\n\nCódigo\nggplot(data = iris, mapping = aes(x = Sepal.Length, y = Petal.Length)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n \nThis plot is defined by 3 components: 1. “data”- iris 1. “aes” - Sepal.length vs Petal.length 1. “layer” - Points (geom)"
  },
  {
    "objectID": "ggplot2.html#atributos-estéticos",
    "href": "ggplot2.html#atributos-estéticos",
    "title": "Gráficos con ggplot2",
    "section": "0.4 Atributos estéticos",
    "text": "0.4 Atributos estéticos\nTambién podemos añadir otros atributos estéticos como el color, la forma y el tamaño. Estos atributos se pueden incluir dentro de aes():\n\n\nCódigo\n# color by species\nggplot(\n  data = iris,\n  mapping = aes(x = Sepal.Length, y = Petal.Length, color = Species)\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n\nCódigo\n# color and shape by species\nggplot(\n  data = iris,\n  mapping = aes(\n    x = Sepal.Length,\n    y = Petal.Length,\n    color = Species,\n    shape = Species\n  )\n) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n \nTenga en cuenta que los argumentos estéticos también pueden incluirse en la capa “geom”:\n\n\nCódigo\nggplot(\n  data = iris,\n  mapping = aes(x = Sepal.Length, y = Petal.Length)\n) +\n  geom_point(aes(color = Species, shape = Species))\n\n\n\n\n\n\n\n\n\n \nTambién podemos incluir un valor fijo:\n\n\nCódigo\nggplot(\n  data = iris,\n  mapping = aes(x = Sepal.Length, y = Petal.Length)\n) +\n  geom_point(color = \"red2\")\n\n\n\n\n\n\n\n\n\n \nAlgunos atributos funcionan mejor con algunos tipos de datos:\n\nColor y forma: variables categóricas\nTamaño: variables continuas\n\n \n\n\nEjercicio 1\nUtilizando el conjunto de datos “hylaeformis”:\n\n\nCódigo\n# lear desde el sitio del curso\nhylaeformis_data &lt;- read.csv(\n  paste0(\"https://raw.githubusercontent.com/maRce10/\", \"r_avanzado_2023/master/data/hylaeformis_data.csv\")\n)\n\n# or bajar manualmente y leer copia local\nhylaeformis_data &lt;- read.csv(\"hylaeformis_data.csv\", stringsAsFactors = FALSE)\n\nhead(hylaeformis_data, 20)\n\n\n\n1.1 Create a scatter plot of vs “meanfreq” (mean frequency)\n1.1 Crear un gráfico de dispersión de duración (“duration”) vs frecuencia promedio (“meanfreq”)\n\n1.2 Añadir un atributo estético para mostrar un color diferente para cada localidad\n\n1.3 Añade otro atributo estético para mostrar el rango de frecuencia dominante (“dfrange”) como tamaño los símbolos"
  },
  {
    "objectID": "ggplot2.html#gráficos-multipanel-facetting",
    "href": "ggplot2.html#gráficos-multipanel-facetting",
    "title": "Gráficos con ggplot2",
    "section": "0.5 Gráficos multipanel (Facetting)",
    "text": "0.5 Gráficos multipanel (Facetting)\n\nOtra forma de visualizar variables categóricas\nPermite crear gráficos multipanel para cada nivel de la variable\n2 tipos: “grid” & “wrap”\n\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species)\n\n\n\n\n\n\n\n\n\nCódigo\n# o\n\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_grid(~Species)\n\n\n\n\n\n\n\n\n\n \nLa escala puede ser fija o libre para los ejes x e y, y puede modificarse el número de columnas y filas:\n\n\nCódigo\n# free x\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species, scales = \"free_x\")\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# free x and 3 rows\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species, scales = \"free_y\", nrow = 3)\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# both free and 2 rows\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  facet_wrap(~Species, scales = \"free\", nrow = 2)\n\n\n\n\n\n\n\n\n\n \nTenga en cuenta que también podemos guardar el componente básico como un objeto R y añadir otros componentes más adelante en el código:\n\n\nCódigo\np &lt;- ggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point()\n\np + facet_wrap(~Species, scales = \"free_x\", nrow = 3)"
  },
  {
    "objectID": "ggplot2.html#geoms-adicionales",
    "href": "ggplot2.html#geoms-adicionales",
    "title": "Gráficos con ggplot2",
    "section": "0.6 “geoms” adicionales",
    "text": "0.6 “geoms” adicionales\n\ngeom_smooth() - añade las líneas de mejor ajuste (incluyendo CI)\ngeom_boxplot() - Distribución de frecuencias\ngeom_histogram() & geom_freqpoly() - distribuciones de frecuencia\ngeom_bar() - distribución de frecuencias de variables categóricas\ngeom_path() & geom_line() - añade líneas a los gráficos de dispersión\n\n \n\n0.6.1 geom_smooth()\nLas líneas de regresión de mejor ajuste pueden añadirse con geom_smooth():\n\n\nCódigo\n# con CI\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  geom_smooth(method = \"lm\") +\n  facet_wrap(~Species, scales = \"free\", nrow = 3)\n\n\n\n\n\n\n\n\n\nCódigo\n# sin CI\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE) +\n  facet_wrap(~Species, scales = \"free\", nrow = 3)\n\n\n\n\n\n\n\n\n\n \n\nEjercicio 2\nUtilizando el conjunto de datos de ejemplo “msleep”:\n\n2.1 Crear un gráfico de dispersión de peso corporal (“bodywt”) frente a peso cerebral (“brainwt”)\n\n2.2 Añadir orden (“order”) como estética del color\n\n2.3 Añadir un componente “faceta” para dividir los gráficos por orden utilizando escalas libres\n\n2.4 Elimine los órdenes con menos de 4 especies en el conjunto de datos y haga un gráfico similar al 2.3\n\n2.5 Añadir una línea de mejor ajuste a cada gráfico del panel\n\n\n\n\n0.6.2 Boxplots\nDe nuevo, sólo se necesita un nuevo componente “geom” para crear un boxplot:\n\n\nCódigo\nggplot(iris, aes(Species, Petal.Length)) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\nUna alternativa interesante son los gráficos de violines:\n\n\nCódigo\nggplot(iris, aes(Species, Petal.Length)) +\n  geom_violin()\n\n\n\n\n\n\n\n\n\n \n\n\n0.6.3 Histogramas\nLo mismo ocurre con los histrogramas y los gráficos de frecuencias:\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_histogram()\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_freqpoly()\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_histogram() +\n  geom_freqpoly()\n\n\n\n\n\n\n\n\n\n \nPodemos controlar la anchura de las barras:\n\n\nCódigo\nggplot(iris, aes(Petal.Length)) +\n  geom_histogram(binwidth = 1, fill = adjustcolor(\"red2\", alpha.f = 0.3))\n\n\nWarning: Duplicated aesthetics after name standardisation: fill\n\n\n\n\n\n\n\n\n\n \nY compara la distribución de los distintos grupos dentro del mismo histograma:\n\n\nCódigo\nggplot(iris, aes(Petal.Length, fill = Species)) +\n  geom_histogram(binwidth = 0.4)\n\n\n\n\n\n\n\n\n\n \n\n\n0.6.4 Gráfico de barras\nMuestran la distribución de variables discretas (categóricas):\n\n\nCódigo\ntab &lt;- table(msleep$order)\n\ndf &lt;-\n  as.data.frame(table(msleep$order[msleep$order %in% names(tab)[tab &gt; 3]]))\n\nggplot(df, aes(Var1, Freq)) +\n  geom_bar(stat = \"identity\")"
  },
  {
    "objectID": "ggplot2.html#personalización-de-ggplots",
    "href": "ggplot2.html#personalización-de-ggplots",
    "title": "Gráficos con ggplot2",
    "section": "0.7 Personalización de ggplots",
    "text": "0.7 Personalización de ggplots\nAdemás de las funciones básicas (por ejemplo, componentes) descritas anteriormente, ggplot tiene muchas otras herramientas (tanto argumentos como funciones adicionales) para personalizar aún más los gráficos. Prácticamente todo se puede modificar. Aquí vemos algunas de las herramientas más comunes.\n \n\n0.7.1 Temas\nggplot2 viene con algunos temas por defecto que se pueden aplicar fácilmente para modificar el aspecto de nuestros gráficos:\n\n\nCódigo\np &lt;- ggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point()\n\np + theme_classic()\n\n\n\n\n\n\n\n\n\nCódigo\np + theme_bw()\n\n\n\n\n\n\n\n\n\nCódigo\np + theme_minimal()\n\n\n\n\n\n\n\n\n\n \nLa mayoría de los temas difieren en el uso de cuadrículas, líneas de borde y patrones de etiquetado de ejes.\n \n\n\n0.7.2 Personalización de ejes\nLos límites de los ejes pueden modificarse como sigue:\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length)) +\n  geom_point() +\n  xlim(c(0, 10))\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n  geom_point() +\n  xlim(c(0, 10)) +\n  ylim(c(0, 9))\n\n\n\n\n\n\n\n\n\n \nLos ejes también pueden transformarse:\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n  geom_point() +\n  scale_x_continuous(trans = \"log\") +\n  scale_y_continuous(trans = \"log2\")\n\n\n\n\n\n\n\n\n\n \no invertidos:\n\n\nCódigo\nggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n  geom_point() +\n  scale_y_reverse()\n\n\n\n\n\n\n\n\n\n\n\n0.7.3 Guardar ggplots\nLos ggplots pueden exportarse como archivos de imagen utilizando la función ggsave:\n\n\nCódigo\nggplot(\n  data = msleep[msleep$order %in% names(tab)[tab &gt; 5], ],\n  mapping = aes(x = bodywt, y = brainwt)\n) +\n  geom_point() +\n  facet_wrap(~order, scales = \"free\")\n\n\nWarning: Removed 21 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n\n\n\n\n\n\n\nCódigo\n# Export\nggsave(\"plot.png\", width = 5, height = 5)\n\n\nWarning: Removed 21 rows containing missing values or values outside the scale range\n(`geom_point()`).\n\n\n \nEl tipo de archivo de imagen se identificará por la extensión en el nombre del archivo\n \nPersonalización adicional del eje:\n\n\nCódigo\n# Log2 scaling of the y axis (with visually-equal spacing)\nrequire(scales)\n\np + scale_y_continuous(trans = log2_trans())\n\n\n\n\n\n\n\n\n\nCódigo\n# show exponents\np + scale_y_continuous(\n  trans = log2_trans(),\n  breaks = trans_breaks(\"log2\", function(x) 2^x),\n  labels = trans_format(\"log2\", math_format(2^.x))\n)\n\n\n\n\n\n\n\n\n\nCódigo\n# Percent\np + scale_y_continuous(labels = percent)\n\n\n\n\n\n\n\n\n\nCódigo\n# dollar\np + scale_y_continuous(labels = dollar)\n\n\n\n\n\n\n\n\n\nCódigo\n# scientific\np + scale_y_continuous(labels = scientific)\n\n\n\n\n\n\n\n\n\nCódigo\n### Agregar \"tick marks\" ###\n\n# Cargar librerías\nlibrary(MASS)\n\ndata(Animals)\n\n# x and y axis are transformed and formatted\np2 &lt;- ggplot(Animals, aes(x = body, y = brain)) +\n  geom_point(size = 4) +\n  scale_x_log10(\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x))\n  ) +\n  scale_y_log10(\n    breaks = trans_breaks(\"log10\", function(x) 10^x),\n    labels = trans_format(\"log10\", math_format(10^.x))\n  ) +\n  theme_bw()\n\n# log-log plot without log tick marks\np2\n\n\n\n\n\n\n\n\n\nCódigo\n# Show log tick marks\np2 + annotation_logticks()\n\n\n\n\n\n\n\n\n\nCódigo\n# # Log ticks on left and right\np2 + annotation_logticks(sides = \"lr\")\n\n\n\n\n\n\n\n\n\nCódigo\n# All sides\np2 + annotation_logticks(sides = \"trbl\")\n\n\n\n\n\n\n\n\n\n \n\n\n0.7.4 Otros gráficos\nSe pueden generar muchos otros tipos de gráficos. Aquí muestro un ejemplo de gráficos de contorno y de “mapa de calor”:\n\n\nCódigo\nhead(faithful)\n\n\n\n\n\n\neruptions\nwaiting\n\n\n\n\n3.600\n79\n\n\n1.800\n54\n\n\n3.333\n74\n\n\n2.283\n62\n\n\n4.533\n85\n\n\n2.883\n55\n\n\n\n\n\n\nCódigo\nggplot(faithfuld, aes(eruptions, waiting)) +\n  geom_contour(aes(z = density, colour = after_stat(level)))\n\n\n\n\n\n\n\n\n\nCódigo\nggplot(faithfuld, aes(eruptions, waiting)) +\n  geom_raster(aes(fill = density))"
  },
  {
    "objectID": "ggplot2.html#otros-paquetes-de-gráficos-en-r",
    "href": "ggplot2.html#otros-paquetes-de-gráficos-en-r",
    "title": "Gráficos con ggplot2",
    "section": "0.8 Otros paquetes de gráficos en R",
    "text": "0.8 Otros paquetes de gráficos en R\n\nggvis (ggplots interactivos)\nvcd (Warnes 2015)\nplotrix (Lemon et al. 2006)\ngplots (Warnes 2015)\n\nConsulte la CRAN Graphics Task View para obtener una lista más completa de herramientas gráficas en R."
  },
  {
    "objectID": "ggplot2.html#references",
    "href": "ggplot2.html#references",
    "title": "Gráficos con ggplot2",
    "section": "0.9 References",
    "text": "0.9 References\n\nLemon J (2006) Plotrix: a package in the red light district of R. R-News 6(4):8–12\nWarnes GR, Bolker B, Bonebakker L, Gentleman R, Liaw WHA, Lumley T, Maechler M, Magnusson A, Moeller S, Schwartz M, Venables B (2015) gplots: various R programming tools for plotting data. R package version 2.17.0. https://CRAN.R-project.org/package=gplots\nWickham H (2010) A layered grammar of graphics. J Comput Graph Stat 19(1):3–28\nWilkinson L (2005) The grammar of graphics. Statistics and computing, 2nd edn. Springer, New York\n\n\n\nInformación de la sesión\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] scales_1.3.0       viridis_0.6.5      viridisLite_0.4.2  MASS_7.3-55       \n[5] RColorBrewer_1.1-3 ggplot2_3.5.1      knitr_1.48         kableExtra_1.4.0  \n\nloaded via a namespace (and not attached):\n [1] Matrix_1.6-5      gtable_0.3.5      jsonlite_1.8.8    dplyr_1.1.4      \n [5] compiler_4.3.2    tidyselect_1.2.1  xml2_1.3.6        stringr_1.5.1    \n [9] gridExtra_2.3     textshaping_0.3.7 splines_4.3.2     systemfonts_1.1.0\n[13] yaml_2.3.10       fastmap_1.2.0     lattice_0.20-45   R6_2.5.1         \n[17] labeling_0.4.3    generics_0.1.3    isoband_0.2.7     htmlwidgets_1.6.4\n[21] tibble_3.2.1      munsell_0.5.1     svglite_2.1.3     pillar_1.9.0     \n[25] rlang_1.1.4       utf8_1.2.4        stringi_1.8.4     xfun_0.47        \n[29] cli_3.6.3         mgcv_1.8-39       withr_3.0.1       magrittr_2.0.3   \n[33] digest_0.6.37     grid_4.3.2        rstudioapi_0.16.0 nlme_3.1-155     \n[37] lifecycle_1.0.4   vctrs_0.6.5       evaluate_0.24.0   glue_1.7.0       \n[41] farver_2.1.2      ragg_1.2.7        fansi_1.0.6       colorspace_2.1-0 \n[45] rmarkdown_2.27    tools_4.3.2       pkgconfig_2.0.3   htmltools_0.5.8.1"
  },
  {
    "objectID": "programa.html#recursos-adicionales",
    "href": "programa.html#recursos-adicionales",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Badillo et al (2020). An introduction to machine learning"
  },
  {
    "objectID": "programa.html#recursos-adicionales-1",
    "href": "programa.html#recursos-adicionales-1",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Roediger et al (2001). Factors that determine false recall: A multiple regression analysis"
  },
  {
    "objectID": "programa.html#recursos-adicionales-2",
    "href": "programa.html#recursos-adicionales-2",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Chen et al (2023). Identifying the top determinants of psychological resilience among community older adults during COVID-19 in Taiwan: A random forest approach"
  },
  {
    "objectID": "programa.html#recursos-adicionales-3",
    "href": "programa.html#recursos-adicionales-3",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Choi et al. (2020). Introduction to machine learning, neural networks, and deep learning\nVideo: Random Forest Algorithm Clearly Explained"
  },
  {
    "objectID": "programa.html#recursos-adicionales-4",
    "href": "programa.html#recursos-adicionales-4",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nVideo: Convolutional Neural Networks (CNNs) explained\nVideo: Neural Network In 5 Minutes"
  },
  {
    "objectID": "programa.html#recursos-adicionales-5",
    "href": "programa.html#recursos-adicionales-5",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Yarkoni & Westfall. 2017. Choosing prediction over explanation in psychology: Lessons from machine learning\nVideo: ¿Que es una red neuronal?"
  },
  {
    "objectID": "programa.html#recursos-adicionales-6",
    "href": "programa.html#recursos-adicionales-6",
    "title": "Antes de empezar el curso",
    "section": "Recursos adicionales",
    "text": "Recursos adicionales\n\nLectura: Yarkoni & Westfall. 2017. Choosing prediction over explanation in psychology: Lessons from machine learning\nVideo: Clustering in Machine Learning"
  },
  {
    "objectID": "preparacion_curso.html",
    "href": "preparacion_curso.html",
    "title": "1 Instalacion de software",
    "section": "",
    "text": "1 Instalacion de software\n\nInstalá o actualizá R en el ordenador que utilizarás durante el curso (https://cran.r-project.org). Asumo que ya lo tenés instalado, pero intentá actualizarlo si tenés una versión de R &lt; 4.0.0. Puedes averiguar qué versión de R tenés ejecutando esto en la consola de R:\n\n\n\nCódigo\nversion$version.string\n\n\n\nActualizá todos los paquetes de R si ya tenías instalado R (⚠️ este paso puede tardar mucho en ejecutarse ⚠️):\n\n\n\nCódigo\nupdate.packages(ask = FALSE)\n\n\n\nInstalá R en la computadora que utilizarás durante el curso (https://cran.r-project.org/). Probablemente ya lo tenés instalado, pero intentá actualizarlo si tenés una versión de R &lt; 4.0.0. Podés encontrar qué versión de R tenés ejecutando esto en la consola de R:\n\n\n\nCódigo\nversion$version.string\n\n\n\nInstalá la interfaz de RStudio (https://posit.co/download/rstudio-desktop/, elejí la versión gratuita).\nAbrí RStudio y seleccioná la pestaña “Tools” y luego “Global options” (última opción). Seleccioná la opción “Code”, luego seleccioná la casilla de “Soft wrap”.\nTambién en Rstudio: Seleccioná la opción “Pane Layout” y mové “Source” al panel superior izquierdo y “Console” al panel superior derecho. Esta disposición asigna más espacio en la pantalla a los paneles más útiles. Dalé “Apply” y “Ok”. Para aquellos que no estén familiarizados con RStudio, “Source” es un editor de texto donde se escribe el código y donde guardas el código en un archivo físico (normalmente en formato .R) y la consola evalúa el código que se envia desde el “Source” e imprime los resultados (si los hay). Podés escribir código en la consola, pero no se guardará en un archivo físico.\nAhora en la consola de R en Rstudio ejecutá el siguiente código para instalar los paquetes que estaremos usando durante el curso:\n\n\n\nCódigo\n# # cargar funciones del paquete \"sketchy\"\n# source(\n#   paste0(\n#     \"https://raw.githubusercontent.com/maRce10/\",\n#     \"sketchy/main/R/load_packages.R\"\n#   )\n# )\n# source(\n#   paste0(\n#     \"https://raw.githubusercontent.com/maRce10/\",\n#     \"sketchy/main/R/internal_functions.R\"\n#   )\n# )\n# \n# instalar paquete sketchy para instalar otros paquetes y creer proyectos\n# install.packages(\"sketchy\")\n\n# cargar paquete\nlibrary(sketchy)\n\n# instalar/ cargar paquetes\nload_packages(\n  packages = c(\n    \"remotes\",\n    \"RColorBrewer\",\n    \"ggplot2\",\n    \"viridis\",\n    \"MASS\",\n    \"psych\",\n    \"lme4\",\n    \"caret\",\n    \"lmerTest\",\n    \"sjPlot\",\n    \"car\",\n    \"nnet\",\n    \"neuralnet\",\n    \"randomForest\",\n    \"dimRed\",\n    github = \"maRce10/sketchy\"\n  )\n)\n\n\n\nCreá un proyecto para el curso corriendo este código:\n\n\n\nCódigo\nlibrary(sketchy)\n\nmake_compendium(\n  name = \"r_avanzado\",\n  path = \"DIRECTORIO_DONDE_HACER_EL_PROYECTO\",\n  Rproj = TRUE,\n  readme = TRUE\n)\n\n\n(en realidad este es tambien un compendio de investigación)\nAbrí el proyecto en Rstudio:\n\nEste proyecto debe usarse cada vez que se trabaja código del curso ✌️\n\n\n2 Recursos adicionales\n\nIntroducción a Rstudio video\nkaggle: juegos de datos de ejemplo link:\nDatos para classificar personalidad\nR data sets: link"
  },
  {
    "objectID": "estadistica_tradicional_regresion.html",
    "href": "estadistica_tradicional_regresion.html",
    "title": "Modelos estádisticos tradicionales como regresiones",
    "section": "",
    "text": "Entender los abordajes estadísticos tradicionales como regresiones\nAquí veremos las pruebas estadísticas más comunes y mostraremos cómo pueden representarse en el formato de regresión lineal. Esta sección se basa en este artículo. Consúltelo para obtener una descripción más detallada de las alternativas no paramétricas."
  },
  {
    "objectID": "estadistica_tradicional_regresion.html#prueba-de-wilcoxon-para-dos-promedios",
    "href": "estadistica_tradicional_regresion.html#prueba-de-wilcoxon-para-dos-promedios",
    "title": "Modelos estádisticos tradicionales como regresiones",
    "section": "6.1 Prueba de Wilcoxon para dos promedios",
    "text": "6.1 Prueba de Wilcoxon para dos promedios\nTambién conocida como prueba de Mann-Whitney, es la alternativa no paramétrica a la prueba t de dos promedios:\n\n\nCódigo\n# set seed\nset.seed(123)\n\n# number of observations\nn &lt;- 50\ny &lt;- rnorm(n = n, mean = 0.2, sd = 1)\n\n# create data frame\ny_data &lt;- data.frame(y)\n\n\ny\n\n\n [1] -0.3604756 -0.0301775  1.7587083  0.2705084  0.3292877  1.9150650\n [7]  0.6609162 -1.0650612 -0.4868529 -0.2456620  1.4240818  0.5598138\n[13]  0.6007715  0.3106827 -0.3558411  1.9869131  0.6978505 -1.7666172\n[19]  0.9013559 -0.2727914 -0.8678237 -0.0179749 -0.8260044 -0.5288912\n[25] -0.4250393 -1.4866933  1.0377870  0.3533731 -0.9381369  1.4538149\n[31]  0.6264642 -0.0950715  1.0951257  1.0781335  1.0215811  0.8886403\n[37]  0.7539177  0.1380883 -0.1059627 -0.1804710 -0.4947070 -0.0079173\n[43] -1.0653964  2.3689560  1.4079620 -0.9231086 -0.2028848 -0.2666554\n[49]  0.9799651  0.1166309\n\n\nCódigo\n# Wilcoxon / Mann-Whitney U\nwilcx_mod &lt;- wilcox.test(y_data$y)\n\nwilcx_mod\n\n\n\n    Wilcoxon signed rank test with continuity correction\n\ndata:  y_data$y\nV = 797, p-value = 0.12\nalternative hypothesis: true location is not equal to 0\n\n\nCódigo\nsigned_rank &lt;- function(x) sign(x) * rank(abs(x))\n\n# As linear model with our dummy-coded group_y2:\nwicx_lm_mod &lt;- lm(signed_rank(y) ~ 1, data = y_data) # compare to\n\nsummary(wicx_lm_mod)\n\n\n\nCall:\nlm(formula = signed_rank(y) ~ 1, data = y_data)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-53.38 -24.13   0.12  25.37  43.62 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)     6.38       4.09    1.56     0.12\n\nResidual standard error: 28.9 on 49 degrees of freedom\n\n\n\n\n\n\n\n\nmodel\np.value\n\n\n\n\n1 mean wilcoxon\n0.12482\n\n\nwilcoxon_lm\n0.12480"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "",
    "text": "Sistema de Estudios de Posgrado\n\n\nUniversidad de Costa Rica\n\n\nII semestre, 2024\n\n\n\nMarcelo Araya-Salas, PhD\n\n\nEl aprendizaje estadístico (“machine learning”) es una rama de la inteligencia artificial que se enfoca en el desarrollo de algoritmos y modelos que permiten a las computadoras aprender patrones y hacer predicciones para tomar decisiones basadas en datos. En lugar de seguir instrucciones explícitas para realizar una tarea, estos algoritmos identifican patrones en los datos y usan estos patrones para mejorar su desempeño en tareas específicas. El aprendizaje estadístico se utiliza en una amplia variedad de aplicaciones, desde el reconocimiento de voz hasta el análisis de grandes conjuntos de datos y la automatización de procesos industriales. En este curso los estudiantes podrán conocer los fundamentos y las técnicas básicas del aprendizaje estadístico para responder preguntas de investigación en Ciencias Cognoscitivas.\n\nObjetivos\n\nDescribir y explicar los conceptos y métodos principales del aprendizaje estadístico aplicados a las Ciencias Cognoscitivas.\nDiferenciar entre los tipos de aprendizaje computacional: supervisado, no supervisado, semi-supervisado y por reforzamiento\nComprender los fundamentos teóricos y los supuestos de técnicas como la regresión, las redes neuronales, los árboles de decisión y el análisis de conglomerados\nImplementar, en el lenguaje de programación R, las técnicas desarrolladas a lo largo del curso\nSeleccionar la técnica más adecuada en función del problema práctico o pregunta de investigación en las diversas áreas de las Ciencias Cognoscitivas."
  },
  {
    "objectID": "intro_curso.html#qué-es-el-aprendizaje-estadístico",
    "href": "intro_curso.html#qué-es-el-aprendizaje-estadístico",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "¿Qué es el Aprendizaje Estadístico?",
    "text": "¿Qué es el Aprendizaje Estadístico?\n\n\nUtilización de datos para modelar fenómenos, hacer predicciones y tomar decisiones basadas en la información extraída\nCombina teorías estadísticas con algoritmos computacionales"
  },
  {
    "objectID": "intro_curso.html#qué-es-el-aprendizaje-estadístico-1",
    "href": "intro_curso.html#qué-es-el-aprendizaje-estadístico-1",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "¿Qué es el Aprendizaje Estadístico?",
    "text": "¿Qué es el Aprendizaje Estadístico?\n\n\n\n\n\nInteligencia Artificial: hacer tareas que requieren inteligencia humana\nAprendizaje estadístico: uso de algoritmos para analizar datos, aprender de ellos, y hacer predicciones"
  },
  {
    "objectID": "intro_curso.html#qué-es-el-aprendizaje-estadístico-2",
    "href": "intro_curso.html#qué-es-el-aprendizaje-estadístico-2",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "¿Qué es el Aprendizaje Estadístico?",
    "text": "¿Qué es el Aprendizaje Estadístico?\n\n\n\n\n\nInteligencia Artificial: hacer tareas que requieren inteligencia humana\nAprendizaje estadístico: uso de algoritmos para analizar datos, aprender de ellos, y hacer predicciones\nAprendizaje Profundo: uso de redes neuronales profundas para analizar diversos niveles de abstracción en los datos\nCiencia de Datos: técnicas de análisis, procesamiento, y visualización de datos para extraer información/conocimiento de grandes volúmenes de datos"
  },
  {
    "objectID": "intro_curso.html#qué-es-el-aprendizaje-estadístico-3",
    "href": "intro_curso.html#qué-es-el-aprendizaje-estadístico-3",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "¿Qué es el Aprendizaje Estadístico?",
    "text": "¿Qué es el Aprendizaje Estadístico?\n\n\\[ Y = f(X) + E \\]\n\n\n\nY: variable dependiente (se quiere predecir o explicar)\n\n\n\n\nX: variable(s) independiente(s) con información relevante para predecir Y\n\n\n\n\nE: error no reducible"
  },
  {
    "objectID": "intro_curso.html#qué-es-el-aprendizaje-estadístico-4",
    "href": "intro_curso.html#qué-es-el-aprendizaje-estadístico-4",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "¿Qué es el Aprendizaje Estadístico?",
    "text": "¿Qué es el Aprendizaje Estadístico?\n\n\\[ Y = f(X) + E \\]\n\n\n\nsinónimos de Y: variable dependiente, resultado (outcome), etiqueta, objetivo, etc.\n\n\n\n\nsinónimos de X: variable independiente, atributo (feature), dimensión, predictor, entrada (input), etc."
  },
  {
    "objectID": "intro_curso.html#para-que-estimar-fx",
    "href": "intro_curso.html#para-que-estimar-fx",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "¿Para que Estimar f(X)?",
    "text": "¿Para que Estimar f(X)?\n\n\\[ Y = f(X) + E \\]\n\n\nPredicción: predecir valores futuros de Y\nInferencia: establecer una relación causal (i.e. estimar el efecto de un cambio en X sobre el cambio en Y)\n\n\n\n\nAprendizaje estadístico = estimar f(X)"
  },
  {
    "objectID": "intro_curso.html#aplicaciones",
    "href": "intro_curso.html#aplicaciones",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Aplicaciones",
    "text": "Aplicaciones\nOmnipresente en herramientas electrónicas:\n\nDetección de correo spam: busca patrones en el contenido del mensaje, como palabras clave sospechosas y comportamientos de envío\nReconocimeinto facial: analiza las características faciales desde diferentes ángulos y aprenden a reconocer variaciones sutiles en la apariencia de un individuo\nOptimización de Rutas con GPS: usa los patrones de tráfico históricos y en tiempo real para predecir y sugerir las rutas más rápidas o eficientes"
  },
  {
    "objectID": "intro_curso.html#aplicaciones-en-ciencias-cognoscitivas",
    "href": "intro_curso.html#aplicaciones-en-ciencias-cognoscitivas",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Aplicaciones en Ciencias Cognoscitivas",
    "text": "Aplicaciones en Ciencias Cognoscitivas\n\nCrucial para entender cómo procesamos la información, tomamos decisiones y aprendemos. Algunos sub-campos que utilizan estas herramientas:\n\n\n\nNeurociencia Cognitiva: Identificación de patrones en la actividad cerebral relacionados con diferentes funciones cognitivas\nPsicología Experimental: Modelado de comportamiento humano y predicción de respuestas psicológicas\nNeurociencia Computacional: Modelado de la actividad neuronal para simular procesos cerebrales"
  },
  {
    "objectID": "intro_curso.html#section",
    "href": "intro_curso.html#section",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "",
    "text": "Aplicaciones: Memoria\n\n\n\n\nRoediger et al 2001. Factors that determine false recall: A multiple regression analysis\nRegresión multiple para identificar factores que influyen en el recuerdo falso\n\n\n\nRecuerdo verídico (r = -0.43) y la fuerza de la asociación entre items (r = 0.73) influyen\n\n\n\n\n\n\n\n\n\n\n\n\\(Y: recuerdo\\ falso \\sim X: asociacion\\ entre\\ items + recuerdo\\ verídico + ...\\)"
  },
  {
    "objectID": "intro_curso.html#section-1",
    "href": "intro_curso.html#section-1",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "",
    "text": "Aplicaciones: Reconocimiento de Emociones\n\n\n\n\nHema et al 2023. Emotional speech Recognition using CNN and Deep learning techniques\nAprendizaje profundo en el reconocimiento y análisis del tono emocional en la voz\n78% de precision\n\n\n\n\n\n\n\n\n\\(Y: emoción \\sim X: estructura\\ acústica\\)"
  },
  {
    "objectID": "intro_curso.html#section-2",
    "href": "intro_curso.html#section-2",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "",
    "text": "Aplicaciones: Resilencia al Estrés\n\n\n\n\nChen et al. 2023. Identifying the top determinants of psychological resilience among community older adults during COVID-19 in Taiwan: A random forest approach\nFactores que determinan la resiliencia al estrés\n80% de probabilidad de una predición correcta\n\n\n\n\n\n\n\n\n\n\\(Y:resilencia\\ (binaria) \\sim X: género + edad + educación + ...\\)"
  },
  {
    "objectID": "intro_curso.html#tipos-de-modelos",
    "href": "intro_curso.html#tipos-de-modelos",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Tipos de Modelos",
    "text": "Tipos de Modelos\nSupervisado: Se predice una Y conocida a priori\n\\[ Y = f(X) \\]\n\n\n\n\n\nY\nX1\nX2\nX3\n\n\n\n\n-0.56\n1.72\n1.22\n1.79\n\n\n-0.23\n0.46\n0.36\n0.50\n\n\n1.56\n-1.27\n0.40\n-1.97\n\n\n0.07\n-0.69\n0.11\n0.70\n\n\n0.13\n-0.45\n-0.56\n-0.47"
  },
  {
    "objectID": "intro_curso.html#tipos-de-modelos-1",
    "href": "intro_curso.html#tipos-de-modelos-1",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Tipos de Modelos",
    "text": "Tipos de Modelos\nSupervisado: Se predice una Y conocida a priori\n\\[ Y = f(X) \\]\n\n\n\n\n\nY\nX1\nX2\nX3\n\n\n\n\nA\n-0.55\n-1.60\n-0.83\n\n\nC\n-0.02\n0.66\n-0.62\n\n\nB\n-0.58\n-1.87\n-0.29\n\n\nC\n1.07\n0.26\n-0.50\n\n\nA\n1.04\n-0.22\n1.10"
  },
  {
    "objectID": "intro_curso.html#tipos-de-modelos-2",
    "href": "intro_curso.html#tipos-de-modelos-2",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Tipos de Modelos",
    "text": "Tipos de Modelos\nNo supervisado: genera una Y con base en la estructura de X\n\\[ f(X) \\]\n\n\n\n\n\nY\nX1\nX2\nX3\n\n\n\n\n?\n-0.56\n1.72\n1.22\n\n\n?\n-0.23\n0.46\n0.36\n\n\n?\n1.56\n-1.27\n0.40\n\n\n?\n0.07\n-0.69\n0.11\n\n\n?\n0.13\n-0.45\n-0.56"
  },
  {
    "objectID": "intro_curso.html#tipos-de-modelos-3",
    "href": "intro_curso.html#tipos-de-modelos-3",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Tipos de Modelos",
    "text": "Tipos de Modelos\nNo supervisado: ó explora la estructura de X\n\\[ f(X) \\]\n\n\n\n\n\nX1\nX2\nX3\n\n\n\n\n-0.56\n1.72\n1.22\n\n\n-0.23\n0.46\n0.36\n\n\n1.56\n-1.27\n0.40\n\n\n0.07\n-0.69\n0.11\n\n\n0.13\n-0.45\n-0.56"
  },
  {
    "objectID": "intro_curso.html#escogiendo-el-modelo-adecuado",
    "href": "intro_curso.html#escogiendo-el-modelo-adecuado",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Escogiendo el Modelo Adecuado",
    "text": "Escogiendo el Modelo Adecuado\n\n\n¿Existe Y?"
  },
  {
    "objectID": "intro_curso.html#escogiendo-el-modelo-adecuado-1",
    "href": "intro_curso.html#escogiendo-el-modelo-adecuado-1",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Escogiendo el Modelo Adecuado",
    "text": "Escogiendo el Modelo Adecuado\n\n\nSi Y existe ¿Es continua o categórica?"
  },
  {
    "objectID": "intro_curso.html#escogiendo-el-modelo-adecuado-2",
    "href": "intro_curso.html#escogiendo-el-modelo-adecuado-2",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Escogiendo el Modelo Adecuado",
    "text": "Escogiendo el Modelo Adecuado\n\n\nSi Y no existe ¿Queremos generarla o solo explorar X?"
  },
  {
    "objectID": "intro_curso.html#escogiendo-el-modelo-adecuado-3",
    "href": "intro_curso.html#escogiendo-el-modelo-adecuado-3",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Escogiendo el Modelo Adecuado",
    "text": "Escogiendo el Modelo Adecuado"
  },
  {
    "objectID": "intro_curso.html#escogiendo-el-modelo-adecuado-4",
    "href": "intro_curso.html#escogiendo-el-modelo-adecuado-4",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Escogiendo el Modelo Adecuado",
    "text": "Escogiendo el Modelo Adecuado"
  },
  {
    "objectID": "intro_curso.html#escogiendo-el-modelo-adecuado-5",
    "href": "intro_curso.html#escogiendo-el-modelo-adecuado-5",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "Escogiendo el Modelo Adecuado",
    "text": "Escogiendo el Modelo Adecuado\n\nInterpretabilidad\n\n\nTomado de Badillo et al 2020"
  },
  {
    "objectID": "instructor.html",
    "href": "instructor.html",
    "title": "Aprendizaje Estadístico, SEP-UCR 2024",
    "section": "",
    "text": "Marcelo Araya-Salas\n\n\n\n\n\nUn ecólogo del comportamiento mas que acabó haciendo mucha programación solo para poder hacer bien el análisis de datos. Ademas de la investigación, también trabajo en hacer herramientas computacionales para el análisis de datos biológicos (no genéticos), principalmente relacionados con el comportamiento animal y la bioacústica. Soy el desarrollador de los paquetes de R warbleR y Rraven los cuales tienen funciones para agilizar el análisis acústico de sonidos de los animales. Más recientemente, sacamos los paquetes baRulho, para cuantificar la transmisión y la degradación de la señal acústica, ohun, para optimizar la detección automática y PhenotypeSpace para cuantificar los espacios de rasgos multidimensionales. Recientemente también desarrollé el paquete sketchy para organizar compendios de investigación."
  },
  {
    "objectID": "fundamentos_de_r.html",
    "href": "fundamentos_de_r.html",
    "title": "Elementos básicos del lenguaje R",
    "section": "",
    "text": "Familiarizarse con los bloques básicos usados en la programación en R\nConocer las fuentes principales de documentación estandarizada en R"
  },
  {
    "objectID": "fundamentos_de_r.html#section",
    "href": "fundamentos_de_r.html#section",
    "title": "Elementos básicos del lenguaje R",
    "section": "2.1  ",
    "text": "2.1"
  },
  {
    "objectID": "fundamentos_de_r.html#objetos-que-contienen-datos",
    "href": "fundamentos_de_r.html#objetos-que-contienen-datos",
    "title": "Elementos básicos del lenguaje R",
    "section": "3.1 Objetos que contienen datos",
    "text": "3.1 Objetos que contienen datos\nLa estructura de datos básica en R es el vector. Con este se contruyen todas las otras clases de objetos. Para entender las clases es útil pensar en el número de dimensiones (1, 2 o mas) y tipos de datos que pueden contener: homogéneos (un único tipo de elemento) o homogéneos (o múltiples tipos de elementos).\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    D(Objetos de Datos) --&gt; D1(1 dimension)\n    D --&gt; D2(2 dimensiones)\n    D1 --&gt; V(Vector)\n    D1 --&gt; L(Lista)\n    D2 --&gt; M(Matriz)\n    D2 --&gt;  DF(\"Cuadro de Datos &lt;br&gt;(Data Frame)\")\n\n    style D fill:#40498E66, stroke:#000, stroke-width:2px, color:#FFF, width:180px\n    style D1 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style D2 fill:#348AA666, stroke:#000, stroke-width:2px, color:#FFF, width:140px\n    style DF fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style V fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style M fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n    style L fill:#49C1AD66, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHomogéneo\nHeterogéneo\n\n\n\n\n1d\nVector atómico\nLista\n\n\n2d\nMatriz\nCuadro de datos (data frame)\n\n\nnd\narreglo (Array)\n\n\n\n\n\n\n\n\n3.1.1 Objetos de 1 dimensión\nHay dos tipos básicos de vectores: vectores atómicos y listas.\nTienen tres propiedades comunes:\n\nTipo, typeof() (clase/modo ~)\nLongitud, length() (número de elementos)\nAttributes, attributes() (metadatos)\n\nSe diferencian en los tipos de sus elementos: todos los elementos de un vector atómico deben ser del mismo tipo, mientras que los elementos de una lista pueden tener diferentes tipos.\n\n3.1.1.1 Vectores atomicos\nTipos de vectores atómicos:\n\nLógico (booleano)\nEntero\nNumérico (doble)\nCaracteres\nFactores\n\nLos vectores se construyen con la función c(), Pueden ser numérico:\n\n\nCódigo\nx &lt;- 1\nx1 &lt;- c(1)\n\nall.equal(x, x1)\n\n\n[1] TRUE\n\n\nCódigo\nclass(x)\n\n\n[1] \"numeric\"\n\n\nDe caracteres:\n\n\nCódigo\ny &lt;- \"algo\"\n\nclass(y)\n\n\n[1] \"character\"\n\n\nLógico:\n\n\nCódigo\nz &lt;- TRUE\n\nclass(z)\n\n\n[1] \"logical\"\n\n\nO factor:\n\n\nCódigo\nq &lt;- factor(1)\n\nclass(q)\n\n\n[1] \"factor\"\n\n\n \nPor tanto, los números o cadenas individuales son en realidad vectores de longitud uno:\n\n\nCódigo\nclass(1)\n\n\n[1] \"numeric\"\n\n\nCódigo\nclass(\"a\")\n\n\n[1] \"character\"\n\n\nLos vectores sólo pueden contener elementos del mismo tipo. Los tipos diferentes de elementos serán forzados al tipo más flexible:\n\n\nCódigo\nx &lt;- c(1, 2, \"a\")\n\nx\n\n\n[1] \"1\" \"2\" \"a\"\n\n\nCódigo\nclass(x)\n\n\n[1] \"character\"\n\n\n \nLos valores que faltan se especifican con NA, que es un vector lógico de longitud 1. NA siempre será interpretado al tipo correcto si se utiliza dentro de c():\n\n\nCódigo\nv &lt;- c(10, 11, NA)\n\nclass(v)\n\n\n[1] \"numeric\"\n\n\nCódigo\nv &lt;- c(\"a\", \"b\", NA)\n\nclass(v)\n\n\n[1] \"character\"\n\n\n\n\n3.1.1.2 Factores\nLos vectores con factores son muy simulares a los de caracteres. Sin embargo, un factor sólo puede contener valores predefinidos, conocidos como niveles. Los atributos se utilizan para definir los niveles del factor.\nLos factores se construyen sobre vectores enteros utilizando dos atributos:\n\nclase “factor”: hace que se comporten de forma diferente a los vectores de caracteres normales\nniveles: define el conjunto de valores permitidos\n\n\n\nCódigo\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\nx\n\n\n[1] a b b a\nLevels: a b\n\n\nCódigo\nlevels(x)\n\n\n[1] \"a\" \"b\"\n\n\nCódigo\nstr(x)\n\n\n Factor w/ 2 levels \"a\",\"b\": 1 2 2 1\n\n\n \nLos factores parecen vectores de caracteres, pero en realidad son números enteros:\n\n\nCódigo\nx &lt;- factor(c(\"a\", \"b\", \"b\", \"a\"))\n\nc(x)\n\n\n[1] a b b a\nLevels: a b\n\n\n\n\n3.1.1.3 Listas\nPuede contener objetos de diferentes clases y tamaños. Las listas se construyen con list():\n\n\nCódigo\nl &lt;- list(\"a\", 1, FALSE)\n\nl\n\n\n[[1]]\n[1] \"a\"\n\n[[2]]\n[1] 1\n\n[[3]]\n[1] FALSE\n\n\nCódigo\nclass(l)\n\n\n[1] \"list\"\n\n\nCódigo\nstr(l)\n\n\nList of 3\n $ : chr \"a\"\n $ : num 1\n $ : logi FALSE\n\n\nEn realidad pueden ser vistas como cajones donde se pueden poner cualquier otro tipo de objeto:\n\n\nCódigo\nl &lt;- list(c(\"a\", \"b\"), c(1, 2, 3, 4), c(FALSE, TRUE, FALSE))\n\nl\n\n\n[[1]]\n[1] \"a\" \"b\"\n\n[[2]]\n[1] 1 2 3 4\n\n[[3]]\n[1] FALSE  TRUE FALSE\n\n\nCódigo\nstr(l)\n\n\nList of 3\n $ : chr [1:2] \"a\" \"b\"\n $ : num [1:4] 1 2 3 4\n $ : logi [1:3] FALSE TRUE FALSE\n\n\n\n\n\n3.1.2 Objetos de 2 dimensiones\n\n\n3.1.3 Matrices\nTodas los elementos son del mismo tipo:\n\n\nCódigo\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\ndim(m)\n\n\n[1] 2 3\n\n\nCódigo\nm\n\n\n     [,1] [,2] [,3]\n[1,]    1    3   12\n[2,]    2   11   13\n\n\nCódigo\nclass(m)\n\n\n[1] \"matrix\" \"array\" \n\n\nCódigo\nm &lt;- matrix(c(1, 2, 3, 11, 12, \"13\"), nrow = 2)\nm\n\n\n     [,1] [,2] [,3]\n[1,] \"1\"  \"3\"  \"12\"\n[2,] \"2\"  \"11\" \"13\"\n\n\n \n\n\n3.1.4 Cuadros de datos (data frames)\nCaso especial de las listas. Puede contener elementos de diferentes tipos:\n\n\nCódigo\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\ndim(m)\n\n\n[1] 5 3\n\n\nCódigo\nm\n\n\n\n\n\n\nID\nsize\nobserved\n\n\n\n\na\n1\nFALSE\n\n\nb\n2\nTRUE\n\n\nc\n3\nFALSE\n\n\nd\n4\nFALSE\n\n\ne\n5\nFALSE\n\n\n\n\n\n\nCódigo\nclass(m)\n\n\n[1] \"data.frame\"\n\n\nCódigo\nis.data.frame(m)\n\n\n[1] TRUE\n\n\nCódigo\nis.list(m)\n\n\n[1] TRUE\n\n\nCódigo\nstr(m)\n\n\n'data.frame':   5 obs. of  3 variables:\n $ ID      : chr  \"a\" \"b\" \"c\" \"d\" ...\n $ size    : num  1 2 3 4 5\n $ observed: logi  FALSE TRUE FALSE FALSE FALSE\n\n\n \nPero los vectores deben tener la misma longitud:\n\n\nCódigo\nm &lt;-\n  data.frame(\n    ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"),\n    size = c(1, 2, 3, 4, 5, 6),\n    observed = c(FALSE, TRUE, FALSE, FALSE, FALSE)\n  )\n\n\nError in data.frame(ID = c(\"a\", \"b\", \"c\", \"d\", \"e\"), size = c(1, 2, 3, : arguments imply differing number of rows: 5, 6\n\n\n \n\n\n3.1.5 Ejercicio 1\n \n\nCree un vector numérico con 8 elementos que contenga números positivos y negativos\nCree un vector de caracteres con los nombres de las provincias de Costa Rica\nAñada al vector de punto anterior un NA\nCree una matriz numérica con 3 columnas y 3 filas\nCree una matriz de caracteres con 4 columnas y 3 filas\n¿Qué tipo de objeto es ‘iris’ y cuales son sus dimensiones? (pista: iris es un objeto disponible por omisión en su ambiente)\nCree un cuadro de datos (data frame) con una columna numérica, una columna de caracteres y una columna con factores"
  },
  {
    "objectID": "fundamentos_de_r.html#funciones-objetos-que-hacen-tareas",
    "href": "fundamentos_de_r.html#funciones-objetos-que-hacen-tareas",
    "title": "Elementos básicos del lenguaje R",
    "section": "3.2 Funciones: objetos que hacen tareas",
    "text": "3.2 Funciones: objetos que hacen tareas\nTodas las funciones se crean con la función function() y siguen la misma estructura:\n\n* Modified from Grolemund 2014  \n\n3.2.1 Funciones integradas\n\n3.2.1.1 Funciones básicas\nR viene con muchas funciones que puedes usar para hacer tareas sofisticadas:\n\n\nCódigo\n# built in functions\nbi &lt;- builtins(internal = FALSE)\n\nlength(bi)\n\n\n[1] 1388\n\n\n \nAlgunas funciones vienen de forma predeterminada con R básico. Nuevas funciones pueden ser cargadas como parte de paquetes adicionales o incluso creadas por el usuario.\n\n\n\n\n\nflowchart LR\n    classDef largeText font-size:18px, padding:15px;\n\n    F(Funciones) --&gt; BF(Funciones Integradas)\n    BF --&gt; OP(Operadores)\n    BF --&gt; BA(Funciones Básicas)\n    F --&gt; PF(Paquetes)\n    F --&gt; UF(Funciones Definidas por el Usuario)\n\n    class R,D,D1,D2,F largeText;\n\n    style F fill:#357BA266, stroke:#000, stroke-width:2px, color:#FFF, width:120px\n    style BF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n    style BA fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000\n    style OP fill:#DEF5E566, stroke:#000, stroke-width:2px, color:#000    \n    style PF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000000\n    style UF fill:#A0DFB966, stroke:#000, stroke-width:2px, color:#000\n\n\n\n\n\n\n\n\n\n3.2.1.2 Operadores\nLos operadores son funciones:\n\n\nCódigo\n1 + 1\n\n\n[1] 2\n\n\nCódigo\n'+'(1, 1)\n\n\n[1] 2\n\n\nCódigo\n2 * 3\n\n\n[1] 6\n\n\nCódigo\n'*'(2, 3)\n\n\n[1] 6\n\n\n \n\n3.2.1.2.1 Operadores mas utilizados\nOperadores aritméticos:\n\n\n\n\n\n\nOperador\nDescrición\n\n\n\n\n+\nsuma\n\n\n-\nresta\n\n\n*\nmultiplicación\n\n\n/\ndivisión\n\n\n^ or **\nexponente\n\n\n\n\n\n\n\n\n\n\nCódigo\n1 - 2\n\n\n[1] -1\n\n\nCódigo\n1 + 2\n\n\n[1] 3\n\n\nCódigo\n2 ^ 2\n\n\n[1] 4\n\n\nCódigo\n2 ** 2\n\n\n[1] 4\n\n\nCódigo\n2:3 %in% 2:4\n\n\n[1] TRUE TRUE\n\n\n \nOperadores lógicos:\n\n\n\nOperador\nDescrición\n\n\n\n\n&lt;\nmenor que\n\n\n&lt;=\nmenor o igual que\n\n\n&gt;\nmayor que\n\n\n&gt;=\nmayor o igual que\n\n\n==\nexactamente igual que\n\n\n!=\ndiferente que\n\n\n!x\nNo es x\n\n\nx | y\nx O y\n\n\nx & y\nx Y y\n\n\nx %in% y\ncorrespondencia\n\n\n\n\n\nCódigo\n1 &lt; 2 \n\n\n[1] TRUE\n\n\nCódigo\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCódigo\n1 &lt;= 2 \n\n\n[1] TRUE\n\n\nCódigo\n1 == 2\n\n\n[1] FALSE\n\n\nCódigo\n1 != 2\n\n\n[1] TRUE\n\n\nCódigo\n1 &gt; 2 \n\n\n[1] FALSE\n\n\nCódigo\n5 %in% 1:6\n\n\n[1] TRUE\n\n\nCódigo\n5 %in% 1:4\n\n\n[1] FALSE\n\n\n \n\n\n\n\n3.2.2 Vectorización\nLa mayoría de las funciones están vectorizadas:\n\n\nCódigo\n1:6 * 1:6\n\n\n\n* Modified from Grolemund & Wickham 2017\n \n\n\n[1]  1  4  9 16 25 36\n\n\n\n\nCódigo\n1:6 - 1:6\n\n\n[1] 0 0 0 0 0 0\n\n\nR recicla vectores de longitud desigual:\n\n\nCódigo\n1:6 * 1:5\n\n\n\n* Modified from Grolemund & Wickham 2017\n\n \n\n3.2.3 Funciones de paquetes adicionales\nEstas son funciones que son incluidas en paquetes adicionales que se pueden instalar y cargar en R. Para ser utilizadas el paquete debe ser instalado y cargado.Por ejemplo para usar la función corTest del paquete “psych” primero debemos instalar. Los paquetes son instalados del servidor de CRAN (Comprehensive R Archive Network) con la función install.packages():\n\n\nCódigo\ninstall.packages(\"psych\")\n\n\n.. y cargar el paquete:\n\n\nCódigo\nlibrary(psych)\n\n\nUna vez instalado y cargado ‘psych’, podemos llamar a la función corTest:\n\n\nCódigo\ncorTest(iris$Sepal.Length, iris$Sepal.Width)\n\n\nCall:corTest(x = iris$Sepal.Length, y = iris$Sepal.Width)\nCorrelation matrix \n[1] -0.12\nSample Size \n[1] 150\nThese are the unadjusted probability values.\n  The probability values  adjusted for multiple tests are in the p.adj object. \n[1] 0.15\n\n To see confidence intervals of the correlations, print with the short=FALSE option\n\n\nEl uso de paquetes externos es la caracteristica mas util de R ya que permite hacer uso de un número casi infinito de funciones especializadas en diferentes tareas así como de campos muy diversos de la ciencia y la industria.\nPodemos explorar los paquetes disponibles para R en la página de CRAN (hacer click en el enlace “packages”).\n\n\n3.2.4 Ejercicio 2\n \n\nBusque un paquete que le interese en CRAN\nInstale el paquete y carguelo\nCorra el codigo de ejemplo de una de sus funciones"
  },
  {
    "objectID": "fundamentos_de_r.html#extraer-subconjuntos-usando-indexación-indexing",
    "href": "fundamentos_de_r.html#extraer-subconjuntos-usando-indexación-indexing",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.1 Extraer subconjuntos usando indexación (indexing)",
    "text": "4.1 Extraer subconjuntos usando indexación (indexing)\nLos elementos dentro de los objetos pueden ser llamados por medio de la indexación. Para sub-conjuntar un vector simplemente llame a la posición del objeto usando corchetes:\n\n\nCódigo\nx &lt;- c(1, 3, 4, 10, 15, 20, 50, 1, 6)\n\nx[1]\n\n\n[1] 1\n\n\nCódigo\nx[2]\n\n\n[1] 3\n\n\nCódigo\nx[2:3]\n\n\n[1] 3 4\n\n\nCódigo\nx[c(1,3)]\n\n\n[1] 1 4\n\n\n \nLos elementos se pueden eliminar de la misma manera:\n\n\nCódigo\nx[-1]\n\n\n[1]  3  4 10 15 20 50  1  6\n\n\nCódigo\nx[-c(1,3)]\n\n\n[1]  3 10 15 20 50  1  6\n\n\n \nLas matrices y los marcos de datos requieren 2 índices [fila, columna]:\n\n\nCódigo\nm &lt;- matrix(c(1, 2, 3, 11, 12, 13), nrow = 2)\n\nm[1, ]\n\n\n[1]  1  3 12\n\n\nCódigo\nm[, 1]\n\n\n[1] 1 2\n\n\nCódigo\nm[1, 1]\n\n\n[1] 1\n\n\nCódigo\nm[-1, ]\n\n\n[1]  2 11 13\n\n\nCódigo\nm[, -1]\n\n\n     [,1] [,2]\n[1,]    3   12\n[2,]   11   13\n\n\nCódigo\nm[-1, -1]\n\n\n[1] 11 13\n\n\nCódigo\ndf &lt;- data.frame(\n  provincia = c(\"San José\", \"Guanacaste\", \"Guanacaste\"), \n  canton = c(\"Montes de Oca\", \"Nicoya\", \"Liberia\"), \n    distrito = c(\"San Rafael\", \"Nosara\", \"Nacascolo\")\n  )\n\ndf\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[1, ]\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\n\n\n\n\nCódigo\ndf[, 1]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCódigo\ndf[1, 1]\n\n\n[1] \"San José\"\n\n\nCódigo\ndf[-1, ]\n\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\n2\nGuanacaste\nNicoya\nNosara\n\n\n3\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[, -1]\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\nMontes de Oca\nSan Rafael\n\n\nNicoya\nNosara\n\n\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[-1, -1]\n\n\n\n\n\n\n\ncanton\ndistrito\n\n\n\n\n2\nNicoya\nNosara\n\n\n3\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ndf[,\"provincia\"]\n\n\n[1] \"San José\"   \"Guanacaste\" \"Guanacaste\"\n\n\nCódigo\ndf[,c(\"provincia\", \"canton\")]\n\n\n\n\n\n\nprovincia\ncanton\n\n\n\n\nSan José\nMontes de Oca\n\n\nGuanacaste\nNicoya\n\n\nGuanacaste\nLiberia\n\n\n\n\n\n\n \nLas listas requieren 1 índice entre dobles corchetes [[índice]]:\n\n\nCódigo\nl &lt;- list(c(\"a\", \"b\"),\n          c(1, 2, 3),\n          c(FALSE, TRUE, FALSE, FALSE))\n\nl[[1]]\n\n\n[1] \"a\" \"b\"\n\n\nCódigo\nl[[3]]\n\n\n[1] FALSE  TRUE FALSE FALSE\n\n\n \nLos elementos dentro de las listas también pueden ser subconjuntos en la misma cadena de código:\n\n\nCódigo\nl[[1]][1:2]\n\n\n[1] \"a\" \"b\"\n\n\nCódigo\nl[[3]][2]\n\n\n[1] TRUE"
  },
  {
    "objectID": "fundamentos_de_r.html#explorar-objectos",
    "href": "fundamentos_de_r.html#explorar-objectos",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.2 Explorar objectos",
    "text": "4.2 Explorar objectos\nLas siguientes funciones de R básico (predeterminadas) nos pueden ayudar a explorar la estructura de los objetos:\n\n\nCódigo\nstr(df)\n\n\n'data.frame':   3 obs. of  3 variables:\n $ provincia: chr  \"San José\" \"Guanacaste\" \"Guanacaste\"\n $ canton   : chr  \"Montes de Oca\" \"Nicoya\" \"Liberia\"\n $ distrito : chr  \"San Rafael\" \"Nosara\" \"Nacascolo\"\n\n\nCódigo\nnames(df)\n\n\n[1] \"provincia\" \"canton\"    \"distrito\" \n\n\nCódigo\ndim(df)\n\n\n[1] 3 3\n\n\nCódigo\nnrow(df)\n\n\n[1] 3\n\n\nCódigo\nncol(df)\n\n\n[1] 3\n\n\nCódigo\nhead(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ntail(df)\n\n\n\n\n\n\nprovincia\ncanton\ndistrito\n\n\n\n\nSan José\nMontes de Oca\nSan Rafael\n\n\nGuanacaste\nNicoya\nNosara\n\n\nGuanacaste\nLiberia\nNacascolo\n\n\n\n\n\n\nCódigo\ntable(df$provincia)\n\n\n\nGuanacaste   San José \n         2          1 \n\n\nCódigo\nclass(df)\n\n\n[1] \"data.frame\"\n\n\n\n\nCódigo\nView(df)"
  },
  {
    "objectID": "fundamentos_de_r.html#ejercicio-3",
    "href": "fundamentos_de_r.html#ejercicio-3",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.3 Ejercicio 3",
    "text": "4.3 Ejercicio 3\n \n\nUtilice los datos de ejemplo iris para crear un subconjunto de datos con sólo las observaciones de la especie setosa\nAhora cree un subconjunto de datos que contenga las observaciones tanto de “setosa” como de “versicolor”\nTambién con iris cree un subconjunto de datos con las observaciones para las que iris$Sepal.length es mayor que 6\n¿Cuántas observaciones tienen una longitud de sépalo superior a 6?"
  },
  {
    "objectID": "fundamentos_de_r.html#section-1",
    "href": "fundamentos_de_r.html#section-1",
    "title": "Elementos básicos del lenguaje R",
    "section": "4.4  ",
    "text": "4.4"
  },
  {
    "objectID": "fundamentos_de_r.html#nombres-de-archivos",
    "href": "fundamentos_de_r.html#nombres-de-archivos",
    "title": "Elementos básicos del lenguaje R",
    "section": "5.1 Nombres de archivos",
    "text": "5.1 Nombres de archivos\nLos nombres de los archivos deben terminar en .R y, por supuesto, ser auto-explicatorios:\n\nBien: graficar_probabilidad_posterior.R\nMal: graf.R"
  },
  {
    "objectID": "fundamentos_de_r.html#nombres-de-objetos",
    "href": "fundamentos_de_r.html#nombres-de-objetos",
    "title": "Elementos básicos del lenguaje R",
    "section": "5.2 Nombres de objetos",
    "text": "5.2 Nombres de objetos\nVariables y funciones:\n\nMinúsculas\nUtilice un guión bajo\nEn general, nombres para las variables y verbos para las funciones\nProcure que los nombres sean concisos y significativos (no siempre es fácil)\nAvoid using names of existing functions of variables\n\n\n\nCódigo\n  - Bien: dia_uno: dia_1, peso_promedio(),\n  \n  - Mal: diauno, dia1, primer.dia_delmes"
  },
  {
    "objectID": "fundamentos_de_r.html#syntaxis",
    "href": "fundamentos_de_r.html#syntaxis",
    "title": "Elementos básicos del lenguaje R",
    "section": "5.3 Syntaxis",
    "text": "5.3 Syntaxis\n\n5.3.1 Espacios\n\nUtilice espacios alrededor de los operadores y para los argumentos dentro de una función\nPonga siempre un espacio después de una coma, y nunca antes (como en el inglés normal)\nColoque un espacio antes del paréntesis izquierdo, excepto en una llamada a una función\n\n\n\nCódigo\n  - Bien: \n          a &lt;- rnorm(n = 10, sd = 10, mean = 1)\n          total &lt;- sum(x[1, ])\n\n  - Mal: \n         a&lt;-rnorm(n=10,sd=10,mean=1) \n         total &lt;- sum(x[,1])  \n\n\n \n\n5.3.1.1 Corchetes\n\nLa llave de apertura nunca debe ir en su propia línea\nLa llave de cierre debe ir siempre en su propia línea\nPuede omitir las llaves cuando un bloque consiste en una sola declaración\n\n\n\nCódigo\n  - Bien:\n              if (is.null(ylim)) {\n              ylim &lt;- c(0, 0.06)\n            }\n                      \n            if (is.null(ylim))\n              ylim &lt;- c(0, 0.06)\n          \n  - Mal:\n            \n         if (is.null(ylim)) ylim &lt;- c(0, 0.06)\n                    \n         if (is.null(ylim)) {ylim &lt;- c(0, 0.06)} \n\n         if (is.null(ylim)) {\n           ylim &lt;- c(0, 0.06)\n           } \n\n\n \n\n\n5.3.1.2 Crear objetos\n\nUse &lt;-, no =\n\n\n\nCódigo\n  - GOOD:\n         x &lt;- 5 \n          \n  - BAD:\n         x = 5\n\n\n \n\n\n5.3.1.3 Sugerencias para añadir comentarios\n\nComente su código\nLas líneas enteras comentadas deben comenzar con # y un espacio\nLos comentarios cortos pueden colocarse después del código precedido por dos espacios, #, y luego un espacio\n\n\n\nCódigo\n# Create histogram of frequency of campaigns by pct budget spent.\nhist(df$pct.spent,\n     breaks = \"scott\",  # method for choosing number of buckets\n     main   = \"Histograma: individuos por unidad de tiempo\",\n     xlab   = \"Número de individuos\",\n     ylab   = \"Frecuencia\")\n\n\n \n\n\n5.3.1.4 Disposición general y ordenación (estilo de google)\n\nComentario de la declaración de derechos de autor (?)\nComentario del autor\nComentario de la descripción del archivo, incluyendo el propósito del programa, las entradas y las salidas\ndeclaraciones source() y library()\nDefiniciones de funciones\nSentencias ejecutadas, si procede (por ejemplo, print, plot)"
  },
  {
    "objectID": "fundamentos_de_r.html#package-documentation",
    "href": "fundamentos_de_r.html#package-documentation",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.1 Package documentation",
    "text": "6.1 Package documentation\n\n \nReference manuals\nLos manuales de referencia son colecciones de la documentación de todas las funciones de un paquete (sólo 1 por paquete):\n\nmanual de dynaSpec\nmanual de baRulho"
  },
  {
    "objectID": "fundamentos_de_r.html#documentación-de-las-funciones",
    "href": "fundamentos_de_r.html#documentación-de-las-funciones",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.2 Documentación de las funciones",
    "text": "6.2 Documentación de las funciones\nTodas las funciones (por defecto o de paquetes cargados) deben tener una documentación que siga un formato estándar:\n\n\nCódigo\n?mean\n\nhelp(\"mean\")\n\n\n\nEsta documentación también puede mostrarse en Rstudio pulsando F1 cuando el cursor está en el nombre de la función\n \nSi no recuerda el nombre de la función pruebe con apropos():\n\n\nCódigo\napropos(\"mean\")\n\n\n [1] \".colMeans\"      \".rowMeans\"      \"circadian.mean\" \"circular.mean\" \n [5] \"colMeans\"       \"geometric.mean\" \"harmonic.mean\"  \"kmeans\"        \n [9] \"mean\"           \"mean.Date\"      \"mean.default\"   \"mean.difftime\" \n[13] \"mean.POSIXct\"   \"mean.POSIXlt\"   \"rowMeans\"       \"weighted.mean\" \n[17] \"winsor.mean\"    \"winsor.means\""
  },
  {
    "objectID": "fundamentos_de_r.html#viñetas-vignettes",
    "href": "fundamentos_de_r.html#viñetas-vignettes",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.3 Viñetas (vignettes)",
    "text": "6.3 Viñetas (vignettes)\nLas viñetas son documentos ilustrativos o casos de estudio que detallan el uso de un paquete (opcional, pueden ser varios por paquete).\nLas viñetas se pueden llamar directamente desde R:\n\n\nCódigo\nvgn &lt;- browseVignettes() \n\n\n\n\nCódigo\nvignette()\n\n\nTambién deberían aparecer en la página del paquete en CRAN."
  },
  {
    "objectID": "fundamentos_de_r.html#demonstraciones",
    "href": "fundamentos_de_r.html#demonstraciones",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.4 Demonstraciones",
    "text": "6.4 Demonstraciones\nLos paquetes también pueden incluir demostraciones de código extendidas (“demos”). Para listar las demos de un paquete ejecute demo(\"nombre del paquete\"):\n\n\nCódigo\ndemo(package=\"stats\")\n\n# call demo directly\ndemo(\"nlm\")"
  },
  {
    "objectID": "fundamentos_de_r.html#ejercicio-4",
    "href": "fundamentos_de_r.html#ejercicio-4",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.5 Ejercicio 4",
    "text": "6.5 Ejercicio 4\n \n\n¿Qué hace la función cut()?\n¿Para qué se utiliza el argumento breaks en cut()?\nEjecuta las 4 primeras líneas de código de los ejemplos proporcionados en la documentación de cut().\n¿Cuántas viñetas tiene el paquete warbleR?"
  },
  {
    "objectID": "fundamentos_de_r.html#referencias",
    "href": "fundamentos_de_r.html#referencias",
    "title": "Elementos básicos del lenguaje R",
    "section": "6.6 Referencias",
    "text": "6.6 Referencias\n\nAdvanced R, H Wickham\nGoogle’s R Style Guide\n\nHands-On Programming with R (Grolemund, 2014)\n\n\nInformación de la sesión\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] psych_2.3.12\n\nloaded via a namespace (and not attached):\n [1] vctrs_0.6.5       nlme_3.1-155      svglite_2.1.3     cli_3.6.3        \n [5] knitr_1.48        rlang_1.1.4       xfun_0.47         stringi_1.8.4    \n [9] highr_0.11        jsonlite_1.8.8    glue_1.7.0        colorspace_2.1-0 \n[13] htmltools_0.5.8.1 scales_1.3.0      rmarkdown_2.27    grid_4.3.2       \n[17] evaluate_0.24.0   munsell_0.5.1     kableExtra_1.4.0  fastmap_1.2.0    \n[21] yaml_2.3.10       lifecycle_1.0.4   stringr_1.5.1     compiler_4.3.2   \n[25] htmlwidgets_1.6.4 rstudioapi_0.16.0 lattice_0.20-45   systemfonts_1.1.0\n[29] digest_0.6.37     viridisLite_0.4.2 R6_2.5.1          parallel_4.3.2   \n[33] mnormt_2.1.1      magrittr_2.0.3    tools_4.3.2       xml2_1.3.6"
  },
  {
    "objectID": "como_simular_datos.html",
    "href": "como_simular_datos.html",
    "title": "Simulación de datos",
    "section": "",
    "text": "Paquetes a utilizar en este manual:\nCódigo\n# instalar/cargar paquetes\n\nsketchy::load_packages(\n  c(\"ggplot2\", \n    \"viridis\"\n    )\n  )"
  },
  {
    "objectID": "como_simular_datos.html#generación-de-números-aleatorios-en-r",
    "href": "como_simular_datos.html#generación-de-números-aleatorios-en-r",
    "title": "Simulación de datos",
    "section": "1.1 Generación de números aleatorios en R",
    "text": "1.1 Generación de números aleatorios en R\nLa estadística nos permite inferir patrones en los datos. Solemos utilizar conjuntos de datos reales para enseñar estadística. Sin embargo, puede ser circular entender el funcionamiento interno de una herramienta estadística probando su capacidad para inferir un patrón que no estamos seguros de encontrar en los datos (y no tenemos idea del mecanismo que produjo ese patrón). Las simulaciones nos permiten crear escenarios controlados en los que conocemos con seguridad los patrones presentes en los datos y los procesos subyacentes que los han generado.\nR ofrece algunas funciones básicas para la simulación de datos. Las más utilizadas son las funciones generadoras de números aleatorios. Los nombres de estas funciones comienzan con r (r____()). Por ejemplo, runif():\n\n\nCódigo\n# simular variable uniforme\nunif_var &lt;- runif(n = 100, min = 0, max = 10)\n\n\n \nEl resultado es un vector numérico de longitud 100 (n = 100):\n\n\nCódigo\n# imprimir variable\nunif_var\n\n\n  [1] 9.889093 3.977455 1.156978 0.697487 2.437494 7.920104 3.400624 9.720625\n  [9] 1.658555 4.591037 1.717481 2.314771 7.728119 0.963015 4.534478 0.847007\n [17] 5.606659 0.087046 9.857371 3.165848 6.394489 2.952232 9.967037 9.060213\n [25] 9.887391 0.656457 6.270388 4.904750 9.710244 3.622208 6.799935 2.637199\n [33] 1.857143 1.851432 3.792967 8.470244 4.980761 7.905856 8.384639 4.569039\n [41] 7.994758 3.819431 7.597012 4.367756 9.042177 3.195349 0.825691 8.162891\n [49] 8.984762 9.664964 5.730689 7.200795 7.740586 6.277608 7.229893 3.868313\n [57] 1.627908 1.872283 3.912495 2.739012 1.919177 5.043918 7.638404 6.936689\n [65] 5.440542 6.590872 4.687284 4.818055 3.370636 4.245263 2.870151 6.011915\n [73] 8.407423 6.208370 1.345516 5.677224 4.434263 4.379754 6.236172 9.326533\n [81] 8.884926 8.785406 2.421769 7.414538 3.876563 0.789517 0.948356 7.621427\n [89] 3.478940 4.167667 3.440162 0.084109 9.115750 1.822054 7.228034 5.719633\n [97] 5.400364 3.549474 8.240918 1.861368\n\n\n \nPodemos explorar el resultado graficando un histograma:\n\n\nCódigo\n# crear histograma\nggplot(data = data.frame(unif_var), mapping = aes(x = unif_var)) + geom_histogram()\n\n\n\n\n\n\n\n\n\n \nMuestra una distribución uniforme que va de 0 a 10.\nTambién podemos simular números aleatorios procedentes de una distribución normal utilizando rnorm():\n\n\nCódigo\n# crear una variable normal\nnorm_var &lt;- rnorm(n = 1000, mean = 2, sd = 1)\n\n# graficar histograma\nggplot(data = data.frame(norm_var), mapping = aes(x = norm_var)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n \nTenga en cuenta que todas las funciones generadoras de números aleatorios tienen el argumento ‘n’, que determina la longitud del vector generado (es decir, el número de números aleatorios), además de algunos argumentos adicionales relacionados con parámetros específicos de la distribución.\nLas variables continuas (es decir, los vectores numéricos) pueden convertirse en variables discretas (es decir, números enteros) simplemente redondeándolas:\n\n\nCódigo\nv1 &lt;- rnorm(n = 5, mean = 10, sd = 3)\n\nv1\n\n\n[1] 15.4269  8.5450 15.1387  8.9203  9.3693\n\n\nCódigo\nround(x = v1, digits = 0)\n\n\n[1] 15  9 15  9  9\n\n\n \n\nEjercicio 1\n\n¿Qué hacen las funciones rbinom() y rexp()?\nEjecútela y haga histogramas de sus resultados\n¿Qué hacen los argumentos ‘mean’ y ‘sd’ en rnorm()? Juegue con diferentes valores y comprueba el histograma para hacerse una idea de su efecto en la simulación"
  },
  {
    "objectID": "como_simular_datos.html#generación-de-variables-categóricas",
    "href": "como_simular_datos.html#generación-de-variables-categóricas",
    "title": "Simulación de datos",
    "section": "1.2 Generación de variables categóricas",
    "text": "1.2 Generación de variables categóricas\nLa forma más sencilla de generar variables categóricas es utilizar el vector de ejemplo letters' (oLETTERS’) para asignar niveles de categoría. Podemos hacerlo utilizando la función rep(). Por ejemplo, el siguiente código crea un vector categórico (caracteres) con dos niveles, cada uno con 4 observaciones:\n\n\nCódigo\nrep(letters[1:2], each = 4)\n\n\n[1] \"a\" \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"b\"\n\n\n \nTambién podemos replicar este patrón utilizando el argumento ‘times’. Este código replica el vector anterior 2 veces:\n\n\nCódigo\nrep(letters[1:2], each = 4, times = 2)\n\n\n [1] \"a\" \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"b\" \"a\" \"a\" \"a\" \"a\" \"b\" \"b\" \"b\" \"b\"\n\n\n \nOtra opción es simular una variable a partir de una distribución binomial y luego convertirla en un factor:\n\n\nCódigo\n# correr rbinom\nbinom_var &lt;- rbinom(n = 50, size = 1, prob = 0.5)\n\nbinom_var\n\n\n [1] 1 0 0 1 1 0 0 0 0 0 0 0 1 1 1 0 0 1 0 1 0 0 0 0 0 0 0 1 0 1 1 1 0 0 0 1 0 0\n[39] 1 1 0 0 0 0 0 1 0 1 1 1\n\n\n\n\nCódigo\n# convertir a factor\ncateg_var &lt;- factor(binom_var, labels = c(\"a\", \"b\"))\n\ncateg_var\n\n\n [1] b a a b b a a a a a a a b b b a a b a b a a a a a a a b a b b b a a a b a a\n[39] b b a a a a a b a b b b\nLevels: a b"
  },
  {
    "objectID": "como_simular_datos.html#muestreo-aleatorio",
    "href": "como_simular_datos.html#muestreo-aleatorio",
    "title": "Simulación de datos",
    "section": "1.3 Muestreo aleatorio",
    "text": "1.3 Muestreo aleatorio\nLa otra herramienta importante de R para jugar con datos simulados es sample(). Esta función permite tomar muestras de tamaños específicos de vectores. Por ejemplo, tomemos el ejemplo del vector ‘letters’:\n\n\nCódigo\nletters\n\n\n [1] \"a\" \"b\" \"c\" \"d\" \"e\" \"f\" \"g\" \"h\" \"i\" \"j\" \"k\" \"l\" \"m\" \"n\" \"o\" \"p\" \"q\" \"r\" \"s\"\n[20] \"t\" \"u\" \"v\" \"w\" \"x\" \"y\" \"z\"\n\n\n \nPodemos tomar una muestra de este vector como es:\n\n\nCódigo\n# tomar muestra\nsample(x = letters, size = 10)\n\n\n [1] \"i\" \"r\" \"q\" \"a\" \"c\" \"m\" \"y\" \"z\" \"u\" \"v\"\n\n\n \nEl argumento ‘size’ nos permite determinar el tamaño de la muestra. Tenga en cuenta que obtendremos un error si el tamaño es mayor que el propio vector:\n\n\nCódigo\nsample(x = letters, size = 30)\n\n\nError in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when 'replace = FALSE'\n\n\n \nEsto sólo puede hacerse cuando el muestreo es con reemplazo (replacement). El muestreo con reemplazo puede aplicarse estableciendo el argumento replace = TRUE:\n\n\nCódigo\nsample(x = letters, size = 30, replace = TRUE)\n\n\n [1] \"j\" \"i\" \"h\" \"i\" \"k\" \"u\" \"n\" \"i\" \"w\" \"k\" \"c\" \"t\" \"m\" \"p\" \"i\" \"h\" \"d\" \"w\" \"c\"\n[20] \"q\" \"j\" \"e\" \"e\" \"j\" \"k\" \"c\" \"l\" \"t\" \"r\" \"h\""
  },
  {
    "objectID": "como_simular_datos.html#iterar-un-proceso",
    "href": "como_simular_datos.html#iterar-un-proceso",
    "title": "Simulación de datos",
    "section": "1.4 Iterar un proceso",
    "text": "1.4 Iterar un proceso\nA menudo, las simulaciones deben repetirse varias veces para descartar resultados espurios debidos al azar o simplemente para probar diferentes parámetros. Las funciones de simulación de datos mencionadas anteriormente pueden ejecutarse varias veces (por ejemplo, iteradas) utilizando la función replicate():\n\n\nCódigo\n# replicar\nrepl_rnorm &lt;- replicate(n = 3, expr = rnorm(2), simplify = FALSE)\n\n# ver clase\nclass(repl_rnorm)\n\n\n[1] \"list\"\n\n\nCódigo\n# imprimir\nrepl_rnorm\n\n\n[[1]]\n[1]  1.19184 -0.33992\n\n[[2]]\n[1]  0.78911 -0.63213\n\n[[3]]\n[1] -1.49312 -0.13441"
  },
  {
    "objectID": "como_simular_datos.html#hacer-que-las-simulaciones-sean-reproducibles",
    "href": "como_simular_datos.html#hacer-que-las-simulaciones-sean-reproducibles",
    "title": "Simulación de datos",
    "section": "1.5 Hacer que las simulaciones sean reproducibles",
    "text": "1.5 Hacer que las simulaciones sean reproducibles\nEl último truco que necesitamos para ejecutar simulaciones en R es la capacidad de reproducir una simulación (es decir, obtener exactamente los mismos datos y resultados simulados). Esto puede ser útil para que otros investigadores puedan ejecutar nuestros análisis exactamente de la misma manera. Esto puede hacerse fácilmente con la función set.seed(). Pruebe a ejecutar el siguiente código. Debería obtener la misma salida:\n\n\nCódigo\n# definir semilla\nset.seed(10)\n\n# crear variable uniforme\nrunif(n = 2)\n\n\n[1] 0.50748 0.30677"
  },
  {
    "objectID": "como_simular_datos.html#juegos-de-datos-con-variables-numéricas-y-categóricas",
    "href": "como_simular_datos.html#juegos-de-datos-con-variables-numéricas-y-categóricas",
    "title": "Simulación de datos",
    "section": "2.1 Juegos de datos con variables numéricas y categóricas",
    "text": "2.1 Juegos de datos con variables numéricas y categóricas\nAhora que sabemos cómo simular variables continuas y categóricas. Podemos juntarlas para crear conjuntos de datos simulados. Esto se puede hacer utilizando la función data.frame():\n\n\nCódigo\n# crear variable categorica\ngrupo &lt;- rep(letters[1:2], each = 3)\n\n# crear variable continuaa\nsize &lt;- rnorm(n = 6, mean = 5, sd = 1)\n\n# poner juntas en un data frame\ndf &lt;- data.frame(grupo, size)\n\n# imprimir\ndf\n\n\n\n\n\n\ngrupo\nsize\n\n\n\n\na\n4.8158\n\n\na\n3.6287\n\n\na\n4.4008\n\n\nb\n5.2946\n\n\nb\n5.3898\n\n\nb\n3.7919\n\n\n\n\n\n\nPor supuesto, podríamos añadir más variables a este cuadro de datos:\n\n\nCódigo\n# crear variable categorica\ngrupo &lt;- rep(letters[1:2], each = 3)\nindividuo &lt;- rep(LETTERS[1:6])\n\n# crear variables continuas\nsize &lt;- rnorm(n = 6, mean = 5, sd = 1)\nweight &lt;- rnorm(n = 6, mean = 100, sd = 10)\n\n# poner todo en un data frame\ndf &lt;- data.frame(grupo, individuo, size, weight)\n\n# imprimir\ndf\n\n\n\n\n\n\ngrupo\nindividuo\nsize\nweight\n\n\n\n\na\nA\n4.6363\n109.874\n\n\na\nB\n3.3733\n107.414\n\n\na\nC\n4.7435\n100.893\n\n\nb\nD\n6.1018\n90.451\n\n\nb\nE\n5.7558\n98.049\n\n\nb\nF\n4.7618\n109.255\n\n\n\n\n\n\nY eso es un juego de datos simulados en su forma más básica. Se parece mucho al tipo de datos con los que trabajamos en biología."
  },
  {
    "objectID": "como_simular_datos.html#prueba-de-concepto-el-teorema-del-límite-central",
    "href": "como_simular_datos.html#prueba-de-concepto-el-teorema-del-límite-central",
    "title": "Simulación de datos",
    "section": "3.1 Prueba de concepto: el Teorema del Límite Central",
    "text": "3.1 Prueba de concepto: el Teorema del Límite Central\nEl Teorema del Límite Central afirma que, si tomamos muestras aleatorias de una población, los promedios de esas muestras seguirán una distribución normal, aunque la población no esté distribuida normalmente. Además, la distribución normal resultante debe tener un promedio cercano al promedio de la población. El teorema es un concepto clave para la estadística inferencial, ya que implica que los métodos estadísticos que funcionan para las distribuciones normales pueden ser aplicables a muchos problemas que implican otros tipos de distribuciones. No obstante, el objetivo aquí es sólo mostrar cómo se pueden utilizar las simulaciones para entender el comportamiento de los métodos estadísticos.\nPara comprobar si esas afirmaciones básicas sobre el Teorema del Límite Central son ciertas, podemos utilizar datos simulados en R. Vamos a simular una población de 1000 observaciones con una distribución uniforme:\n\n\nCódigo\n# simular popublacion uniforme\nunif_pop &lt;- runif(1000, min = 0, max = 10)\n\n# ver histograma\nggplot(data = data.frame(unif_pop), mapping = aes(x = unif_pop)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n \nPodemos tomar muestras aleatorias usando sample() así:\n\n\nCódigo\nsample(x = unif_pop, size = 30)\n\n\n [1] 9.28420 1.02626 2.57517 3.32485 6.89990 2.29404 0.33737 8.21366 3.30364\n[10] 8.03793 2.59174 7.81770 5.65426 0.63831 2.83470 4.20434 4.76330 4.42193\n[19] 6.97830 7.92625 0.68121 3.52323 6.51103 5.38289 7.97210 1.80062 4.21282\n[28] 3.33866 8.91223 4.71163\n\n\n \nEste proceso puede ser replicado varias veces con replicate():\n\n\nCódigo\n# replicar\nsamples &lt;- replicate(n = 100, expr = mean(sample(x = unif_pop, size = 30)))\n\n\n \nEl código anterior toma 100 muestras con 30 valores cada una. Ahora podemos comprobar la distribución de las muestras:\n\n\nCódigo\n# ver distribucion/ histograma\nggplot(data = data.frame(samples), mapping = aes(x = samples)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n \n… asi como el promedio:\n\n\nCódigo\nmean(samples)\n\n\n[1] 5.0212\n\n\n \nComo era de esperar, las muestras siguen una distribución normal con una media cercana a la media de la población, que es:\n\n\nCódigo\nmean(unif_pop)\n\n\n[1] 5.0527\n\n\n \nProbemos con una distribución más compleja. Por ejemplo, una distribución bimodal:\n\n\nCódigo\n# usar semilla\nset.seed(123)\n\n# simular variables\nnorm1 &lt;- rnorm(n = 1000, mean = 10, sd = 3)\nnorm2 &lt;- rnorm(n = 1000, mean = 20, sd = 3)\n\n# juntar en una sola variable\nbimod_pop &lt;- c(norm1, norm2)\n\n# ver histograma\nggplot(data = data.frame(bimod_pop), mapping = aes(x = bimod_pop)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# replicar muestreo\nsamples &lt;- replicate(200, mean(sample(bimod_pop, 10)))\n\n# ver histograma\nggplot(data = data.frame(samples), mapping = aes(x = samples)) + geom_histogram() \n\n\n\n\n\n\n\n\n\n\n\n\n\nCódigo\n# ver promedios\nmean(samples)\n\n\n[1] 15.231\n\n\nCódigo\nmean(bimod_pop)\n\n\n[1] 15.088\n\n\n \n\nEjercicio 2\n \n\nIntenta explorar el Teorema del Límite Central como en el caso anterior, pero esta vez utilizando:\n\nUna distribución exponencial (rexp())\nUna distribución log-normal (rlnorm())\n\n\n \n\nPara cada distribución: grafique un histograma y compare los promedios de la población y de las muestras"
  },
  {
    "objectID": "como_simular_datos.html#referencias",
    "href": "como_simular_datos.html#referencias",
    "title": "Simulación de datos",
    "section": "3.2 Referencias",
    "text": "3.2 Referencias\n\nR’s rbinom – Simulate Binomial or Bernoulli trials\nR’s rnorm – selecting values from a normal distribution\nR’s exp – Simulating Exponential Distributions\nSimulating data in R"
  },
  {
    "objectID": "importar_datos.html",
    "href": "importar_datos.html",
    "title": "Importar y exportar datos en R",
    "section": "",
    "text": "Código\nsketchy::load_packages(c(\n  \"RColorBrewer\",\n  \"ggplot2\",\n  \"readxl\",\n  \"tidyr\",\n  \"dplyr\"\n))"
  },
  {
    "objectID": "importar_datos.html#establecer-el-directorio-de-trabajo",
    "href": "importar_datos.html#establecer-el-directorio-de-trabajo",
    "title": "Importar y exportar datos en R",
    "section": "2.1 Establecer el directorio de trabajo",
    "text": "2.1 Establecer el directorio de trabajo\nPara leer datos en R es necesario especificar el directorio de trabajo. Se puede establecer con la función setwd(). La forma de hacerlo depende del sistema operativo (windows, mac, Linux). La sintaxis del directorio sigue la estructura anidada de las carpetas. Por ejemplo:\n\n\nCódigo\nsetwd(\"/home/m/Desktop/\")\n\n\n… establece el directorio de trabajo en la carpeta “Desktop”, que se encuentra dentro de “m”, que se encuentra dentro de “home”.\n..;\nAlgunos consejos básicos para establecer el directorio de trabajo:\n\nAsegúrese de que la ubicación está entre comillas\nAsegúrese de que hay una barra diagonal (/) entre los nombres de las carpetas (aunque las barras diagonales dobles parecen funcionar en Windows).\nNo incluya ningún nombre de archivo en el nombre del directorio de la carpeta.\nPara encontrar la ubicación, puede consultar las propiedades de un archivo de esa carpeta y copiarlo.\nLa ruta a la carpeta debe ir entre comillas (““)\nEl nombre debe coincidir exactamente (mejor copiar/pegar)\nUtilice list.files() para comprobar qué archivos están en el directorio de trabajo\nR puede sugerir y autocompletar los nombres de las carpetas pulsando “tab” cuando están entre comillas:\n\n \n\n \n\n2.1.1 Establecer el directorio de trabajo en windows\nEn windows debería ser algo como esto:\n\n\nCódigo\nsetwd(\"C:/location\")\n\n\nTambién pueden hacerlo manualmente (¡solo en windows!):\n\n\nCódigo\nsetwd(choose.dir())\n\n\n \nDebería aparecer una ventana en la que puede elegir la ubicación. Sin embargo, esto sólo se debe utilizar para averiguar la forma correcta de escribir la ubicación del directorio, no como parte de la propia secuencia de comandos.\n \n\n\n2.1.2 Establecer el directorio de trabajo en macOS\nPara mac establecer el directorio de trabajo debe ser algo como esto:\n\n\nCódigo\nsetwd(\"/Users/yourname/..\")\n\n\nno incluya lo que tenga antes de “usuarios” (como en windows)\n \n\n\n2.1.3 Establecer el directorio de trabajo en Linux\nSimilar al código usado en OSX:\n\n\nCódigo\nsetwd(\"/home/m/Desktop/\")\n\n\n \nLa “~” (virgulilla) también puede utilizarse para omitir la carpeta “home” y “user” en Linux:\n\n\nCódigo\nsetwd(\"~/Desktop/\")\n\n\n \nEl directorio de trabajo actual se puede comprobar de la siguiente manera:\n\n\nCódigo\ngetwd()\n\n\n[1] \"/home/marce/Dropbox/courses_and_workshops/estadistica/aprendizaje_estadistico_2024\""
  },
  {
    "objectID": "importar_datos.html#lectura-de-datos",
    "href": "importar_datos.html#lectura-de-datos",
    "title": "Importar y exportar datos en R",
    "section": "2.2 Lectura de datos",
    "text": "2.2 Lectura de datos\nCualquier archivo puede ser leído en R. Sólo es cuestión de hacer saber a R en qué formato está codificado el archivo (por ejemplo, qué convenciones se siguieron al generarlo). Los formatos más comunes para almacenar/intercambiar conjuntos de datos como los que solemos manejar en ciencias biológicas son txt, csv y xls/xlsx.\n \nLa función más utilizada para importar datos en R es read.table. De hecho, la documentación de esta función incluye todas las funciones por defecto para introducir datos:\n\n\nCódigo\n?read.table"
  },
  {
    "objectID": "importar_datos.html#leer-archivos-.txt",
    "href": "importar_datos.html#leer-archivos-.txt",
    "title": "Importar y exportar datos en R",
    "section": "2.3 Leer archivos .txt",
    "text": "2.3 Leer archivos .txt\nLos archivos .txt pueden leerse con read.table. Descarguemos primero un conjunto de datos de libre acceso en formato .txt:\n\n\nCódigo\n# definir el directorio de trabajo\nsetwd(\"INGRESE LA DIRECCION DE LA CARPETA DONDE ESTAN LOS DATOS\")\n\ndownload.file(\n  \"https://raw.githubusercontent.com/maRce10/UCR_ESP_2024/master/pantheria_mammals_data.txt\",\n  destfile = \"pantheria_mammals_data.txt\"\n)\n\n\nYou can also manually download the file from here\n \nEl archivo puede introducirse en R de la siguiente forma:\n\n\nCódigo\n# leer datos\ndatos_pantheria &lt;- read.table(\"pantheria_mammals_data.txt\", stringsAsFactors = FALSE, sep = \"\\t\", header = TRUE)\n\n\n\n\nCódigo\n# explorar estructura\nhead(datos_pantheria)\n\n\n\n\n\n\n\n\nMSW93_Order\nMSW93_Family\nMSW93_Genus\nMSW93_Species\nMSW93_Binomial\nX1.1_ActivityCycle\nX5.1_AdultBodyMass_g\nX8.1_AdultForearmLen_mm\nX13.1_AdultHeadBodyLen_mm\nX2.1_AgeatEyeOpening_d\nX3.1_AgeatFirstBirth_d\nX18.1_BasalMetRate_mLO2hr\nX5.2_BasalMetRateMass_g\nX6.1_DietBreadth\nX7.1_DispersalAge_d\nX9.1_GestationLen_d\nX12.1_HabitatBreadth\nX22.1_HomeRange_km2\nX22.2_HomeRange_Indiv_km2\nX14.1_InterBirthInterval_d\nX15.1_LitterSize\nX16.1_LittersPerYear\nX17.1_MaxLongevity_m\nX5.3_NeonateBodyMass_g\nX13.2_NeonateHeadBodyLen_mm\nX21.1_PopulationDensity_n.km2\nX10.1_PopulationGrpSize\nX23.1_SexualMaturityAge_d\nX10.2_SocialGrpSize\nX24.1_TeatNumber\nX12.2_Terrestriality\nX6.2_TrophicLevel\nX25.1_WeaningAge_d\nX5.4_WeaningBodyMass_g\nX13.3_WeaningHeadBodyLen_mm\nReferences\nX5.5_AdultBodyMass_g_EXT\nX16.2_LittersPerYear_EXT\nX5.6_NeonateBodyMass_g_EXT\nX5.7_WeaningBodyMass_g_EXT\nX26.1_GR_Area_km2\nX26.2_GR_MaxLat_dd\nX26.3_GR_MinLat_dd\nX26.4_GR_MRLat_dd\nX26.5_GR_MaxLong_dd\nX26.6_GR_MinLong_dd\nX26.7_GR_MRLong_dd\nX27.1_HuPopDen_Min_n.km2\nX27.2_HuPopDen_Mean_n.km2\nX27.3_HuPopDen_5p_n.km2\nX27.4_HuPopDen_Change\nX28.1_Precip_Mean_mm\nX28.2_Temp_Mean_01degC\nX30.1_AET_Mean_mm\nX30.2_PET_Mean_mm\n\n\n\n\nRodentia\nMuridae\nAbditomys\nlatidens\nAbditomys latidens\n-999\n268\n-999.00\n223.99\n-999\n-999\n-999\n-999\n-999\n-999\n-999.00\n-999\n-999\n-999\n-999\n-999.00\n-999\n-999.0\n-999.0\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n2152\n-999\n-999\n-999\n-999\n357\n16.94\n16.74\n16.84\n120.97\n120.78\n120.88\n93\n93.00\n93\n0.09\n316.00\n180.00\n1443.00\n1557.0\n\n\nRodentia\nMuridae\nAbrawayaomys\nruschii\nAbrawayaomys ruschii\n-999\n63\n-999.00\n-999.00\n-999\n-999\n-999\n-999\n-999\n-999\n-999.00\n-999\n-999\n-999\n-999\n-999.00\n-999\n-999.0\n-999.0\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n2655\n-999\n-999\n-999\n-999\n126137\n-15.09\n-19.84\n-17.47\n-40.52\n-43.56\n-42.04\n5\n21.21\n7\n0.06\n107.06\n209.10\n1084.47\n1402.4\n\n\nRodentia\nAbrocomidae\nAbrocoma\nbennettii\nAbrocoma bennettii\n1\n251\n-999.00\n-999.00\n-999\n-999\n-999\n-999\n-999\n-999\n-999.00\n3\n-999\n-999\n-999\n4.86\n-999\n27.6\n-999.0\n-999\n142\n-999\n-999\n-999\n-999\n2\n-999\n-999\n-999\n-999\n543;890;1297;1492;2655\n-999\n-999\n-999\n-999\n54616\n-27.71\n-35.58\n-31.64\n-69.40\n-71.70\n-70.55\n0\n63.15\n1\n0.07\n20.44\n17.66\n213.09\n1073.8\n\n\nRodentia\nAbrocomidae\nAbrocoma\nboliviensis\nAbrocoma boliviensis\n-999\n158\n-999.00\n-999.00\n-999\n-999\n-999\n-999\n-999\n-999\n-999.00\n-999\n-999\n-999\n-999\n-999.00\n-999\n-999.0\n-999.0\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n-999\n2655\n-999\n-999\n-999\n-999\n5774\n-17.44\n-18.05\n-17.75\n-63.49\n-64.51\n-64.00\n5\n29.24\n5\n0.04\n82.63\n175.55\n1171.61\n1487.3\n\n\nRodentia\nAbrocomidae\nAbrocoma\ncinerea\nAbrocoma cinerea\n-999\n194\n-999.00\n-999.00\n-999\n-999\n-999\n-999\n-999\n-999\n109.64\n3\n-999\n-999\n-999\n2.20\n-999\n-999.0\n13.3\n-999\n-999\n-999\n-999\n-999\n-999\n2\n-999\n-999\n-999\n-999\n890;1297;1627;2655\n-999\n-999\n-999\n-999\n381391\n-14.43\n-24.35\n-19.39\n-64.27\n-70.60\n-67.43\n0\n13.72\n0\n0.06\n48.46\n35.22\n515.10\n1257.3\n\n\nChiroptera\nPteropodidae\nAcerodon\ncelebensis\nAcerodon celebensis\n-999\n382\n133.49\n201.55\n-999\n-999\n-999\n-999\n-999\n-999\n-999.00\n1\n-999\n-999\n-999\n0.98\n-999\n-999.0\n-999.0\n-999\n-999\n-999\n-999\n-999\n-999\n2\n-999\n-999\n-999\n-999\n978;1297;1658;2151;2655\n-999\n-999\n-999\n-999\n173613\n3.74\n-6.49\n-1.37\n126.34\n118.75\n122.55\n5\n92.68\n17\n0.07\n229.41\n215.47\n1812.60\n1909.2\n\n\n\n\n\n\n\n\n \nEl nombre del archivo está entre comillas y contiene la extensión del archivo.\n \nTenga en cuenta que el valor -999 se utiliza para definir celdas vacías. Podemos leer estos valores como NAs al importar los datos utilizando el argumento ‘na.strings’:\n\n\nCódigo\n# leer datos\ndatos_pantheria &lt;-\n  read.table(\n    \"pantheria_mammals_data.txt\",\n    sep = \"\\t\",\n    header = TRUE,\n    na.strings = \"-999\"\n  )\n\n# explorar estructura\nhead(datos_pantheria)\n\n\n\n\n\n\n\n\nMSW93_Order\nMSW93_Family\nMSW93_Genus\nMSW93_Species\nMSW93_Binomial\nX1.1_ActivityCycle\nX5.1_AdultBodyMass_g\nX8.1_AdultForearmLen_mm\nX13.1_AdultHeadBodyLen_mm\nX2.1_AgeatEyeOpening_d\nX3.1_AgeatFirstBirth_d\nX18.1_BasalMetRate_mLO2hr\nX5.2_BasalMetRateMass_g\nX6.1_DietBreadth\nX7.1_DispersalAge_d\nX9.1_GestationLen_d\nX12.1_HabitatBreadth\nX22.1_HomeRange_km2\nX22.2_HomeRange_Indiv_km2\nX14.1_InterBirthInterval_d\nX15.1_LitterSize\nX16.1_LittersPerYear\nX17.1_MaxLongevity_m\nX5.3_NeonateBodyMass_g\nX13.2_NeonateHeadBodyLen_mm\nX21.1_PopulationDensity_n.km2\nX10.1_PopulationGrpSize\nX23.1_SexualMaturityAge_d\nX10.2_SocialGrpSize\nX24.1_TeatNumber\nX12.2_Terrestriality\nX6.2_TrophicLevel\nX25.1_WeaningAge_d\nX5.4_WeaningBodyMass_g\nX13.3_WeaningHeadBodyLen_mm\nReferences\nX5.5_AdultBodyMass_g_EXT\nX16.2_LittersPerYear_EXT\nX5.6_NeonateBodyMass_g_EXT\nX5.7_WeaningBodyMass_g_EXT\nX26.1_GR_Area_km2\nX26.2_GR_MaxLat_dd\nX26.3_GR_MinLat_dd\nX26.4_GR_MRLat_dd\nX26.5_GR_MaxLong_dd\nX26.6_GR_MinLong_dd\nX26.7_GR_MRLong_dd\nX27.1_HuPopDen_Min_n.km2\nX27.2_HuPopDen_Mean_n.km2\nX27.3_HuPopDen_5p_n.km2\nX27.4_HuPopDen_Change\nX28.1_Precip_Mean_mm\nX28.2_Temp_Mean_01degC\nX30.1_AET_Mean_mm\nX30.2_PET_Mean_mm\n\n\n\n\nRodentia\nMuridae\nAbditomys\nlatidens\nAbditomys latidens\nNA\n268\nNA\n223.99\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2152\nNA\nNA\nNA\nNA\n357\n16.94\n16.74\n16.84\n120.97\n120.78\n120.88\n93\n93.00\n93\n0.09\n316.00\n180.00\n1443.00\n1557.0\n\n\nRodentia\nMuridae\nAbrawayaomys\nruschii\nAbrawayaomys ruschii\nNA\n63\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2655\nNA\nNA\nNA\nNA\n126137\n-15.09\n-19.84\n-17.47\n-40.52\n-43.56\n-42.04\n5\n21.21\n7\n0.06\n107.06\n209.10\n1084.47\n1402.4\n\n\nRodentia\nAbrocomidae\nAbrocoma\nbennettii\nAbrocoma bennettii\n1\n251\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n3\nNA\nNA\nNA\n4.86\nNA\n27.6\nNA\nNA\n142\nNA\nNA\nNA\nNA\n2\nNA\nNA\nNA\nNA\n543;890;1297;1492;2655\nNA\nNA\nNA\nNA\n54616\n-27.71\n-35.58\n-31.64\n-69.40\n-71.70\n-70.55\n0\n63.15\n1\n0.07\n20.44\n17.66\n213.09\n1073.8\n\n\nRodentia\nAbrocomidae\nAbrocoma\nboliviensis\nAbrocoma boliviensis\nNA\n158\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2655\nNA\nNA\nNA\nNA\n5774\n-17.44\n-18.05\n-17.75\n-63.49\n-64.51\n-64.00\n5\n29.24\n5\n0.04\n82.63\n175.55\n1171.61\n1487.3\n\n\nRodentia\nAbrocomidae\nAbrocoma\ncinerea\nAbrocoma cinerea\nNA\n194\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n109.64\n3\nNA\nNA\nNA\n2.20\nNA\nNA\n13.3\nNA\nNA\nNA\nNA\nNA\nNA\n2\nNA\nNA\nNA\nNA\n890;1297;1627;2655\nNA\nNA\nNA\nNA\n381391\n-14.43\n-24.35\n-19.39\n-64.27\n-70.60\n-67.43\n0\n13.72\n0\n0.06\n48.46\n35.22\n515.10\n1257.3\n\n\nChiroptera\nPteropodidae\nAcerodon\ncelebensis\nAcerodon celebensis\nNA\n382\n133.49\n201.55\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n1\nNA\nNA\nNA\n0.98\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n2\nNA\nNA\nNA\nNA\n978;1297;1658;2151;2655\nNA\nNA\nNA\nNA\n173613\n3.74\n-6.49\n-1.37\n126.34\n118.75\n122.55\n5\n92.68\n17\n0.07\n229.41\n215.47\n1812.60\n1909.2"
  },
  {
    "objectID": "importar_datos.html#leer-archivos-.csv",
    "href": "importar_datos.html#leer-archivos-.csv",
    "title": "Importar y exportar datos en R",
    "section": "2.4 Leer archivos .csv",
    "text": "2.4 Leer archivos .csv\nDe nuevo, podemos descargar un archivo de ejemplo en línea:\n\n\nCódigo\n# bajar datos en zip\ndownload.file(\n  \"https://www.birds.cornell.edu/clementschecklist/wp-content/uploads/2023/12/Clements-v2023-October-2023-csv.zip\",\n  destfile = \"clements_bird_list.zip\"\n)\n\n# extraer zip\nunzip(\"clements_bird_list.zip\", files = \"Clements-v2023-October-2023.csv\")\n\n# leer datos\nclm_lst &lt;-\n  read.csv(\"Clements-v2023-October-2023.csv\", stringsAsFactors = FALSE)\n\nhead(clm_lst)\n\n\n\n\n\n\n\n\nsort.v2023\nspecies_code\ntaxon_concept_id\nClements.v2023.change\ntext.for.website.v2023\ncategory\nEnglish.name\nscientific.name\nauthority\nname.and.authority\nrange\norder\nfamily\nextinct\nextinct.year\nsort.v2022\npage.6.0\n\n\n\n\n0\n\n\n\n\n\nClements, J. F., P. C. Rasmussen, T. S. Schulenberg, M. J. Iliff, T. A. Fredericks, J. A. Gerbracht, D. Lepage, A. Spencer, S. M. Billerman, B. L. Sullivan, and C. L. Wood. 2023. The eBird/Clements checklist of birds of the world: v2023. Downloaded from https://www.birds.cornell.edu/clementschecklist/download/\n\n\n\n\n\n\nNA\n\nNA\n\n\n\n1\nstruth1\n\n\n\nfamily\nOstriches\nStruthionidae\n\n\n\nStruthioniformes\nStruthionidae (Ostriches)\nNA\n\n1\n\n\n\n2\nostric2\navibase-2247CB05\n\n\nspecies\nCommon Ostrich\nStruthio camelus\nLinnaeus, 1758\nStruthio camelus Linnaeus, 1758\n\nStruthioniformes\nStruthionidae (Ostriches)\nNA\n\n2\n2\n\n\n3\ncomost1\navibase-E7F58C33\n\n\nsubspecies\n\nStruthio camelus camelus\nLinnaeus, 1758\nStruthio camelus camelus Linnaeus, 1758\nSahel of North Africa and the Sudan\nStruthioniformes\nStruthionidae (Ostriches)\nNA\n\n3\n2\n\n\n4\ncomost2\navibase-06477478\n\n\nsubspecies\n\nStruthio camelus syriacus\nRothschild, 1919\nStruthio camelus syriacus Rothschild, 1919\nFormerly Syrian and Arabian deserts. Extinct ca. 1966\nStruthioniformes\nStruthionidae (Ostriches)\n1\n1966\n4\n2\n\n\n5\ncomost3\navibase-BF8ED7FA\n\n\nsubspecies\n\nStruthio camelus massaicus\nNeumann, 1898\nStruthio camelus massaicus Neumann, 1898\nS Kenya and e Tanzania\nStruthioniformes\nStruthionidae (Ostriches)\nNA\n\n5\n2\n\n\n\n\n\n\n\n\nTambién puede descargar manualmente el archivo desde aquí\n \nComo en el ejemplo anterior, podemos decirle a R cómo identificar las celdas vacías utilizando el argumento na.strings:\n\n\nCódigo\nclm_lst &lt;-\n  read.csv(\n    \"Clements-v2023-October-2023.csv\",\n    stringsAsFactors = FALSE,\n    na.strings = \"\"\n  )\n\nhead(clm_lst)\n\n\n\n\n\n\n\n\nsort.v2023\nspecies_code\ntaxon_concept_id\nClements.v2023.change\ntext.for.website.v2023\ncategory\nEnglish.name\nscientific.name\nauthority\nname.and.authority\nrange\norder\nfamily\nextinct\nextinct.year\nsort.v2022\npage.6.0\n\n\n\n\n0\nNA\nNA\nNA\nNA\nNA\nClements, J. F., P. C. Rasmussen, T. S. Schulenberg, M. J. Iliff, T. A. Fredericks, J. A. Gerbracht, D. Lepage, A. Spencer, S. M. Billerman, B. L. Sullivan, and C. L. Wood. 2023. The eBird/Clements checklist of birds of the world: v2023. Downloaded from https://www.birds.cornell.edu/clementschecklist/download/\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n1\nstruth1\nNA\nNA\nNA\nfamily\nOstriches\nStruthionidae\nNA\nNA\nNA\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n1\nNA\n\n\n2\nostric2\navibase-2247CB05\nNA\nNA\nspecies\nCommon Ostrich\nStruthio camelus\nLinnaeus, 1758\nStruthio camelus Linnaeus, 1758\nNA\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n2\n2\n\n\n3\ncomost1\navibase-E7F58C33\nNA\nNA\nsubspecies\nNA\nStruthio camelus camelus\nLinnaeus, 1758\nStruthio camelus camelus Linnaeus, 1758\nSahel of North Africa and the Sudan\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n3\n2\n\n\n4\ncomost2\navibase-06477478\nNA\nNA\nsubspecies\nNA\nStruthio camelus syriacus\nRothschild, 1919\nStruthio camelus syriacus Rothschild, 1919\nFormerly Syrian and Arabian deserts. Extinct ca. 1966\nStruthioniformes\nStruthionidae (Ostriches)\n1\n1966\n4\n2\n\n\n5\ncomost3\navibase-BF8ED7FA\nNA\nNA\nsubspecies\nNA\nStruthio camelus massaicus\nNeumann, 1898\nStruthio camelus massaicus Neumann, 1898\nS Kenya and e Tanzania\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n5\n2"
  },
  {
    "objectID": "importar_datos.html#leer-archivos-de-excel",
    "href": "importar_datos.html#leer-archivos-de-excel",
    "title": "Importar y exportar datos en R",
    "section": "2.5 Leer archivos de Excel",
    "text": "2.5 Leer archivos de Excel\nLa mayoría de los investigadores introducen los datos en hojas de cálculo Excel. Así que sería bastante práctico leer los datos directamente desde ahí. Para leer archivos xls y xlsx necesitamos instalar el paquete “readxl” (hay otros paquetes que se pueden utilizar pero todos funcionan de forma similar):\n\n\nCódigo\ninstall.packages(pkgs = \"readxl\")\n\nlibrary(readxl)\n\n\n \nComo hicimos anteriormente, descargue un archivo de ejemplo de un repositorio en línea. En este caso es la misma lista de taxonomía de aves de Clements en formato xlsx:\n\n\nCódigo\ndownload.file(\"https://www.birds.cornell.edu/clementschecklist/wp-content/uploads/2023/10/Clements-v2023-October-2023.xlsx\", destfile = \"clements_bird_list.xlsx\")\n\n\nTambién puede descargar manualmente el archivo desde aquí\n \nAhora podemos utilizar la función read_excel() para leer el archivo:\n\n\nCódigo\n# leer archivo\nclm_lst2 &lt;- read_excel(\"clements_bird_list.xlsx\", sheet = 1)\n\nhead(clm_lst2)\n\n\n\n\n\n\n\n\nsort v2023\nspecies_code\ntaxon_concept_id\nClements v2023 change\ntext for website v2023\ncategory\nEnglish name\nscientific name\nauthority\nname and authority\nrange\norder\nfamily\nextinct\nextinct year\nsort v2022\npage 6.0\n\n\n\n\n0\nNA\nNA\nNA\nNA\nNA\nClements, J. F., P. C. Rasmussen, T. S. Schulenberg, M. J. Iliff, T. A. Fredericks, J. A. Gerbracht, D. Lepage, A. Spencer, S. M. Billerman, B. L. Sullivan, and C. L. Wood. 2023. The eBird/Clements checklist of birds of the world: v2023. Downloaded from https://www.birds.cornell.edu/clementschecklist/download/\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\nNA\n\n\n1\nstruth1\nNA\nNA\nNA\nfamily\nOstriches\nStruthionidae\nNA\nNA\nNA\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n1\nNA\n\n\n2\nostric2\navibase-2247CB05\nNA\nNA\nspecies\nCommon Ostrich\nStruthio camelus\nLinnaeus, 1758\nStruthio camelus Linnaeus, 1758\nNA\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n2\n2\n\n\n3\ncomost1\navibase-E7F58C33\nNA\nNA\nsubspecies\nNA\nStruthio camelus camelus\nLinnaeus, 1758\nStruthio camelus camelus Linnaeus, 1758\nSahel of North Africa and the Sudan\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n3\n2\n\n\n4\ncomost2\navibase-06477478\nNA\nNA\nsubspecies\nNA\nStruthio camelus syriacus\nRothschild, 1919\nStruthio camelus syriacus Rothschild, 1919\nFormerly Syrian and Arabian deserts. Extinct ca. 1966\nStruthioniformes\nStruthionidae (Ostriches)\n1\n1966\n4\n2\n\n\n5\ncomost3\navibase-BF8ED7FA\nNA\nNA\nsubspecies\nNA\nStruthio camelus massaicus\nNeumann, 1898\nStruthio camelus massaicus Neumann, 1898\nS Kenya and e Tanzania\nStruthioniformes\nStruthionidae (Ostriches)\nNA\nNA\n5\n2\n\n\n\n\n\n\n\n\n \nYou need to specify the file name (including extension) and the excel sheet (tab) name. read_excel() auto detects the format from the file extension. The functions read_xls() and read_xlsx() can be used to read files without extension.\n \n\n2.5.1 Ejercicio 1\nTodas las funciones predeterminadas para introducir datos en R tienen una contrapartida para exportar el mismo tipo de datos. Los nombres de estas otras funciones son similares a los de las de lectura de datos, aunque suelen empezar por “write” o “save”.\n1.1 ¿Cuáles son los nombres de las funciones por defecto para exportar los formatos de datos que hemos utilizado anteriormente? (pista: prueba apropos para comprobar qué funciones están disponibles)\n1.2 Exportar los datos de mamíferos como archivo .csv.\n1.3 Vuelva a exportar los datos de mamíferos, esta vez excluyendo los nombres de las filas\n1.4 Leer el archivo .csv con read.table.\n1.5 ¿Qué otros paquetes pueden importar archivos excel en R?\n1.6 ¿Se puede exportar un archivo excel o añadir datos a un archivo excel existente desde R?\n1.7 Utilizando el archivo “clements_bird_list.csv”, ¿cómo le diría a R que leyera tanto “Rheiformes” como “Ostriches” como celdas vacías (sin dejar de leer las celdas vacías como celdas vacías)?"
  },
  {
    "objectID": "importar_datos.html#datos-compactos",
    "href": "importar_datos.html#datos-compactos",
    "title": "Importar y exportar datos en R",
    "section": "3.1 Datos compactos",
    "text": "3.1 Datos compactos\nDatos compactos (“tidy data”) es una lógica para organizar conjuntos de datos de forma coherente e intuitiva. Para ejecutar parte del código de abajo necesitarás los paquetes ‘tidyr’ y ‘dplyr’, que se pueden instalar/cargar de la siguiente manera:\n\n\nCódigo\ninstall.packages(pkgs = \"tidyr\")\n\ninstall.packages(pkgs = \"dplyr\")\n\nlibrary(tidyr)\n\nlibrary(dplyr)\n\n\n \nLos mismos datos pueden representarse de muchas maneras. En el ejemplo siguiente, cada conjunto de datos muestra exactamente los mismos valores de cuatro variables país, año, población y casos, pero en cada conjunto de datos los valores están organizados de forma diferente. Los datos muestran el número de casos de tuberculosis en Afganistán, Brasil y China entre 1999 y 2000:\n\n\nCódigo\nas.data.frame(table1)\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\n\n\nCódigo\nas.data.frame(table2)\n\n\n\n\n\n\n\n\ncountry\nyear\ntype\ncount\n\n\n\n\nAfghanistan\n1999\ncases\n745\n\n\nAfghanistan\n1999\npopulation\n19987071\n\n\nAfghanistan\n2000\ncases\n2666\n\n\nAfghanistan\n2000\npopulation\n20595360\n\n\nBrazil\n1999\ncases\n37737\n\n\nBrazil\n1999\npopulation\n172006362\n\n\nBrazil\n2000\ncases\n80488\n\n\nBrazil\n2000\npopulation\n174504898\n\n\nChina\n1999\ncases\n212258\n\n\nChina\n1999\npopulation\n1272915272\n\n\nChina\n2000\ncases\n213766\n\n\nChina\n2000\npopulation\n1280428583\n\n\n\n\n\n\n\n\n\n\nCódigo\nas.data.frame(table3)\n\n\n\n\n\n\n\n\ncountry\nyear\nrate\n\n\n\n\nAfghanistan\n1999\n745/19987071\n\n\nAfghanistan\n2000\n2666/20595360\n\n\nBrazil\n1999\n37737/172006362\n\n\nBrazil\n2000\n80488/174504898\n\n\nChina\n1999\n212258/1272915272\n\n\nChina\n2000\n213766/1280428583\n\n\n\n\n\n\n\n\nO incluso repartidos en 2 conjuntos de datos diferentes:\n\n\nCódigo\nas.data.frame(table4a)\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\nAfghanistan\n745\n2666\n\n\nBrazil\n37737\n80488\n\n\nChina\n212258\n213766\n\n\n\n\n\n\n\n\n\n\nCódigo\nas.data.frame(table4b)\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\nAfghanistan\n19987071\n20595360\n\n\nBrazil\n172006362\n174504898\n\n\nChina\n1272915272\n1280428583\n\n\n\n\n\n\n\n\n \nTodos estos conjuntos de datos contenían los mismos datos subyacentes. Sin embargo, no son igual de fáciles de utilizar.\nExisten tres reglas interrelacionadas para ordenar un conjunto de datos:\n\nCada variable debe tener su propia columna\nEach observation must have its own row\nCada valor debe tener su propia celda\n\nEsta figura muestra las reglas visualmente:\n * Modified from R for Data Science  \nEstas tres reglas están interrelacionadas porque es imposible satisfacer sólo dos de las tres. Esa interrelación conduce a un conjunto aún más sencillo de instrucciones prácticas:\n\nPonga cada conjunto de datos en un marco de datos\nPonga cada variable en una columna\n\n \nEn el ejemplo anterior, sólo la tabla1 está ordenada. Es la única representación en la que cada columna es una variable. Formatear los datos de esta manera tiene dos ventajas principales:\n\nSi tienes una estructura de datos consistente, es más fácil aprender las herramientas que trabajan con ella porque tienen una uniformidad subyacente\nColocar las variables en columnas se ajusta bien a la naturaleza vectorial de R. Como hemos visto, las funciones incorporadas en R trabajan con vectores de valores. Esto hace que la transformación de datos ordenados resulte especialmente natural.\n\n \n\n3.1.1 Ejercicio 2\n2.1 Describa cómo están organizadas las variables y observaciones en cada uno de los marcos de datos de muestreo\n2.2 Calcule la tasa de casos por 10000 personas para “tabla1”, “tabla2” y “tabla4a”/“tabla4b”."
  },
  {
    "objectID": "importar_datos.html#recopilación-de-datos",
    "href": "importar_datos.html#recopilación-de-datos",
    "title": "Importar y exportar datos en R",
    "section": "3.2 Recopilación de datos",
    "text": "3.2 Recopilación de datos\nUn problema habitual es un conjunto de datos en el que algunos de los nombres de las columnas no son nombres de variables, sino valores de una variable. Tomemos “tabla4a”: los nombres de las columnas 1999 y 2000 representan valores de la variable año, y cada fila representa dos observaciones, no una:\n\n\nCódigo\nas.data.frame(table4a)\n\n\n\n\n\n\n\n\ncountry\n1999\n2000\n\n\n\n\nAfghanistan\n745\n2666\n\n\nBrazil\n37737\n80488\n\n\nChina\n212258\n213766\n\n\n\n\n\n\n\n\n \nPara ordenar un conjunto de datos como éste, necesitamos reunir esas columnas en un nuevo par de variables. Para ello necesitamos tres parámetros:\n\nEl conjunto de columnas que representan valores, no variables. En este ejemplo, son las columnas 1999 y 2000.\nEl nombre de la variable cuyos valores forman los nombres de las columnas. En la sintaxis ‘tidyr’ se llama key, que en este caso es year.\nEl nombre de la variable cuyos valores se reparten por las celdas. En la sintaxis ‘tidyr’ que se llama que value, que en este caso es el número de cases\n\nEstos parámetros se pueden utilizar para crear un conjunto de datos ordenados utilizando la función gather():\n\n\nCódigo\ngather(table4a, key = \"year\", value = \"cases\", `1999`, `2000`)\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\n\n\n\n\nAfghanistan\n1999\n745\n\n\nBrazil\n1999\n37737\n\n\nChina\n1999\n212258\n\n\nAfghanistan\n2000\n2666\n\n\nBrazil\n2000\n80488\n\n\nChina\n2000\n213766\n\n\n\n\n\n\n\n\nPodemos visualizar este formato de la siguiente manera:\n * Modified from R for Data Science  \ngather() también se puede utilizar para ordenar table4b. La única diferencia es la variable almacenada en los valores de las celdas:\n\n\nCódigo\ngather(\n  data = table4b,\n  key = \"year\",\n  value = \"population\",\n  `1999`,\n  `2000`\n)\n\n\n\n\n\n\n\n\ncountry\nyear\npopulation\n\n\n\n\nAfghanistan\n1999\n19987071\n\n\nBrazil\n1999\n172006362\n\n\nChina\n1999\n1272915272\n\n\nAfghanistan\n2000\n20595360\n\n\nBrazil\n2000\n174504898\n\n\nChina\n2000\n1280428583\n\n\n\n\n\n\n\n\n \nPara combinar las versiones ordenadas de las tablas table4a y table4b en un único marco de datos (o ‘tibble’), podemos utilizar dplyr::left_join() o merge() de la base R:\n\n\nCódigo\ntidy4a &lt;-\n  gather(table4a, key = \"year\", value = \"cases\", `1999`, `2000`)\n\ntidy4b &lt;-\n  gather(table4b, key = \"year\", value = \"population\", `1999`, `2000`)\n\nleft_join(\n  x = tidy4a,\n  y = tidy4b,\n  by = c(\"country\", \"year\")\n)\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nBrazil\n1999\n37737\n172006362\n\n\nChina\n1999\n212258\n1272915272\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\n\n\nCódigo\nmerge(\n  x = tidy4a,\n  y = tidy4b,\n  by = c(\"country\", \"year\")\n)\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583"
  },
  {
    "objectID": "importar_datos.html#expandir-spreading",
    "href": "importar_datos.html#expandir-spreading",
    "title": "Importar y exportar datos en R",
    "section": "3.3 Expandir (spreading)",
    "text": "3.3 Expandir (spreading)\nEl expandir es lo contrario de la agrupación. Se utiliza cuando una observación está dispersa en varias filas. Por ejemplo, en la tabla2 una observación es un país en un año, pero cada observación está dispersa en dos filas:\n\n\nCódigo\ntable2\n\n\n\n\n\n\n\n\ncountry\nyear\ntype\ncount\n\n\n\n\nAfghanistan\n1999\ncases\n745\n\n\nAfghanistan\n1999\npopulation\n19987071\n\n\nAfghanistan\n2000\ncases\n2666\n\n\nAfghanistan\n2000\npopulation\n20595360\n\n\nBrazil\n1999\ncases\n37737\n\n\nBrazil\n1999\npopulation\n172006362\n\n\nBrazil\n2000\ncases\n80488\n\n\nBrazil\n2000\npopulation\n174504898\n\n\nChina\n1999\ncases\n212258\n\n\nChina\n1999\npopulation\n1272915272\n\n\nChina\n2000\ncases\n213766\n\n\nChina\n2000\npopulation\n1280428583\n\n\n\n\n\n\n\n\n \nPara ordenar este conjunto de datos, sólo necesitamos dos parámetros:\n\nLa columna que contiene los nombres de las variables, la columna key. Aquí, es type.\nLa columna que contiene los valores de las variables múltiples, la columna value. la columna value. Aquí es count.\n\n \nPara hacer esto podemos usar spread():\n\n\nCódigo\nspread(table2, key = \"type\", value = \"count\")\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\n \nque puede visualizarse de la siguiente manera:\n * Modified from R for Data Science  \nspread() y gather() son funciones complementarias. gather() hace las tablas anchas más estrechas y largas; spread() hace las tablas largas más cortas y anchas.\n \n\n3.3.1 Ejercicio 3\n3.1 Ordena el siguiente conjunto de datos sobre la altura de los árboles de 2 especies:\n\n\nCódigo\nplnt_sz &lt;- data.frame(\n  forest = c(\"old_growth\", \"disturbed\"),\n  Species_1 = c(154, 160),\n  Species_2 = c(120, 113)\n)"
  },
  {
    "objectID": "importar_datos.html#separar-y-unir",
    "href": "importar_datos.html#separar-y-unir",
    "title": "Importar y exportar datos en R",
    "section": "3.4 Separar y unir",
    "text": "3.4 Separar y unir\nHasta ahora hemos arreglado “tabla2” y “tabla4”, pero no “tabla3”. La “tabla3” tiene un problema diferente: tenemos una columna (tasa) que contiene dos variables (casos y población). Esto puede solucionarse con la función separate() . También veremos su complemento unite(), que se utiliza cuando una sola variable está repartida en varias columnas.\n \n\n3.4.1 Separar\nLa función separate() separa una columna en varias columnas, dividiéndolas donde aparezca un carácter separador. Por ejemplo, table3:\n\n\nCódigo\nas.data.frame(table3)\n\n\n\n\n\n\n\n\ncountry\nyear\nrate\n\n\n\n\nAfghanistan\n1999\n745/19987071\n\n\nAfghanistan\n2000\n2666/20595360\n\n\nBrazil\n1999\n37737/172006362\n\n\nBrazil\n2000\n80488/174504898\n\n\nChina\n1999\n212258/1272915272\n\n\nChina\n2000\n213766/1280428583\n\n\n\n\n\n\n\n\nVisualmente hace algo así:\n * Modified from R for Data Science\n \nLa columna tasa contiene las variables casos y población, y necesitamos separarla en dos variables. separate() toma el nombre de la columna a separar, y los nombres de las nuevas columnas a crear:\n\n\nCódigo\nseparate(\n  data = table3,\n  col = rate,\n  into = c(\"cases\", \"population\")\n)\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\nDe forma predeterminada, separate() dividirá basándose en cualquier carácter no alfanumérico (es decir, un carácter que no sea un número o una letra). En el código anterior, separate() divide los valores de rate en los caracteres de la barra diagonal. Esto puede indicarse explícitamente (para evitar errores):\n\n\nCódigo\ntb3 &lt;-\n  separate(\n    data = table3,\n    col = rate,\n    into = c(\"cases\", \"population\"),\n    sep = \"/\"\n  )\n\ntb3\n\n\n\n\n\n\n\n\ncountry\nyear\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745\n19987071\n\n\nAfghanistan\n2000\n2666\n20595360\n\n\nBrazil\n1999\n37737\n172006362\n\n\nBrazil\n2000\n80488\n174504898\n\n\nChina\n1999\n212258\n1272915272\n\n\nChina\n2000\n213766\n1280428583\n\n\n\n\n\n\n\n\ntibble [6 × 4] (S3: tbl_df/tbl/data.frame)\n $ country   : chr [1:6] \"Afghanistan\" \"Afghanistan\" \"Brazil\" \"Brazil\" ...\n $ year      : num [1:6] 1999 2000 1999 2000 1999 ...\n $ cases     : chr [1:6] \"745\" \"2666\" \"37737\" \"80488\" ...\n $ population: chr [1:6] \"19987071\" \"20595360\" \"172006362\" \"174504898\" ...\n\n\n \nTenga en cuenta que case y population son columnas de caracteres. Por defecto separate() deja el tipo de las nuevas columnas como en la original. En este caso esto no es lo ideal ya que realmente son números. Podemos pedir a separate() que intente convertir a tipos mejores usando convert = TRUE:\n\n\nCódigo\ntb3 &lt;-\n  separate(\n    data = table3,\n    col = rate,\n    into = c(\"cases\", \"population\"),\n    convert = TRUE\n  )\n\nstr(tb3)\n\n\ntibble [6 × 4] (S3: tbl_df/tbl/data.frame)\n $ country   : chr [1:6] \"Afghanistan\" \"Afghanistan\" \"Brazil\" \"Brazil\" ...\n $ year      : num [1:6] 1999 2000 1999 2000 1999 ...\n $ cases     : int [1:6] 745 2666 37737 80488 212258 213766\n $ population: int [1:6] 19987071 20595360 172006362 174504898 1272915272 1280428583\n\n\n \nTambién puede pasar un vector de enteros a sep, que serán interpretados como posiciones en las que dividir. Los valores positivos comienzan en 1 en el extremo izquierdo de las cadenas; los valores negativos comienzan en -1 en el extremo derecho de las cadenas. Cuando se usan enteros para separar cadenas, la longitud de sep debe ser uno menos que el número de nombres en into. Puede utilizarlo para separar los dos últimos dígitos de cada año:\n\n\nCódigo\nseparate(\n  data = table3,\n  col = year,\n  into = c(\"century\", \"year\"),\n  sep = 2\n)\n\n\n\n\n\n\n\n\ncountry\ncentury\nyear\nrate\n\n\n\n\nAfghanistan\n19\n99\n745/19987071\n\n\nAfghanistan\n20\n00\n2666/20595360\n\n\nBrazil\n19\n99\n37737/172006362\n\n\nBrazil\n20\n00\n80488/174504898\n\n\nChina\n19\n99\n212258/1272915272\n\n\nChina\n20\n00\n213766/1280428583\n\n\n\n\n\n\n\n\nLa separación de columnas también se puede hacer con la base R, aunque requiere un poco más de codificación:\n\n\nCódigo\ntable3$cases &lt;-\n  sapply(table3$rate, function(x) {\n    try(strsplit(x, \"/\")[[1]][1])\n  },\n  USE.NAMES = FALSE\n  )\n\ntable3$population &lt;-\n  sapply(table3$rate, function(x) {\n    try(strsplit(x, \"/\")[[1]][2])\n  },\n  USE.NAMES = FALSE\n  )\n\ntb3\n\n\n\n\n\n\n\n\ncountry\nyear\nrate\ncases\npopulation\n\n\n\n\nAfghanistan\n1999\n745/19987071\n745\n19987071\n\n\nAfghanistan\n2000\n2666/20595360\n2666\n20595360\n\n\nBrazil\n1999\n37737/172006362\n37737\n172006362\n\n\nBrazil\n2000\n80488/174504898\n80488\n174504898\n\n\nChina\n1999\n212258/1272915272\n212258\n1272915272\n\n\nChina\n2000\n213766/1280428583\n213766\n1280428583\n\n\n\n\n\n\n\n\ntibble [6 × 4] (S3: tbl_df/tbl/data.frame)\n $ country   : chr [1:6] \"Afghanistan\" \"Afghanistan\" \"Brazil\" \"Brazil\" ...\n $ year      : num [1:6] 1999 2000 1999 2000 1999 ...\n $ cases     : chr [1:6] \"745\" \"2666\" \"37737\" \"80488\" ...\n $ population: chr [1:6] \"19987071\" \"20595360\" \"172006362\" \"174504898\" ..."
  },
  {
    "objectID": "importar_datos.html#unir",
    "href": "importar_datos.html#unir",
    "title": "Importar y exportar datos en R",
    "section": "3.5 Unir",
    "text": "3.5 Unir\nunite() es la inversa de separate(): combinar varias columnas en una sola:\n * Modified from R for Data Science\n \nSin embargo, la necesitará con mucha menos frecuencia que separate().\nPodemos utilizar unite() para volver a unir las columnas century y year que creamos anteriormente:\n\n\nCódigo\nunite(data = table5, col = \"new\", \"century\", \"year\")\n\n\n\n\n\n\n\n\ncountry\nnew\nrate\n\n\n\n\nAfghanistan\n19_99\n745/19987071\n\n\nAfghanistan\n20_00\n2666/20595360\n\n\nBrazil\n19_99\n37737/172006362\n\n\nBrazil\n20_00\n80488/174504898\n\n\nChina\n19_99\n212258/1272915272\n\n\nChina\n20_00\n213766/1280428583\n\n\n\n\n\n\n\n\nEn esta función también podemos utilizar el argumento sep (aunque en este ejemplo no se ha especificado).\n \n\n3.5.1 Ejercicio 4\n\n4.1 Una century y year de la “tabla5” usando R básico (pista: paste())"
  },
  {
    "objectID": "importar_datos.html#referencias",
    "href": "importar_datos.html#referencias",
    "title": "Importar y exportar datos en R",
    "section": "4.1 Referencias",
    "text": "4.1 Referencias\n\nClements, J. F., T. S. Schulenberg, M. J. Iliff, D. Roberson, T. A. Fredericks, B. L. Sullivan, and C. L. Wood. 2017. The eBird/Clements checklist of birds of the world: v2016.\nJones, Jon Bielby, Marcel Cardillo, Susanne A. Fritz, Justin O’Dell, C. David L. Orme, Kamran Safi, Wes Sechrest, Elizabeth H. Boakes, Chris Carbone, Christina Connolly, Michael J. Cutts, Janine K. Foster, Richard Grenyer, Michael Habib, Christopher A. Plaster, Samantha A. Price, Elizabeth A. Rigby, Janna Rist, Amber Teacher, Olaf R. P. Bininda-Emonds, John L. Gittleman, Georgina M. Mace, and Andy Purvis. 2009. PanTHERIA: a species-level database of life history, ecology, and geography of extant and recently extinct mammals. Ecology 90:2648.\nWickham, Hadley, and Garrett Grolemund. 2016. R for data science: import, tidy, transform, visualize, and model data. website\nData import tutorial- DataCamp"
  },
  {
    "objectID": "importar_datos.html#información-de-la-sesión",
    "href": "importar_datos.html#información-de-la-sesión",
    "title": "Importar y exportar datos en R",
    "section": "Información de la sesión",
    "text": "Información de la sesión\n\n\nR version 4.3.2 (2023-10-31)\nPlatform: x86_64-pc-linux-gnu (64-bit)\nRunning under: Ubuntu 22.04.2 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.10.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.10.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Costa_Rica\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] dplyr_1.1.4        tidyr_1.3.1        readxl_1.4.3       kableExtra_1.4.0  \n[5] RColorBrewer_1.1-3 viridis_0.6.5      viridisLite_0.4.2  ggplot2_3.5.1     \n[9] knitr_1.48        \n\nloaded via a namespace (and not attached):\n [1] gtable_0.3.5        jsonlite_1.8.8      highr_0.11         \n [4] crayon_1.5.3        compiler_4.3.2      tidyselect_1.2.1   \n [7] xml2_1.3.6          stringr_1.5.1       gridExtra_2.3      \n[10] systemfonts_1.1.0   scales_1.3.0        yaml_2.3.10        \n[13] fastmap_1.2.0       R6_2.5.1            generics_0.1.3     \n[16] htmlwidgets_1.6.4   tibble_3.2.1        munsell_0.5.1      \n[19] xaringanExtra_0.7.0 svglite_2.1.3       pillar_1.9.0       \n[22] rlang_1.1.4         utf8_1.2.4          stringi_1.8.4      \n[25] xfun_0.47           cli_3.6.3           withr_3.0.1        \n[28] magrittr_2.0.3      digest_0.6.37       grid_4.3.2         \n[31] rstudioapi_0.16.0   remotes_2.5.0       packrat_0.9.2      \n[34] lifecycle_1.0.4     vctrs_0.6.5         evaluate_0.24.0    \n[37] glue_1.7.0          cellranger_1.1.0    sketchy_1.0.3      \n[40] fansi_1.0.6         colorspace_2.1-0    purrr_1.0.2        \n[43] rmarkdown_2.27      tools_4.3.2         pkgconfig_2.0.3    \n[46] htmltools_0.5.8.1"
  }
]